<section><title>pipes</title>
	<para>One of the most powerful advantages of unix is the use of <command>pipes</command><indexterm><primary>pipe</primary></indexterm>, and the ability of almost any program to be used in a pipe. A pipe takes <command>stdout</command><indexterm><primary>stdout</primary></indexterm> from the previous command and sends it as <command>stdin</command><indexterm><primary>stdin</primary></indexterm> to the next command in the pipe. Pipes can have many commands, and all commands in a pipe can be running simultaneously.</para>
	<para> What follows after the introduction to pipes is a number of small unix tools that do one specific task very well. These can be used as building blocks for more complex applications and solutions.</para>
	<para>You still remember cat and tac right ?</para>
	<screen>
[paul@RHEL4b pipes]$ cat count.txt 
one
two
three
four
five
[paul@RHEL4b pipes]$ tac count.txt 
five
four
three
two
one
[paul@RHEL4b pipes]$
	</screen>
	<para>A pipe is represented by a vertical bar <command>&#124;</command><indexterm><primary>&#124;</primary></indexterm> in between two commands. Below a very simple pipe.</para>
	<screen>
[paul@RHEL4b pipes]$ cat count.txt | tac
five
four
three
two
one
[paul@RHEL4b pipes]$ 
	</screen>
	<para>But pipes can be longer, as in this example.</para>
	<screen>
[paul@RHEL4b pipes]$ cat count.txt | tac | tac
one
two
three
four
five
[paul@RHEL4b pipes]$ 
	</screen>
	<para>Remember that I told you in the beginning of this book that the cat command is actually doing nothing ?</para>
	<screen>
[paul@RHEL4b pipes]$ tac count.txt | cat | cat | cat | cat | cat
five
four
three
two
one
[paul@RHEL4b pipes]$
	</screen>
</section>
<section><title>tee</title>
	<para>Writing long pipes in unix is fun, but sometimes you might want intermediate results. This is were <command>tee</command><indexterm><primary>tee(1)</primary></indexterm> comes in handy, tee outputs both to a file and to stdout. So tee is almost the same as cat, except that it has two identical outputs.</para>
	<screen>
[paul@RHEL4b pipes]$ tac count.txt | tee temp.txt | tac
one
two
three
four
five
[paul@RHEL4b pipes]$ cat temp.txt 
five
four
three
two
one
[paul@RHEL4b pipes]$
	</screen>
</section>
<section><title>grep</title>
	<para>Time for the real tools now. With all the uses of <command>grep</command><indexterm><primary>grep(1)</primary></indexterm> you can probably fill a book. The most common use of grep is to filter results on keywords.</para>
	<screen>
[paul@RHEL4b pipes]$ cat tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | grep Williams
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
	</screen>
	<para>You can write this without the cat.</para>
	<screen>
[paul@RHEL4b pipes]$ grep Williams tennis.txt 
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
	</screen>
	<para>One of the most useful options of grep is <command>grep -i</command><indexterm><primary>grep -i</primary></indexterm> which filters in a case insensitive way.</para>
	<screen>
[paul@RHEL4b pipes]$ grep Bel tennis.txt 
Justine Henin, Bel
[paul@RHEL4b pipes]$ grep -i Bel tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$ 
	</screen>
	<para>Another very useful option is <command>grep -v</command><indexterm><primary>grep -v</primary></indexterm> which outputs lines not matching the string.</para>
	<screen>
[paul@RHEL4b pipes]$ grep -v Fra tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
	</screen>
	<para>And of course, both options can be combined.</para>
	<screen>
[paul@RHEL4b pipes]$ grep -vi usa tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$
	</screen>
</section>
<section><title>cut</title>
	<para>With <command>cut</command><indexterm><primary>cut(1)</primary></indexterm> you can select columns from files, depending on a delimiter or a count of bytes. The screenshot below uses cut to filter for the username and userid in the /etc/passwd file. It uses the colon as a delimiter, and select fields 1 and 3.</para>
	<screen>
[[paul@RHEL4b pipes]$ cut -d: -f1,3 /etc/passwd | tail -4 
Figo:510
Pfaff:511
Harry:516
Hermione:517
[paul@RHEL4b pipes]$ 
	</screen>
	<para>When using a space as the delimiter for cut, you have to quote the space.</para>
	<screen>
[paul@RHEL4b pipes]$ cut -d" " -f1 tennis.txt 
Amelie
Kim
Justine
Serena
Venus
[paul@RHEL4b pipes]$
	</screen>
	<para>One last example, cutting the second to the seventh character of /etc/passwd.</para>
	<screen>
[paul@RHEL4b pipes]$ cut -c2-7 /etc/passwd | tail -4
igo:x:
faff:x
arry:x
ermion
[paul@RHEL4b pipes]$
	</screen>
</section>
<section><title>tr</title>
	<para>You can translate characters with <command>tr</command><indexterm><primary>tr(1)</primary></indexterm>. The screenshot translates all occurences of e to E.</para>
	<screen>
[paul@RHEL4b pipes]$ cat tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'e' 'E'
AmEliE MaurEsmo, Fra
Kim ClijstErs, BEL
JustinE HEnin, BEl
SErEna Williams, usa
VEnus Williams, USA
[paul@RHEL4b pipes]$
	</screen>
	<para>Here we set all letters to uppercase by defining two ranges.</para>
	<screen>
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'a-z' 'A-Z'
AMELIE MAURESMO, FRA
KIM CLIJSTERS, BEL
JUSTINE HENIN, BEL
SERENA WILLIAMS, USA
VENUS WILLIAMS, USA
[paul@RHEL4b pipes]$
	</screen>
	<para>Here we translate all newlines to spaces.</para>
	<screen>
[paul@RHEL4b pipes]$ cat count.txt 
one
two
three
four
five
[paul@RHEL4b pipes]$ cat count.txt | tr '\n' ' '
one two three four five [paul@RHEL4b pipes]$
	</screen>
	<para>The tr filter can also be used to squeeze multiple occurences of a character to one.</para>
	<screen>
[paul@RHEL4b pipes]$ cat spaces.txt 
one    two        three
     four   five  six
[paul@RHEL4b pipes]$ cat spaces.txt | tr -s ' '
one two three
 four five six
[paul@RHEL4b pipes]$
	</screen>
	<para>You can also use tr to 'encrypt' texts with rot13.</para>
	<screen>
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'nopqrstuvwxyzabcdefghijklm'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'n-za-m'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ 
	</screen>
	<para>tr -d to delete characters</para>
</section>
<section><title>wc</title>
	<para>Counting words, lines and characters is easy with <command>wc</command><indexterm><primary>wc(1)</primary></indexterm>. </para>
	<screen>
[paul@RHEL4b pipes]$ wc tennis.txt 
  5  15 100 tennis.txt
[paul@RHEL4b pipes]$ wc -l tennis.txt 
5 tennis.txt
[paul@RHEL4b pipes]$ wc -w tennis.txt 
15 tennis.txt
[paul@RHEL4b pipes]$ wc -c tennis.txt 
100 tennis.txt
[paul@RHEL4b pipes]$
	</screen>
	<para>How many users are logged on to this system ?</para>
	<screen>
[paul@RHEL4b pipes]$ who
root     tty1         Jul 25 10:50
paul     pts/0        Jul 25 09:29 (laika)
Harry    pts/1        Jul 25 12:26 (barry)
paul     pts/2        Jul 25 12:26 (pasha)
[paul@RHEL4b pipes]$ who | wc -l
4
[paul@RHEL4b pipes]$ 
	</screen>
</section>
<section><title>sort</title>
	<para>Sorting is always useful. The <command>sort</command><indexterm><primary>sort(1)</primary></indexterm> filter has a lot of options. How about a sorted list of logged on users.</para>
	<screen>
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root
[paul@RHEL4b pipes]$
	</screen>
	<para>Sorting on column 1 or column 2.</para>
	<screen>
[paul@RHEL4b pipes]$ sort -k1 country.txt 
Belgium, Brussels, 10
France, Paris, 60
Germany, Berlin, 100
Iran, Teheran, 70
Italy, Rome, 50
[paul@RHEL4b pipes]$ sort -k2 country.txt 
Germany, Berlin, 100
Belgium, Brussels, 10
France, Paris, 60
Italy, Rome, 50
Iran, Teheran, 70
[paul@RHEL4b pipes]$ 
	</screen>
	<para>The screenshot below shows the difference between an alfabetical sort and a numerical sort (both on the third column).</para>
	<screen>
[paul@RHEL4b pipes]$ sort -k3 country.txt 
Belgium, Brussels, 10
Germany, Berlin, 100
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
[paul@RHEL4b pipes]$ sort -n -k3 country.txt 
Belgium, Brussels, 10
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
Germany, Berlin, 100
[paul@RHEL4b pipes]$
	</screen>
</section>
<section><title>uniq</title>
	<para>With <command>uniq</command><indexterm><primary>uniq(1)</primary></indexterm> you can remove duplicates from a sorted list. Here's a sorted list of logged on users, first with and then without duplicates.</para>
	<screen>
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort | uniq
Harry
paul
root
[paul@RHEL4b pipes]$
	</screen>
	<para>uniq -c counts...</para>
</section>
<section><title>find</title>
	<para>The <command>find</command><indexterm><primary>find(1)</primary></indexterm> tool is used very often in linux. Find is useful at the start of a pipe, to search for files. Here are some examples. In real life, you will want to add 2&#062;/dev/null to the command lines to avoid cluttering your screen with error messages.</para>
	<para>Find all files in /etc and put the list in etcfiles.txt</para>
	<screen>find /etc &#062; etcfiles.txt</screen>
	<para>Find all files of the entire system and put the list in allfiles.txt</para>
	<screen>find / &#062; allfiles.txt</screen>
	<para>Find files that end in .conf in the current directory (and all subdirs).</para>
	<screen>find . -name "*.conf"</screen>
	<para>Find files of type file (so not directory or pipe...) that end in .conf.</para>
	<screen>find . -type f -name "*.conf"</screen>
	<para>Find files of type directory that end in .bak.</para>
	<screen>find /data -type d -name "*.bak"</screen>
	<para>Find files that are newer than file44.txt</para>
	<screen>find . -newer fil44.txt</screen>
	<para>Find can also execute another command on every file found. This example will look for *.odf files and copy them to /backup/.</para>
	<screen>find "/data/*.odf" -exec cp {} /backup/ \;</screen>
	<para>Find can also execute, after your confirmation, another command on every file found. This example will remove *.odf files if you approve of it for every file found.</para>
	<screen>find "/data/*.odf" -ok rm {} \;</screen>
	<para>The find tool can do much more, see the man page.</para>
</section>
<section><title>locate</title>
	<para>The <command>locate</command><indexterm><primary>locate(1)</primary></indexterm> tool is very different from <command>find</command> in that it uses an index to locate files. This is a lot faster than traversing all the directories, but it also means that it is always outdated. If the index does not exist yet, then you have to create it (as root on Red Hat Enterprise Linux) with the <command>updatedb</command><indexterm><primary>updatedb(1)</primary></indexterm> command.</para>
	<screen>
[paul@RHEL4b ~]$ locate Samba
warning: locate: could not open database: /var/lib/slocate/slocate.db:...
warning: You need to run the 'updatedb' command (as root) to create th...
Please have a look at /etc/updatedb.conf to enable the daily cron job.
[paul@RHEL4b ~]$ updatedb 
fatal error: updatedb: You are not authorized to create a default sloc...
[paul@RHEL4b ~]$ su -
Password: 
[root@RHEL4b ~]# updatedb
[root@RHEL4b ~]# 
	</screen>
	<para>Most Linux distributions will schedule the <command>updatedb</command> to run once every day.</para>
</section>
<section><title>diff</title>
	<para>To compare two files line by line, you can use <command>diff</command><indexterm><primary>diff(1)</primary></indexterm>. To ignore blanks, use <command>diff -b</command>, and to ignore case, use <command>diff -i</command>.</para>
	<para>In this examples diff tells you 2c2 the second line in file one was changed with the second line in file two.</para>
	<screen>
[paul@RHEL4b test]$ cat &#062; count.txt
one
two
three
four
[paul@RHEL4b test]$ cat &#062; count2.txt
one
Two
three
four
[paul@RHEL4b test]$ diff count.txt count2.txt 
2c2
&#060; two
---
&#062; Two
[paul@RHEL4b test]$
	</screen>
	<para>Another example of diff. The second file now has one more line than the first file. After line 2, a line was added as line 3 (2a3) to the second file.</para>
	<screen>
[paul@RHEL4b test]$ cat &#062; count.txt 
one
two
four
[paul@RHEL4b test]$ cat &#062; count2.txt 
one
two
three
four
[paul@RHEL4b test]$ diff count.txt count2.txt 
2a3
&#062; three
[paul@RHEL4b test]$
	</screen>
</section>
<section><title>comm</title>
	<para>You can use <command>comm</command><indexterm><primary>comm(1)</primary></indexterm> to quickly compare two sorted files. By default comm will output three columns. In this example, Abba, Cure and Queen are in both lists, Bowie and Sweet are only in the first file, Turner is only in the second.</para>
	<screen>
[paul@RHEL4b test]$ cat &#062; list1.txt
Abba
Bowie
Cure
Queen
Sweet
[paul@RHEL4b test]$ cat &#062; list2.txt
Abba
Cure
Queen
Turner
[paul@RHEL4b test]$ comm list1.txt list2.txt 
                Abba
Bowie
                Cure
                Queen
Sweet
        Turner
[paul@RHEL4b test]$ 			
       </screen>
</section>
<section><title>compress</title>
	<para>Users never have enough space, so compression comes in handy. The <command>compress</command><indexterm><primary>compress(1)</primary></indexterm> command can make files take up less space. You can get the original back with <command>uncompress</command><indexterm><primary>uncompress(1)</primary></indexterm>. In the backup chapter we will also discuss gzip, gunzip, bzip2 and bunzip2.</para>
	<screen>
[paul@RHEL4b test]$ ls -lh
total 19M
-rw-rw-r--  1 paul paul 19M Jul 26 04:21 allfiles.txt
[paul@RHEL4b test]$ compress allfiles.txt 
[paul@RHEL4b test]$ ls -lh
total 3.2M
-rw-rw-r--  1 paul paul 3.2M Jul 26 04:21 allfiles.txt.Z
[paul@RHEL4b test]$ uncompress allfiles.txt 
[paul@RHEL4b test]$ ls -lh
total 19M
-rw-rw-r--  1 paul paul 19M Jul 26 04:21 allfiles.txt
[paul@RHEL4b test]$ 
	</screen>
</section>
<section><title>od</title>
	<para>European humans like to work with ascii characters, but computers store files in bytes. The example below creates a simple file, and then uses <command>od</command><indexterm><primary>od(1)</primary></indexterm> to show the contents of the file in hexadecimal bytes, in octal bytes and in ascii (or backslashed) characters.</para>
	<screen>
paul@laika:~/test$ cat > text.txt
abcdefg
1234567
paul@laika:~/test$ od -t x1 text.txt 
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020
paul@laika:~/test$ od -b text.txt 
0000000 141 142 143 144 145 146 147 012 061 062 063 064 065 066 067 012
0000020
paul@laika:~/test$ od -c text.txt 
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
paul@laika:~/test$
	</screen>
</section>
<section><title>other tools and filters</title>
	<para>You might want to look at expand, unexpand, pr, nl, fmt, paste, join, sed, awk, ...</para>
</section>
<section><title>Practice tools and filters</title>
	<para>1. Explain the difference between these two commands. This question is very important. If you don't know the answer, then look back at the bash chapters.</para>
	<screen>find . -name "*.txt"</screen>
	<screen>find . -name *.txt</screen>
	<para>2. Explain the difference between these two statements. Will they both work when there are 200 .odf files in /data/ ? How about when there are 2 million .odf files ?</para>
	<screen>find /data -name "*.odf" > data_odf.txt</screen>
	<screen>find /data/*.odf > data_odf.txt</screen>
	<para>3. Write a find command that finds all files created after january 30th this year.</para>	
	<para>4. Write a find command that finds all *.odf files created in september last year.</para>
	<para>5. Put a sorted list of all bash users in bashusers.txt.</para>
	<para>6. Put a sorted list of all bash users, with their username, userid and home directory in bashusers.info.</para>
	<para>7. Make a list of all non-bash and non-korn users.</para>
	<para>8. Make a list of all files (not directories) in /etc/ that contain the string smb, nmb or samba.</para>
	<para>9. Look at the output of /sbin/ifconfig. Make an ipconfig command that shows only the nic name (eth0), the ip address and the subnet mask.</para>
	<para>10. Make a command abc that removes all non-letters from a file (and replaces them with spaces).</para>
	<para>11. Count the number of *.conf files in /etc and all its subdirs.</para>	
	<para>12. Two commands that do the same thing: copy *.odf files to /backup/ . What would be a reason to replace the first command with the second ? Again, this is an important question.</para>
	<screen>cp -r /data/*.odf /backup/</screen>
	<screen>find /data -name "*.odf" -exec cp {} /backup/ \;</screen>
	<para>13. Create a file called loctest.txt. Can you find this file with locate ? Why not ? How do you make locate find this file ?</para>
	<para>14. Create a file named text.txt that contains this sentence: The zun is shining today. Create a file DICT that contains the words "is shining sun the today", one word on each line. The first file is a text, the second file is a dictionary. Now create a spell checker that uses those two files and outputs the misspelled words (in this case that would be 'zun').</para>
	<para>15. Use find and -exec to rename all .htm files to .html.</para>	
	<para>16. Find the hexadecimal byte value for ascii characters : " 'space' 'tab' A and a .</para>	
	<para>17. List all files in the current directory of size between 10 and 20 bytes.</para>
	<para>18. List all files in your home directory that have more than one hard link (hint: use the find tool).</para>	
	<para></para>	
	<para></para>	
	<para>Always take time to properly <command>document</command> every script that you write!</para>
	<para></para>	
	<para>Image copied from <command>xkcd.com</command><indexterm><primary>http://xkcd.com</primary></indexterm>.</para>
	<mediaobject><imageobject><imagedata fileref="images/command_line_fu.jpg" format="EPS" align="center"></imagedata></imageobject></mediaobject>	
	<para></para>	
</section>
<section><title>Solutions: tools and filters</title>
	<para>1. The shell will not touch the *.txt because it is between double quotes. The find tool will look in the current directory for all files ending in .txt.</para>
	<screen>find . -name "*.txt"</screen>
	<para>The shell will expand the *.txt to all files in the current directory that end in .txt. Then find will give you a syntax error.</para>
	<screen>find . -name *.txt</screen>
	<para>3. use find with the -newer option related to a marker file>/para>
	<screen>touch -t 200901302359 marker_date
find . -type f -newer marker_date </screen>
	<para>4. the same as 3. but add a negation to create an "older than" statement</para>
	<screen>touch -t 200808312359 marker_date_start
touch -t 2008100100 marker_date_end
find . -type f -newer marker -_date_start ! -newer marker_date_end </screen>
	<para>14. The one line spell checker.</para>
	<screen>
[paul]$ echo "The zun is shining today" > text.txt
[paul]$ cat > DICT
is
shining
sun
the
today
[paul]$ cat text.txt| tr 'A-Z ' 'a-z\n' |sort|uniq|comm -2 -3 - DICT
zun
[paul]$
	</screen>
	<para>18. Use find to look in your home directory(~) for regular files(-type f) that do not(!) have one hard link(-links 1).</para>
	<screen>find ~ ! -links 1 -type f</screen>
</section>
