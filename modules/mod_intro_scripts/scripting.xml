<section><title>about shell scripting</title>
	<para>Shells like <command>bash</command> and <command>Korn</command> have support for programming constructs that can be saved as <command>scripts</command>. These <command>scripts</command> in turn then become more <command>shell</command> commands. Many Linux commands are <command>scripts</command>. <command>User profile scripts</command> are run when a user logs and <command>init scripts</command> are run when a <command>daemon</command> is stopped or started.</para>
	<para>This means that system administrators also need basic knowledge of <command>scripting</command> to understand how their servers and their applications are started, updated, upgraded, patched, maintained, configured and removed, and also to understand how a user environment is built.</para>
</section>
	<section><title>hello world</title>
		<para>Just like in every programming course, we start with a simple <command>hello_world</command> script. The following script will output <command>Hello World</command>.</para>
		<screen>
echo Hello World
		</screen>
		<para>After creating this simple script in <command>vi</command>, you'll have to <command>chmod +x hello_world</command><indexterm><primary>chmod +x</primary></indexterm> to make it executable. And unless you add the scripts directory to your path, you'll have to type the path to the script for the shell to be able to find it.</para>
		<screen>
[paul@RHEL4a ~]$ chmod +x hello_world 
[paul@RHEL4a ~]$ ./hello_world 
Hello World
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>she-bang</title>
		<para>Let's expand our example a little further by putting <command>#!/bin/bash</command> on the first line of the script. The <command>#!</command> is called a <command>she-bang</command>, where the <command>she-bang</command> is the first two characters of the script.</para>
		<screen>
#!/bin/bash
echo Hello World
		</screen>
	</section>
	<section><title>comment</title>
		<para>Let's expand our example a little further.</para>
		<screen>
#!/bin/bash
# Hello World Script
echo Hello World
		</screen>
	</section>
	<section><title>variables</title>
		<screen>
#!/bin/bash
var1=4
echo var1 = $var1
		</screen>
		<para>Scripts can contain variables, but since scripts are run in their own shell, the variables do not survive the end of the script.</para>
		<screen>
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$ ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$
		</screen>
		<para>Luckily, you can force a script to run in the same shell; this is called <command>sourcing</command> a script.</para>
		<screen>
[paul@RHEL4a ~]$ source ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
		<para>The above is identical to the below.</para>
		<screen>
[paul@RHEL4a ~]$ . ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>shell</title>
		<para>You can never be sure which shell a user is running. A script that works flawlessly in <command>bash</command> might not work in <command>ksh</command>, <command>csh</command>, or <command>dash</command>. To instruct a shell to run your script in a certain shell, you can start your script with a <command>she-bang</command><indexterm><primary>#!/bin/bash</primary></indexterm> followed by the shell it is supposed to run in. This script will run in a bash shell.</para>
		<screen>
#!/bin/bash
echo -n hello
echo A bash subshell `echo -n hello`
		</screen>
		<para>This script will run in a Korn shell (unless /bin/ksh is a link to /bin/bash). The <command>/etc/shells</command><indexterm><primary>/etc/shells</primary></indexterm> file contains a list of shells on your system.</para>
		<screen>
#!/bin/ksh
echo -n hello
echo a Korn subshell `echo -n hello`
		</screen>
		<para>Some user may try to perform <command>setuid</command> based script root spoofing. This is a rare but possible attack. To improve script security and to avoid interpreter spoofing, you need to add <command>--</command> after the <command>#!/bin/bash</command>, which disables further option processing so <command>bash</command> will not accept any options. 
		<screen>
#!/bin/bash -
		</screen>
		or
		<screen>
#!/bin/bash --
		</screen>
		Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --. 
		</para>
	</section>
	<section><title>for loop</title>
		<para>The example below shows the syntax of a classical <command>for loop</command><indexterm><primary>for loop (bash)</primary></indexterm> in bash.</para>
		<screen>for i in 1 2 4
do
   echo $i
done</screen>
		<para>An example of a <command>for loop</command> combined with an embedded shell.</para>
		<screen>
#!/bin/ksh
for counter in `seq 1 20`
do
   echo counting from 0 to 20, now at $counter
   sleep 1
done
		</screen>
		<para>This <command>for loop</command> use file globbing (from the shell expansion). Putting the instruction on the command line has identical functionality.</para>
		<screen>kahlan@solexp11$ ls
count.ksh  go.ksh
kahlan@solexp11$ for file in *.ksh ; do cp $file $file.backup ; done
kahlan@solexp11$ ls                                                 
count.ksh  count.ksh.backup  go.ksh  go.ksh.backup </screen>
	</section>
	<section><title>while loop</title>
		<para>Below a simple example of a <command>while loop</command><indexterm><primary>while loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
while [ $i -ge 0 ] ;
do
   echo Counting down, from 100 to 0, now at $i;
   let i--;
done
		</screen>
		<para>Endless loops can be made with <command>while true</command> or <command>while :</command> , where the <command>colon</command> is the equivalent of <command>no operation</command> in the <command>Korn</command> and <command>bash</command> shells.</para>
		<screen>#!/bin/ksh
# endless loop
while :
do
 echo hello
 sleep 1
done</screen>
	</section>
	<section><title>until loop</title>
		<para>Below a simple example of an <command>until loop</command><indexterm><primary>until loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
until [ $i -le 0 ] ;
do
   echo Counting down, from 100 to 1, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>parameters</title>
		<para>A <command>bash</command> shell script can have parameters. The numbering you see in the script below continues if you have more parameters. You also have special parameters containing the number of parameters, a string of all of them, and also the process id, and the last error code. The man page of <command>bash</command> has a full list.</para>
		<screen>
#!/bin/bash
echo The first argument is $1
echo The second argument is $2
echo The third argument is $3

echo \$ $$  PID of the script
echo \# $#  count arguments
echo \? $?  last error code
echo \* $*  all the arguments
		</screen>
		<para>Below is the output of the script above in action.</para>
		<screen>
[paul@RHEL4a scripts]$ ./pars one two three
The first argument is one
The second argument is two
The third argument is three
$ 5610 PID of the script
# 3 count arguments
? 0 last error code
* one two three all the arguments
[paul@RHEL4a scripts]$ ./pars 1 2
The first argument is 1
The second argument is 2
The third argument is
$ 5612 PID of the script
# 2 count arguments
? 0 last error code
* 1 2 all the arguments
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>shift</title>
		<para>The <command>shift</command> statement can parse all <command>parameters</command> one by one. This is a sample script.</para>
		<screen>kahlan@solexp11$ cat shift.ksh 
#!/bin/ksh                                
                                          
if [ "$#" == "0" ] 
 then
  echo You have to give at least one parameter.
  exit 1
fi

while (( "$# ))
 do
  echo You gave me $1
  shift
 done</screen>
		<para>Below is some sample output of the script above.</para>
		<screen>kahlan@solexp11$ ./shift.ksh one  
You gave me one
kahlan@solexp11$ ./shift.ksh one two three 1201 "33 42"
You gave me one                           
You gave me two
You gave me three
You gave me 1201
You gave me 33 42
kahlan@solexp11$ ./shift.ksh                           
You have to give at least one parameter.</screen>
	</section>
	<section><title>test [ ]</title>
		<para>The <command>test</command><indexterm><primary>test</primary></indexterm> command can test whether something is true or false. Let's start by testing whether 10 is greater than 55.</para>
		<screen>
[paul@RHEL4b ~]$ test 10 -gt 55 ; echo $?
1
[paul@RHEL4b ~]$ 
		</screen>
		<para>The test command returns 1 if the test fails. And as you see in the next screenshot, test returns 0 when a test succeeds.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 ; echo $?
0
[paul@RHEL4b ~]$
		</screen>
		<para>If you prefer true and false, then write the test like this.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ test 6 -gt 55 &#038;&#038; echo true || echo false
false
		</screen>
		<para>The test command can also be written as square brackets, the screenshot below is identical to the one above.</para>
		<screen>
[paul@RHEL4b ~]$ [ 56 -gt 55 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 6 -gt 55 ] &#038;&#038; echo true || echo false
false
		</screen>
		<para>Below are some example tests. Take a look at <command>man test</command> to see more options for tests.</para>
		<screen>
[ -d foo ]             Does the directory foo exist ?
[ '/etc' = $PWD ]      Is the string /etc equal to the variable $PWD ?
[ $1 != 'secret' ]     Is the first parameter different from secret ?
[ 55 -lt $bar ]        Is 55 less than the value of $bar ?
[ $foo -ge 1000 ]      Is the value of $foo greater or equal to 1000 ?
[ "abc" &#060; $bar ]  Does abc sort before the value of $bar ?
[ -f foo ]             Is foo a regular file ?
[ -r bar ]             Is bar a readable file ?
[ foo -nt bar ]        Is file foo newer than file bar ?
[ -o nounset ]         Is the shell option nounset set ?
		</screen>
		<para>Tests can be combined with logical AND and OR.</para>
		<screen>
paul@RHEL4b:~$ [ 66 -gt 55 -a 66 -lt 500 ] &#038;&#038; echo true || echo false
true
paul@RHEL4b:~$ [ 66 -gt 55 -a 660 -lt 500 ] &#038;&#038; echo true || echo false
false
paul@RHEL4b:~$ [ 66 -gt 55 -o 660 -lt 500 ] &#038;&#038; echo true || echo false
true
		</screen>
	</section>
	<section><title>eval</title>
		<para><command>eval</command> reads arguments as input to the shell (the resulting commands are executed). This allows using the value of a variable as a variable.</para>
		<screen>paul@deb503:~/test42$ answer=42
paul@deb503:~/test42$ word=answer
paul@deb503:~/test42$ eval x=\$$word ; echo $x
42</screen>
		<para>Both in <command>bash</command> and <command>Korn</command> the arguments can be quoted.</para>
		<screen>kahlan@solexp11$ answer=42                
kahlan@solexp11$ word=answer              
kahlan@solexp11$ eval "y=\$$word" ; echo $y
42</screen>
	</section>
	<section><title>(( ))</title>
		<para>The <command>(( ))</command> allows for evaluation of numerical expressions.</para>
		<para></para>
		<screen>paul@deb503:~/test42$ (( 42 > 33 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ (( 42 > 1201 )) &#038;&#038; echo true || echo false
false
paul@deb503:~/test42$ var42=42
paul@deb503:~/test42$ (( 42 == var42 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ (( 42 == $var42 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ var42=33
paul@deb503:~/test42$ (( 42 == var42 )) &#038;&#038; echo true || echo false
false</screen>
	</section>
	<section><title>if if, then then, or else</title>
		<para>The <command>if then else</command><indexterm><primary>if then else (bash)</primary></indexterm> construction is about choice. If a certain condition is met, then execute something, else execute something else. The example below tests whether a file exists, and if the file exists then a proper message is echoed.</para>
		<screen>
#!/bin/bash

if [ -f isit.txt ]
then echo isit.txt exists!
else echo isit.txt not found!
fi
		</screen>
		<para>If we name the above script 'choice', then it executes like this.</para>
		<screen>
[paul@RHEL4a scripts]$ ./choice 
isit.txt not found!
[paul@RHEL4a scripts]$ touch isit.txt
[paul@RHEL4a scripts]$ ./choice 
isit.txt exists!
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>let</title>
		<para>The <command>let</command><indexterm><primary>let</primary></indexterm> built-in shell function instructs the shell to perform an evaluation of arithmetic expressions. It will return 0 unless the last arithmetic expression evaluates to 0.</para>
		<screen>
[paul@RHEL4b ~]$ let x="3 + 4" ; echo $x
7
[paul@RHEL4b ~]$ let x="10 + 100/10" ; echo $x
20
[paul@RHEL4b ~]$ let x="10-2+100/10" ; echo $x
18
[paul@RHEL4b ~]$ let x="10*2+100/10" ; echo $x
30
		</screen>
		<para>The <command>shell</command> can also convert between different bases.</para>
		<screen>
[paul@RHEL4b ~]$ let x="0xFF" ; echo $x
255
[paul@RHEL4b ~]$ let x="0xC0" ; echo $x
192
[paul@RHEL4b ~]$ let x="0xA8" ; echo $x
168
[paul@RHEL4b ~]$ let x="8#70" ; echo $x
56
[paul@RHEL4b ~]$ let x="8#77" ; echo $x
63
[paul@RHEL4b ~]$ let x="16#c0" ; echo $x
192
		</screen>
		<para>There is a difference between assigning a variable directly, or using <command>let</command> to evaluate the arithmetic expressions (even if it is just assigning a value).</para>
		<screen>kahlan@solexp11$ dec=15 ; oct=017 ; hex=0x0f            
kahlan@solexp11$ echo $dec $oct $hex                                                                                                                  
15 017 0x0f                                                                         
kahlan@solexp11$ let dec=15 ; let oct=017 ; let hex=0x0f
kahlan@solexp11$ echo $dec $oct $hex                                                                                                                                                                        
15 15 15</screen>
	</section>
	<section><title>runtime input</title>
		<para>You can ask the user for input with the <command>read</command><indexterm><primary>read</primary></indexterm> command in a script.</para>
		<screen>
#!/bin/bash
echo -n Enter a number:
read number
		</screen>
	</section>
	<section><title>sourcing a config file</title>
		<screen>
[paul@RHEL4a scripts]$ cat myApp.conf 
# The config file of myApp

# Enter the path here
myAppPath=/var/myApp

# Enter the number of quines here
quines=5

[paul@RHEL4a scripts]$ cat myApp.bash 
#!/bin/bash
#
# Welcome to the myApp application
# 

. ./myApp.conf

echo There are $quines quines

[paul@RHEL4a scripts]$ ./myApp.bash 
There are 5 quines
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>case</title>
		<para>You can sometimes simplify nested if statements with a case construct.</para>
		<screen>
[paul@RHEL4b ~]$ ./help
What animal did you see ? lion
You better start running fast!
[paul@RHEL4b ~]$ ./help
What animal did you see ? dog
Don't worry, give it a cookie.
[paul@RHEL4b ~]$ cat help
#!/bin/bash
#
# Wild Animals Helpdesk Advice
#
echo -n "What animal did you see ? "
read animal
case $animal in
        "lion" | "tiger")
                echo "You better start running fast!"
        ;;
        "cat")
                echo "Let that mouse go..."
        ;;
        "dog")
                echo "Don't worry, give it a cookie."
        ;;
        "chicken" | "goose" | "duck" )
                echo "Eggs for breakfast!"
        ;;
        "liger")
                echo "Approach and say 'Ah you big fluffy kitty...'."
        ;;
        "babelfish")
                echo "Did it fall out your ear ?"
        ;;
        *)
                echo "You discovered an unknown animal, name it!"
        ;;
esac
[paul@RHEL4b ~]$ 			
		</screen>
	</section>
	<section><title>getopts</title>
		<para>The <command>getopts</command> function allows you to parse options given to a command.</para>
		<screen>kahlan@solexp11$ cat options.ksh 
#!/bin/ksh

while getopts ":afz" option;
do
 case $option in
  a)
   echo received -a
   ;;
  f)
   echo received -f
   ;;
  z)
   echo received -z
   ;;
  *)
   echo "invalid option -$OPTARG" 
   ;;
 esac
done</screen>
		<para>This is sample output from the script above.</para>
		<screen>kahlan@solexp11$ ./options.ksh        
kahlan@solexp11$ ./options.ksh -af
received -a
received -f
kahlan@solexp11$ ./options.ksh -zfg
received -z
received -f
invalid option -g
kahlan@solexp11$ ./options.ksh -a -b -z
received -a
invalid option -b
received -z</screen>
		<para>You can also check for options that need an argument, as this example shows.</para>
		<screen>kahlan@solexp11$ cat argoptions.ksh 
#!/bin/ksh

while getopts ":af:z" option;
do
 case $option in
  a)
   echo received -a
   ;;
  f)
   echo received -f with $OPTARG
   ;;
  z)
   echo received -z
   ;;
  :)
   echo "option -$OPTARG needs an argument"
   ;;
  *)
   echo "invalid option -$OPTARG" 
   ;;
 esac
done</screen>
		<para>This is sample output from the script above.</para>
		<screen>kahlan@solexp11$ ./argoptions.ksh -a -f hello -z
received -a
received -f with hello
received -z
kahlan@solexp11$ ./argoptions.ksh -zaf 42       
received -z
received -a
received -f with 42
kahlan@solexp11$ ./argoptions.ksh -zf   
received -z
option -f needs an argument</screen>
	</section>
	<section><title>shopt</title>
		<para>You can toggle the values of variables controlling optional shell behavior with the <command>shopt</command><indexterm><primary>shopt</primary></indexterm> built-in shell command. The example below first verifies whether the cdspell option is set; it is not. The next shopt command sets the value, and the third shopt command verifies that the option really is set. You can now use minor spelling mistakes in the cd command. The man page of bash has a complete list of options.</para>
		<screen>
paul@laika:~$ shopt -q cdspell ; echo $?
1
paul@laika:~$ shopt -s cdspell
paul@laika:~$ shopt -q cdspell ; echo $?
0
paul@laika:~$ cd /Etc
/etc</screen>
	</section>
	<section><title>shell functions</title>
		<para>Shell <command>functions</command> can be used to group commands in a logical way.</para>
		<screen>kahlan@solexp11$ cat funcs.ksh 
#!/bin/ksh
                                          
function greetings {
echo Hello World!
echo and hello to $USER to!
}

echo We will now call a function
greetings
echo The end</screen>
		<para>This is sample output from this script with a <command>function</command>.</para>
		<screen>kahlan@solexp11$ ./funcs.ksh              
We will now call a function
Hello World!
and hello to kahlan to!
The end</screen>
		<para>A shell function can also receive parameters.</para>
		<screen>kahlan@solexp11$ cat addfunc.ksh 
#!/bin/ksh

function plus {
let result="$1 + $2"
echo  $1 + $2 = $result
}

plus 3 10
plus 20 13
plus 20 22</screen>
		<para>This script produces the following output.</para>
		<screen>kahlan@solexp11$ ./addfunc.ksh 
3 + 10 = 13
20 + 13 = 33
20 + 22 = 42</screen>
	</section>
