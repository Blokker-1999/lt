	<section><title>Hello World</title>
		<para>Just like in every programming course, we start with a simple Hello World script. The following script will output Hello World.</para>
		<screen>
#!/bin/bash
# Hello World Script
echo Hello World
		</screen>
		<para>After creating this simple script in vi, you'll have to <command>chmod +x</command><indexterm><primary>chmod +x</primary></indexterm> the script to make it executable. And unless you add the scripts directory to your path, you'll have to type the path to the script for the shell to be able to find it.</para>
		<screen>
[paul@RHEL4a ~]$ chmod +x hello_world 
[paul@RHEL4a ~]$ ./hello_world 
Hello World
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>Variables</title>
		<screen>
#!/bin/bash
var1=4
echo var1 = $var1
		</screen>
		<para>Scripts can contain variables, but since scripts are run in their own shell, the variables do not survive the end of the script.</para>
		<screen>
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$ ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$
		</screen>
		<para>Luckily you can force a script to run in the same shell, this is called sourcing a script.</para>
		<screen>
[paul@RHEL4a ~]$ source ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
		<para>The above is identical to the below.</para>
		<screen>
[paul@RHEL4a ~]$ . ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>Shell</title>
		<para>You can never be sure which shell a user is running. A script that works flawlessly in bash, might not work in ksh or csh or dash. To instruct a shell to run your script in a certain shell, you can start your script with a shebang <command>#!</command><indexterm><primary>#!/bin/bash</primary></indexterm> followed by the shell it is supposed to run in. This script will run in a bash shell.</para>
		<screen>
#!/bin/bash
echo -n hello
echo A bash subshell `echo -n hello`
		</screen>
		<para>This script will run in a Korn shell (unless /bin/ksh is a link to /bin/bash). The <command>/etc/shells</command><indexterm><primary>/etc/shells</primary></indexterm> file contains a list of shells on your system.</para>
		<screen>
#!/bin/ksh
echo -n hello
echo a Korn subshell `echo -n hello`
		</screen>
	</section>
	<section><title>for loop</title>
		<para>The example below shows the syntax of a classical <command>for loop</command><indexterm><primary>for loop (bash)</primary></indexterm> in bash.</para>
		<screen>
for i in 1 2 4
do
   echo $i
done
		</screen>
		<para>An example of a for loop combined with an embedded shell to generate the list.</para>
		<screen>
for file in `ls *.txt`
do
   cp $file $file.bak
   echo Backup of $file put in $file.bak
done
		</screen>
	</section>
	<section><title>while loop</title>
		<para>Below a simple example of a <command>while loop</command><indexterm><primary>while loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
while [ $i -ge 0 ] ;
do
   echo Counting down, from 100 to 0, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>until loop</title>
		<para>Below a simple example of an <command>until loop</command><indexterm><primary>until loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
until [ $i -le 0 ] ;
do
   echo Counting down, from 100 to 1, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>parameters</title>
		<para>A bash shell script can have parameters. The numbering you see in the script below continues if you have more parameters. You also have special parameters for the number of parameters, a string of all of them, and also the process id and the last error code. The man page of bash has a full list.</para>
		<screen>
#!/bin/bash
echo The first argument is $1
echo The second argument is $2
echo The third argument is $3

echo \$ $$  PID of the script
echo \# $#  count arguments
echo \? $?  last error code
echo \* $*  all the arguments
		</screen>
		<para>Below is the output of the script above in action.</para>
		<screen>
[paul@RHEL4a scripts]$ ./pars one two three
The first argument is one
The second argument is two
The third argument is three
$ 5610 PID of the script
# 3 count arguments
? 0 last error code
* one two three all the arguments
[paul@RHEL4a scripts]$ ./pars a b c
The first argument is a
The second argument is b
The third argument is c
$ 5611 PID of the script
# 3 count arguments
? 0 last error code
* a b c all the arguments
[paul@RHEL4a scripts]$ ./pars 1 2
The first argument is 1
The second argument is 2
The third argument is
$ 5612 PID of the script
# 2 count arguments
? 0 last error code
* 1 2 all the arguments
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>test [ ]</title>
		<para>The <command>test</command><indexterm><primary>test</primary></indexterm> command can test whether something is true or false. Let's start by testing whether 10 is greater than 55.</para>
		<screen>
[paul@RHEL4b ~]$ test 10 -gt 55 ; echo $?
1
[paul@RHEL4b ~]$ 
		</screen>
		<para>The test command returns 1 if the test fails. And as you see in the next screenshot, test returns 0 when a test succeeds.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 ; echo $?
0
[paul@RHEL4b ~]$
		</screen>
		<para>If you prefer true and false, then write the test like this.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ test 6 -gt 55 &#038;&#038; echo true || echo false
false
		</screen>
		<para>The test command can also be written as square brackets, the screenshot below is identical to the one above.</para>
		<screen>
[paul@RHEL4b ~]$ [ 56 -gt 55 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 6 -gt 55 ] &#038;&#038; echo true || echo false
false
		</screen>
		<para>Below are some example tests. Take a look at <command>man test</command> to see more options for tests.</para>
		<screen>
[ -d foo ]             Does the directory foo exist ?
[ '/etc' = $PWD ]      Is the string /etc equal to the variable $PWD ?
[ $1 != 'secret' ]     Is the first parameter different from secret ?
[ 55 -lt $bar ]        Is 55 less than the value of $bar ?
[ $foo -ge 1000 ]      Is the value of $foo greater or equal to 1000 ?
[ "abc" &#060; $bar ]  Does abc sort before the value of $bar ?
[ -f foo ]             Is foo a regular file ?
[ -r bar ]             Is bar a readable file ?
[ foo -nt bar ]        Is file foo newer than file bar ?
[ -o nounset ]         Is the shell option nounset set ?
		</screen>
		<para>Tests can be combined with logical AND and OR.</para>
		<screen>
[paul@RHEL4b ~]$ [ 66 -gt 55 -a 66 -lt 500 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 66 -gt 55 -a 660 -lt 500 ] &#038;&#038; echo true || echo false
false
[paul@RHEL4b ~]$ [ 66 -gt 55 -o 660 -lt 500 ] &#038;&#038; echo true || echo false
true
		</screen>
	</section>
	<section><title>if if, then then, or else</title>
		<para>The <command>if then else</command><indexterm><primary>if then else (bash)</primary></indexterm> construction is about choice. If a certain condition is met, then execute something, else execute something else. The example below tests whether a file exists, if the file exists then a proper message is echoed.</para>
		<screen>
#!/bin/bash

if [ -f isit.txt ]
then echo isit.txt exists!
else echo isit.txt not found!
fi
		</screen>
		<para>If we name the above script 'choice', then it executes like this.</para>
		<screen>
[paul@RHEL4a scripts]$ ./choice 
isit.txt not found!
[paul@RHEL4a scripts]$ touch isit.txt
[paul@RHEL4a scripts]$ ./choice 
isit.txt exists!
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>let</title>
		<para>The <command>let</command><indexterm><primary>let</primary></indexterm> command allows for evalutation of arithmetic expressions.</para>
		<screen>
[paul@RHEL4b ~]$ let x="3 + 4" ; echo $x
7
[paul@RHEL4b ~]$ let x="10 + 100/10" ; echo $x
20
[paul@RHEL4b ~]$ let x="10-2+100/10" ; echo $x
18
[paul@RHEL4b ~]$ let x="10*2+100/10" ; echo $x
30
		</screen>
		<para>The let command can also convert between different bases.</para>
		<screen>
[paul@RHEL4b ~]$ let x="0xFF" ; echo $x
255
[paul@RHEL4b ~]$ let x="0xC0" ; echo $x
192
[paul@RHEL4b ~]$ let x="0xA8" ; echo $x
168
[paul@RHEL4b ~]$ let x="8#70" ; echo $x
56
[paul@RHEL4b ~]$ let x="8#77" ; echo $x
63
[paul@RHEL4b ~]$ let x="16#c0" ; echo $x
192
		</screen>
	</section>
	<section><title>runtime input</title>
		<para>You can ask the user for input with the <command>read</command><indexterm><primary>read</primary></indexterm> command in a script.</para>
		<screen>
#!/bin/bash
echo -n Enter a number:
read number
		</screen>
	</section>
	<section><title>sourcing a config file</title>
		<screen>
[paul@RHEL4a scripts]$ cat myApp.conf 
# The config file of myApp

# Enter the path here
myAppPath=/var/myApp

# Enter the number of quines here
quines=5

[paul@RHEL4a scripts]$ cat myApp.bash 
#!/bin/bash
#
# Welcome to the myApp application
# 

. ./myApp.conf

echo There are $quines quines

[paul@RHEL4a scripts]$ ./myApp.bash 
There are 5 quines
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>case</title>
		<para>You can sometimes simplify nested if statements with a case construct.</para>
		<screen>
[paul@RHEL4b ~]$ ./help
What animal did you see ? lion
You better start running fast!
[paul@RHEL4b ~]$ ./help
What animal did you see ? dog
Don't worry, give it a cookie.
[paul@RHEL4b ~]$ cat help
#!/bin/bash
#
# Wild Animals Helpdesk Advice
#
echo -n "What animal did you see ? "
read animal
case $animal in
        "lion" | "tiger")
                echo "You better start running fast!"
        ;;
        "cat")
                echo "Let that mouse go..."
        ;;
        "dog")
                echo "Don't worry, give it a cookie."
        ;;
        "chicken" | "goose" | "duck" )
                echo "Eggs for breakfast!"
        ;;
        "liger")
                echo "Approach and say 'Ah you big fluffy kitty...'."
        ;;
        "babelfish")
                echo "Did it fall out your ear ?"
        ;;
        *)
                echo "You discovered an unknown animal, name it!"
        ;;
esac
[paul@RHEL4b ~]$ 			
		</screen>
	</section>
	<section><title>shopt</title>
		<para>You can toggle the values of variables controlling optional shell behavior with the <command>shopt</command><indexterm><primary>shopt</primary></indexterm> built-in shell command. The example below first verifies whether the cdspell option is set, it is not. The next shopt command sets the value, and the third shopt command verifies that the option really is set. You can now use minor spelling mistakes in the cd command. The man page of bash has a complete list of options.</para>
		<screen>
paul@laika:~$ shopt -q cdspell ; echo $?
1
paul@laika:~$ shopt -s cdspell
paul@laika:~$ shopt -q cdspell ; echo $?
0
paul@laika:~$ cd /Etc
/etc
paul@laika:/etc$
		</screen>
	</section>
	<section><title>Practice : scripts</title>
		<para>0. Give each script a different name, keep them for later!</para>
		<para>1. Write a script that receives four parameters, and outputs them in reverse order.</para>
		<para>2. Write a script that receives two parameters (two filenames) and outputs whether those files exist.</para>
		<para>3. Write a script that counts the number of files ending in .txt in the current directory.</para>
		<para>4. Write a script that asks for two numbers, and outputs the sum and product (as shown here).</para>
		<screen>
Enter a number: 5
Enter another number: 2

Sum:       5 + 2 = 7
Product:   5 x 2 = 10
		</screen>
		<para>5. Improve the previous script to test that the numbers are between 1 and 100, exit with an error if necessary.</para>
		<para>6. Improve the previous script to congratulate the user if the sum equals the product.</para>
		<para>7. Improve the script from question 2. to complain if it does not receive exactly two parameters.</para>
		<para>8. Write a script that counts from 3 to 7 and then from 7 to 3, and all this three times, once with a for loop, once with a while loop and once with a until loop. Show the teacher that it works!</para>
		<para>9. Write a script that asks for a filename. Verify existance of the file, then verify that you own the file, and whether it is writable. If not, then make it writable.</para>
		<para>10. Make a configuration file for the previous script. Put a logging switch in the config file, logging means writing detailed output of everything the script does to a log file in /tmp.</para>
		<para>11. Make the case statement in "Wild Animals Helpdesk Advice" case insensitive. Use shopt (with the correct toggled option) for this, but reset the value back to it's original after the end of the case statement. (A solution is available in appendix 1, but try to find it yourself.)</para>
		<para>12. If time permits (or if you are waiting for other students to finish this practice), take a look at linux system scripts in /etc/init.d and /etc/rc.d and try to understand them. Where does execution of a script start in /etc/init.d/samba ? There are also some hidden scripts in ~, we will discuss them later.</para>
	</section>
	<section><title>Solutions</title>
		<para>11. A script with a case insensitive case statement, using the shopt nocasematch option. The nocasematch option is reset to the value it had before the scripts started.</para>
		<screen>
#!/bin/bash
#
# Wild Animals Case Insensitive Helpdesk Advice
#

if shopt -q nocasematch; then
  nocase=yes;
else
  nocase=no;
  shopt -s nocasematch;
fi

echo -n "What animal did you see ? "
read animal

case $animal in
		"lion" | "tiger")
				echo "You better start running fast!"
		;;
		"cat")
				echo "Let that mouse go..."
		;;
		"dog")
				echo "Don't worry, give it a cookie."
		;;
		"chicken" | "goose" | "duck" )
				echo "Eggs for breakfast!"
		;;
		"liger")
				echo "Approach and say 'Ah you big fluffy kitty.'"
		;;
		"babelfish")
				echo "Did it fall out your ear ?"
		;;
		*)
				echo "You discovered an unknown animal, name it!"
		;;
esac

if [ nocase = yes ] ; then
        shopt -s nocasematch;
else
        shopt -u nocasematch;
fi
		</screen>
	</section>
