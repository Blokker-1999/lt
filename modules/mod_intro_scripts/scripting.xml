<section><title>about shell scripting</title>
	<para>Shells like <command>bash</command> and <command>Korn</command> have support for programming constructs that can be saved as <command>scripts</command>. These <command>scripts</command> in turn then become more <command>shell</command> commands. Many Linux commands are <command>scripts</command>. <command>User profile scripts</command> are run when a user logs and <command>init scripts</command> are run when a <command>daemon</command> is stopped or started.</para>
	<para>This means that system administrators also need basic knowledge of <command>scripting</command> to understand how their servers and their applications are started, updated, upgraded, patched, maintained, configured and removed, and also to understand how a user environment is built.</para>
</section>
	<section><title>hello world</title>
		<para>Just like in every programming course, we start with a simple <command>hello_world</command> script. The following script will output <command>Hello World</command>.</para>
		<screen>
echo Hello World
		</screen>
		<para>After creating this simple script in <command>vi</command>, you'll have to <command>chmod +x hello_world</command><indexterm><primary>chmod +x</primary></indexterm> to make it executable. And unless you add the scripts directory to your path, you'll have to type the path to the script for the shell to be able to find it.</para>
		<screen>
[paul@RHEL4a ~]$ chmod +x hello_world 
[paul@RHEL4a ~]$ ./hello_world 
Hello World
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>she-bang</title>
		<para>Let's expand our example a little further by putting <command>#!/bin/bash</command> on the first line of the script. The <command>#!</command> is called a <command>she-bang</command>, where the <command>she-bang</command> is the first two characters of the script.</para>
		<screen>
#!/bin/bash
echo Hello World
		</screen>
	</section>
	<section><title>comment</title>
		<para>Let's expand our example a little further.</para>
		<screen>
#!/bin/bash
# Hello World Script
echo Hello World
		</screen>
	</section>
	<section><title>variables</title>
		<screen>
#!/bin/bash
var1=4
echo var1 = $var1
		</screen>
		<para>Scripts can contain variables, but since scripts are run in their own shell, the variables do not survive the end of the script.</para>
		<screen>
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$ ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$
		</screen>
		<para>Luckily, you can force a script to run in the same shell; this is called <command>sourcing</command> a script.</para>
		<screen>
[paul@RHEL4a ~]$ source ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
		<para>The above is identical to the below.</para>
		<screen>
[paul@RHEL4a ~]$ . ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>shell</title>
		<para>You can never be sure which shell a user is running. A script that works flawlessly in <command>bash</command> might not work in <command>ksh</command>, <command>csh</command>, or <command>dash</command>. To instruct a shell to run your script in a certain shell, you can start your script with a <command>she-bang</command><indexterm><primary>#!/bin/bash</primary></indexterm> followed by the shell it is supposed to run in. This script will run in a bash shell.</para>
		<screen>
#!/bin/bash
echo -n hello
echo A bash subshell `echo -n hello`
		</screen>
		<para>This script will run in a Korn shell (unless /bin/ksh is a link to /bin/bash). The <command>/etc/shells</command><indexterm><primary>/etc/shells</primary></indexterm> file contains a list of shells on your system.</para>
		<screen>
#!/bin/ksh
echo -n hello
echo a Korn subshell `echo -n hello`
		</screen>
		<para>Some user may try to perform <command>setuid</command> based script root spoofing. This is a rare but possible attack. To improve script security and to avoid interpreter spoofing, you need to add <command>--</command> after the <command>#!/bin/bash</command>, which disables further option processing so <command>bash</command> will not accept any options. 
		<screen>
#!/bin/bash -
		</screen>
		or
		<screen>
#!/bin/bash --
		</screen>
		Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --. 
		</para>
	</section>
	<section><title>for loop</title>
		<para>The example below shows the syntax of a classical <command>for loop</command><indexterm><primary>for loop (bash)</primary></indexterm> in bash.</para>
		<screen>for i in 1 2 4
do
   echo $i
done</screen>
		<para>An example of a <command>for loop</command> combined with an embedded shell.</para>
		<screen>
#!/bin/ksh
for counter in `seq 1 20`
do
   echo counting from 0 to 20, now at $counter
   sleep 1
done
		</screen>
		<para>This <command>for loop</command> use file globbing (from the shell expansion). Putting the instruction on the command line has identical functionality.</para>
		<screen>kahlan@solexp11$ ls
count.ksh  go.ksh
kahlan@solexp11$ for file in *.ksh ; do cp $file $file.backup ; done
kahlan@solexp11$ ls                                                 
count.ksh  count.ksh.backup  go.ksh  go.ksh.backup </screen>
	</section>
	<section><title>while loop</title>
		<para>Below a simple example of a <command>while loop</command><indexterm><primary>while loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
while [ $i -ge 0 ] ;
do
   echo Counting down, from 100 to 0, now at $i;
   let i--;
done
		</screen>
		<para>Endless loops can be made with <command>while true</command> or <command>while :</command> , where the <command>colon</command> is the equivalent of <command>no operation</command> in the <command>Korn</command> and <command>bash</command> shells.</para>
		<screen>#!/bin/ksh
# endless loop
while :
do
 echo hello
 sleep 1
done</screen>
	</section>
	<section><title>until loop</title>
		<para>Below a simple example of an <command>until loop</command><indexterm><primary>until loop (bash)</primary></indexterm>.</para>
		<screen>
let i=100;
until [ $i -le 0 ] ;
do
   echo Counting down, from 100 to 1, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>parameters</title>
		<para>A <command>bash</command> shell script can have parameters. The numbering you see in the script below continues if you have more parameters. You also have special parameters containing the number of parameters, a string of all of them, and also the process id, and the last error code. The man page of <command>bash</command> has a full list.</para>
		<screen>
#!/bin/bash
echo The first argument is $1
echo The second argument is $2
echo The third argument is $3

echo \$ $$  PID of the script
echo \# $#  count arguments
echo \? $?  last error code
echo \* $*  all the arguments
		</screen>
		<para>Below is the output of the script above in action.</para>
		<screen>
[paul@RHEL4a scripts]$ ./pars one two three
The first argument is one
The second argument is two
The third argument is three
$ 5610 PID of the script
# 3 count arguments
? 0 last error code
* one two three all the arguments
[paul@RHEL4a scripts]$ ./pars a b c
The first argument is a
The second argument is b
The third argument is c
$ 5611 PID of the script
# 3 count arguments
? 0 last error code
* a b c all the arguments
[paul@RHEL4a scripts]$ ./pars 1 2
The first argument is 1
The second argument is 2
The third argument is
$ 5612 PID of the script
# 2 count arguments
? 0 last error code
* 1 2 all the arguments
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>test [ ]</title>
		<para>The <command>test</command><indexterm><primary>test</primary></indexterm> command can test whether something is true or false. Let's start by testing whether 10 is greater than 55.</para>
		<screen>
[paul@RHEL4b ~]$ test 10 -gt 55 ; echo $?
1
[paul@RHEL4b ~]$ 
		</screen>
		<para>The test command returns 1 if the test fails. And as you see in the next screenshot, test returns 0 when a test succeeds.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 ; echo $?
0
[paul@RHEL4b ~]$
		</screen>
		<para>If you prefer true and false, then write the test like this.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ test 6 -gt 55 &#038;&#038; echo true || echo false
false
		</screen>
		<para>The test command can also be written as square brackets, the screenshot below is identical to the one above.</para>
		<screen>
[paul@RHEL4b ~]$ [ 56 -gt 55 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 6 -gt 55 ] &#038;&#038; echo true || echo false
false
		</screen>
		<para>Below are some example tests. Take a look at <command>man test</command> to see more options for tests.</para>
		<screen>
[ -d foo ]             Does the directory foo exist ?
[ '/etc' = $PWD ]      Is the string /etc equal to the variable $PWD ?
[ $1 != 'secret' ]     Is the first parameter different from secret ?
[ 55 -lt $bar ]        Is 55 less than the value of $bar ?
[ $foo -ge 1000 ]      Is the value of $foo greater or equal to 1000 ?
[ "abc" &#060; $bar ]  Does abc sort before the value of $bar ?
[ -f foo ]             Is foo a regular file ?
[ -r bar ]             Is bar a readable file ?
[ foo -nt bar ]        Is file foo newer than file bar ?
[ -o nounset ]         Is the shell option nounset set ?
		</screen>
		<para>Tests can be combined with logical AND and OR.</para>
		<screen>
paul@RHEL4b:~$ [ 66 -gt 55 -a 66 -lt 500 ] &#038;&#038; echo true || echo false
true
paul@RHEL4b:~$ [ 66 -gt 55 -a 660 -lt 500 ] &#038;&#038; echo true || echo false
false
paul@RHEL4b:~$ [ 66 -gt 55 -o 660 -lt 500 ] &#038;&#038; echo true || echo false
true
		</screen>
	</section>
	<section><title>eval</title>
		<para><command>eval</command> reads arguments as input to the shell (the resulting commands are executed). This allows using the value of a variable as a variable.</para>
		<screen>paul@deb503:~/test42$ answer=42
paul@deb503:~/test42$ word=answer
paul@deb503:~/test42$ eval x=\$$word ; echo $x
42</screen>
		<para>Both in <command>bash</command> and <command>Korn</command> the arguments can be quoted.</para>
		<screen>kahlan@solexp11$ answer=42                
kahlan@solexp11$ word=answer              
kahlan@solexp11$ eval "y=\$$word" ; echo $y
42</screen>
	</section>
	<section><title>(( ))</title>
		<para>The <command>(( ))</command> allows for evaluation of numerical expressions.</para>
		<para></para>
		<screen>paul@deb503:~/test42$ (( 42 > 33 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ (( 42 > 1201 )) &#038;&#038; echo true || echo false
false
paul@deb503:~/test42$ var42=42
paul@deb503:~/test42$ (( 42 == var42 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ (( 42 == $var42 )) &#038;&#038; echo true || echo false
true
paul@deb503:~/test42$ var42=33
paul@deb503:~/test42$ (( 42 == var42 )) &#038;&#038; echo true || echo false
false</screen>
	</section>
	<section><title>if if, then then, or else</title>
		<para>The <command>if then else</command><indexterm><primary>if then else (bash)</primary></indexterm> construction is about choice. If a certain condition is met, then execute something, else execute something else. The example below tests whether a file exists, and if the file exists then a proper message is echoed.</para>
		<screen>
#!/bin/bash

if [ -f isit.txt ]
then echo isit.txt exists!
else echo isit.txt not found!
fi
		</screen>
		<para>If we name the above script 'choice', then it executes like this.</para>
		<screen>
[paul@RHEL4a scripts]$ ./choice 
isit.txt not found!
[paul@RHEL4a scripts]$ touch isit.txt
[paul@RHEL4a scripts]$ ./choice 
isit.txt exists!
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>let</title>
		<para>The <command>let</command><indexterm><primary>let</primary></indexterm> built-in shell function instructs the shell to perform an evaluation of arithmetic expressions. It will return 0 unless the last arithmetic expression evaluates to 0.</para>
		<screen>
[paul@RHEL4b ~]$ let x="3 + 4" ; echo $x
7
[paul@RHEL4b ~]$ let x="10 + 100/10" ; echo $x
20
[paul@RHEL4b ~]$ let x="10-2+100/10" ; echo $x
18
[paul@RHEL4b ~]$ let x="10*2+100/10" ; echo $x
30
		</screen>
		<para>The <command>shell</command> can also convert between different bases.</para>
		<screen>
[paul@RHEL4b ~]$ let x="0xFF" ; echo $x
255
[paul@RHEL4b ~]$ let x="0xC0" ; echo $x
192
[paul@RHEL4b ~]$ let x="0xA8" ; echo $x
168
[paul@RHEL4b ~]$ let x="8#70" ; echo $x
56
[paul@RHEL4b ~]$ let x="8#77" ; echo $x
63
[paul@RHEL4b ~]$ let x="16#c0" ; echo $x
192
		</screen>
		<para>There is a difference between assigning a variable directly, or using <command>let</command> to evaluate the arithmetic expressions (even if it is just assigning a value).</para>
		<screen>kahlan@solexp11$ dec=15 ; oct=017 ; hex=0x0f            
kahlan@solexp11$ echo $dec $oct $hex                                                                                                                  
15 017 0x0f                                                                         
kahlan@solexp11$ let dec=15 ; let oct=017 ; let hex=0x0f
kahlan@solexp11$ echo $dec $oct $hex                                                                                                                                                                        
15 15 15</screen>
	</section>
	<section><title>runtime input</title>
		<para>You can ask the user for input with the <command>read</command><indexterm><primary>read</primary></indexterm> command in a script.</para>
		<screen>
#!/bin/bash
echo -n Enter a number:
read number
		</screen>
	</section>
	<section><title>sourcing a config file</title>
		<screen>
[paul@RHEL4a scripts]$ cat myApp.conf 
# The config file of myApp

# Enter the path here
myAppPath=/var/myApp

# Enter the number of quines here
quines=5

[paul@RHEL4a scripts]$ cat myApp.bash 
#!/bin/bash
#
# Welcome to the myApp application
# 

. ./myApp.conf

echo There are $quines quines

[paul@RHEL4a scripts]$ ./myApp.bash 
There are 5 quines
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>case</title>
		<para>You can sometimes simplify nested if statements with a case construct.</para>
		<screen>
[paul@RHEL4b ~]$ ./help
What animal did you see ? lion
You better start running fast!
[paul@RHEL4b ~]$ ./help
What animal did you see ? dog
Don't worry, give it a cookie.
[paul@RHEL4b ~]$ cat help
#!/bin/bash
#
# Wild Animals Helpdesk Advice
#
echo -n "What animal did you see ? "
read animal
case $animal in
        "lion" | "tiger")
                echo "You better start running fast!"
        ;;
        "cat")
                echo "Let that mouse go..."
        ;;
        "dog")
                echo "Don't worry, give it a cookie."
        ;;
        "chicken" | "goose" | "duck" )
                echo "Eggs for breakfast!"
        ;;
        "liger")
                echo "Approach and say 'Ah you big fluffy kitty...'."
        ;;
        "babelfish")
                echo "Did it fall out your ear ?"
        ;;
        *)
                echo "You discovered an unknown animal, name it!"
        ;;
esac
[paul@RHEL4b ~]$ 			
		</screen>
	</section>
	<section><title>getopts</title>
		<para>The <command>getopts</command> function allows you to parse options given to a command.</para>
		<screen>kahlan@solexp11$ cat options.ksh 
#!/bin/ksh

while getopts ":afz" option;
do
 case $option in
  a)
   echo received -a
   ;;
  f)
   echo received -f
   ;;
  z)
   echo received -z
   ;;
  *)
   echo "invalid option -$OPTARG" 
   ;;
 esac
done</screen>
		<para>This is sample output from the script above.</para>
		<screen>kahlan@solexp11$ ./options.ksh        
kahlan@solexp11$ ./options.ksh -af
received -a
received -f
kahlan@solexp11$ ./options.ksh -zfg
received -z
received -f
invalid option -g
kahlan@solexp11$ ./options.ksh -a -b -z
received -a
invalid option -b
received -z</screen>
		<para>You can also check for options that need an argument, as this example shows.</para>
		<screen>kahlan@solexp11$ cat argoptions.ksh 
#!/bin/ksh

while getopts ":af:z" option;
do
 case $option in
  a)
   echo received -a
   ;;
  f)
   echo received -f with $OPTARG
   ;;
  z)
   echo received -z
   ;;
  :)
   echo "option -$OPTARG needs an argument"
   ;;
  *)
   echo "invalid option -$OPTARG" 
   ;;
 esac
done</screen>
		<para>This is sample output from the script above.</para>
		<screen>kahlan@solexp11$ ./argoptions.ksh -a -f hello -z
received -a
received -f with hello
received -z
kahlan@solexp11$ ./argoptions.ksh -zaf 42       
received -z
received -a
received -f with 42
kahlan@solexp11$ ./argoptions.ksh -zf   
received -z
option -f needs an argument</screen>
	</section>
	<section><title>shopt</title>
		<para>You can toggle the values of variables controlling optional shell behavior with the <command>shopt</command><indexterm><primary>shopt</primary></indexterm> built-in shell command. The example below first verifies whether the cdspell option is set; it is not. The next shopt command sets the value, and the third shopt command verifies that the option really is set. You can now use minor spelling mistakes in the cd command. The man page of bash has a complete list of options.</para>
		<screen>
paul@laika:~$ shopt -q cdspell ; echo $?
1
paul@laika:~$ shopt -s cdspell
paul@laika:~$ shopt -q cdspell ; echo $?
0
paul@laika:~$ cd /Etc
/etc
paul@laika:/etc$
		</screen>
	</section>
	<section><title>Practice : scripts</title>
		<para>0. Give each script a different name, keep them for later!</para>
		<para>1. Write a script that receives four parameters, and outputs them in reverse order.</para>
		<para>2. Write a script that receives two parameters (two filenames) and outputs whether those files exist.</para>
		<para>3. Write a script that counts the number of files ending in .txt in the current directory.</para>
		<para>4. Write a script that asks for two numbers, and outputs the sum and product (as shown here).</para>
		<screen>
Enter a number: 5
Enter another number: 2

Sum:       5 + 2 = 7
Product:   5 x 2 = 10
		</screen>
		<para>5. Improve the previous script to test that the numbers are between 1 and 100, exit with an error if necessary.</para>
		<para>6. Improve the previous script to congratulate the user if the sum equals the product.</para>
		<para>7. Improve the script from question 2. to complain if it does not receive exactly two parameters.</para>
		<para>8. Write a script that counts from 3 to 7 and then from 7 to 3, and all this three times, once with a for loop, once with a while loop and once with a until loop. Show the teacher that it works!</para>
		<para>9. Write a script that asks for a filename. Verify existence of the file, then verify that you own the file, and whether it is writable. If not, then make it writable.</para>
		<para>10. Make a configuration file for the previous script. Put a logging switch in the config file, logging means writing detailed output of everything the script does to a log file in /tmp.</para>
		<para>11. Make the case statement in "Wild Animals Helpdesk Advice" case insensitive. Use shopt (with the correct toggled option) for this, but reset the value back to it's original after the end of the case statement. (A solution is available in appendix 1, but try to find it yourself.)</para>
		<para>12. If time permits (or if you are waiting for other students to finish this practice), take a look at linux system scripts in /etc/init.d and /etc/rc.d and try to understand them. Where does execution of a script start in /etc/init.d/samba ? There are also some hidden scripts in ~, we will discuss them later.</para>
	</section>
	<section><title>Solutions</title>
		<para>1. Write a script that receives four parameters, and outputs them in reverse order.</para>
		<screen>echo $4 $3 $2 $1</screen>
		<para>2. Write a script that receives two parameters (two filenames) and outputs whether those files exist.</para>
		<screen>
#!/bin/bash

if [ -f $1 ]
then echo $1 exists!
else echo $1 not found!
fi

if [ -f $2 ]
then echo $2 exists!
else echo $2 not found!
fi
		</screen>
		<para>3. Write a script that counts the number of files ending in .txt in the current directory.</para>
		<screen>
#!/bin/bash

ls *.txt > /dev/null 2>&#038;1
if [ $? -ne 0 ] 
then echo "There are 0 files ending in .txt"
else
	let i=0
	for file in *.txt
	do
		let i++
	done
	echo "There are $i files ending in .txt"
fi
</screen>
		<para>4. Write a script that asks for two numbers, and outputs the sum and product (as shown here).</para>
		<screen>
Enter a number: 5
Enter another number: 2

Sum:       5 + 2 = 7
Product:   5 x 2 = 10
		</screen>
		<screen>
#!/bin/bash

echo -n "Enter a number : "
read n1

echo -n "Enter another number : "
read n2

let sum="$n1+$n2"
let pro="$n1*$n2"

echo -e "Sum\t: $n1 + $n2 = $sum" 
echo -e "Product\t: $n1 * $n2 = $pro" 

		</screen>
		<para>5. Improve the previous script to test that the numbers are between 1 and 100, exit with an error if necessary.</para>
		<screen>
echo -n "Enter a number between 1 and 100 : "
read n1

if [ $n1 -lt 1 -o $n1 -gt 100 ]
then
       echo Wrong number... 
       exit 1
fi
		</screen>
		<para>6. Improve the previous script to congratulate the user if the sum equals the product.</para>
		<screen>
if [ $sum -eq $pro ] 
then echo Congratulations $sum == $pro
fi
		</screen>
		<para>7. Improve the script from question 2. to complain if it does not receive exactly two parameters.</para>
		<screen>
if [ $# -ne 2 ]
then
 echo Must get two parameters...
 exit 1
fi
		</screen>
		<para>8. Write a script that counts from 3 to 7 and then from 7 to 3, and all this three times, once with a for loop, once with a while loop and once with a until loop. Show the teacher that it works!</para>
		<screen></screen>
		<para>9. Write a script that asks for a filename. Verify existance of the file, then verify that you own the file, and whether it is writable. If not, then make it writable.</para>
		<screen></screen>
		<para>10. Make a configuration file for the previous script. Put a logging switch in the config file, logging means writing detailed output of everything the script does to a log file in /tmp.</para>
		<para>11. A script with a case insensitive case statement, using the shopt nocasematch option. The nocasematch option is reset to the value it had before the scripts started.</para>
		<screen>
#!/bin/bash
#
# Wild Animals Case Insensitive Helpdesk Advice
#

if shopt -q nocasematch; then
  nocase=yes;
else
  nocase=no;
  shopt -s nocasematch;
fi

echo -n "What animal did you see ? "
read animal

case $animal in
		"lion" | "tiger")
				echo "You better start running fast!"
		;;
		"cat")
				echo "Let that mouse go..."
		;;
		"dog")
				echo "Don't worry, give it a cookie."
		;;
		"chicken" | "goose" | "duck" )
				echo "Eggs for breakfast!"
		;;
		"liger")
				echo "Approach and say 'Ah you big fluffy kitty.'"
		;;
		"babelfish")
				echo "Did it fall out your ear ?"
		;;
		*)
				echo "You discovered an unknown animal, name it!"
		;;
esac

if [ nocase = yes ] ; then
        shopt -s nocasematch;
else
        shopt -u nocasematch;
fi
		</screen>
		<para>12. If time permits (or if you are waiting for other students to finish this practice), take a look at linux system scripts in /etc/init.d and /etc/rc.d and try to understand them. Where does execution of a script start in /etc/init.d/samba ? There are also some hidden scripts in ~, we will discuss them later.</para>
	<para>Always take time to properly <command>document</command> every script that you write!</para>
	<para></para>	
	<para>Image copied from <command>xkcd.com</command><indexterm><primary>http://xkcd.com</primary></indexterm>.</para>
	<mediaobject><imageobject><imagedata fileref="images/command_line_fu.jpg" format="EPS" align="center"></imagedata></imageobject></mediaobject>	
	<para></para>	
	</section>
