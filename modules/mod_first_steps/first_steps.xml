	<section><title>Working with directories</title>
		<para>It is one thing to know the structure of the Unix filetree, it is another to walk around in it. To explore the filesystem, you will need some tools. Here's a small overview of the most common commands, available on any Unix or Linux system. </para>
		<section><title>pwd</title>
			<para>The <command>you are here</command> sign can be displayed with the <command>pwd</command><indexterm><primary>pwd</primary></indexterm> command (Print Working Directory). Go ahead, try it: open a commandline interface (like gnome-terminal or an xterm) and type <command>pwd</command>. The tool displays your <command>current directory</command><indexterm><primary>current directory</primary></indexterm>.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
			</screen>
		</section>
		<section><title>cd</title>
			<para>You can change your current directory with the <command>cd</command><indexterm><primary>cd</primary></indexterm> command (Change Directory). </para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd /bin
paul@laika$ pwd
/bin
paul@laika$ cd /boot/grub
paul@laika$ pwd
/boot/grub
paul@laika$ cd /home/paul/
paul@laika$ pwd
/home/paul
			</screen>
			<para>You can pull off a trick with cd. Just typing <command>cd</command> without a target directory, will put you in your home directory. Typing <command>cd ~</command><indexterm><primary>cd ~</primary></indexterm> has the same effect.</para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd
paul@laika$ pwd
/home/paul
paul@laika$ cd ~
paul@laika$ pwd
/home/paul
			</screen>
			<para>To go to the <command>parent directory</command><indexterm><primary>parent directory</primary></indexterm> (the one just above your current directory in the directory tree), type <command>cd ..</command><indexterm><primary>cd ..</primary></indexterm> . <emphasis>To stay in the current directory, type <command>cd .</command> ;-)</emphasis></para>
			<screen>
paul@laika:/usr/share/games/wesnoth$ pwd
/usr/share/games/wesnoth
paul@laika:/usr/share/games/wesnoth$ cd ..
paul@laika:/usr/share/games$ pwd
/usr/share/games
paul@laika:/usr/share/games$ cd ..
paul@laika:/usr/share$ cd ..
paul@laika:/usr$ cd ..
paul@laika:/$ pwd
/
paul@laika:/$ 
			</screen>
			<para>Another useful shortcut with cd is to just type <command>cd -</command><indexterm><primary>cd -</primary></indexterm> to go to the previous directory.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
paul@laika:~$ cd /etc
paul@laika:/etc$ pwd
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ cd -
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ 			</screen>
			<para>You should be aware of <command>absolute and relative paths</command><indexterm><primary>absolute and relative paths</primary></indexterm> in the filetree. When you type a path starting with a slash, then the root of the filetree is assumed. If you don't start your path with a slash, then the current directory is the assumed starting point. The screenshot below first shows the current directory (/home/paul). From within this directory, you have to type <command>cd /home</command> instead of <command>cd home</command> to go to the /home directory. When inside /home, you have to type <command>cd paul</command> instead of <command>cd /paul</command> to enter the subdirectory paul of the current directory /home.</para>
			<screen>
paul@laika$ pwd
/home/paul
paul@laika$ cd home
bash: cd: home: No such file or directory
paul@laika$ cd /home
paul@laika$ pwd
/home
paul@laika$ cd /paul
bash: cd: /paul: No such file or directory
paul@laika$ cd paul
paul@laika$ pwd
/home/paul
paul@laika$ 
			</screen>
			<para>In case your current directory is the root directory, then both <command>cd /home</command> and <command>cd home</command> will get you in the /home directory.</para>
			<screen>
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd home
paul@laika$ pwd
/home
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd /home 
paul@laika$ pwd
/home
			</screen>
			<para>This was the last screenshot with pwd statements. From now on, the current directory will always be displayed in the prompt. We will explain later in this book, how the shell variable $PS1 can be configured to do this.</para>
		</section>

		<section><title>ls</title>
			<para>You can list the contents of a directory with <command>ls</command><indexterm><primary>ls</primary></indexterm>. Many times you will be using options with ls to display the contents of the directory in different formats, or to display different parts of the directory. Just typing ls gives you a list of files in the directory.Typing <command>ls -l</command><indexterm><primary>ls -l</primary></indexterm> (that is a letter L, not the number 1) gives you a long listing (more information on the contents).</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -l
total 23992
-rw-r--r-- 1 paul paul 24506857 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul    14744 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul     8189 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul     4096 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul        0 2006-03-30 22:45 summer.txt
			</screen>
			<para>A frequently used option with ls is <command>-a</command> to show all files. All files means including the <command>hidden files</command><indexterm><primary>hidden files</primary></indexterm>. When a filename on a Unix file system starts with a dot, it is considered a hidden file, and it doesn't show up in regular file listings.</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -a
.   allfiles.txt   .bash_profile  dmesg.txt   .lesshst  stuff       
..  .bash_history  .bashrc        httpd.conf  .ssh      summer.txt 
paul@pasha:~$ 
			</screen>
			<para>Another frequently used ls option is <command>-h</command>. It shows the numbers (file sizes) in a more human readable format. Also shown below is some variation in the way you can give the options to ls. We will explain the details of the output later in this book!</para>
			<screen>
paul@pasha:~$ ls -l -h
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -lh
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -hl
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -h -l
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
			</screen>
		</section>
		<section><title>mkdir</title>
			<para>Walking around the Unix filetree is fun, but it is even more fun to create your own directories with <command>mkdir</command><indexterm><primary>mkdir</primary></indexterm>. You have to give at least one parameter to <command>mkdir</command>, the name of the new directory to be created. Think before you type a leading / . </para>
			<screen>
paul@laika:~$ mkdir MyDir
paul@laika:~$ cd MyDir
paul@laika:~/MyDir$ ls -al
total 8
drwxr-xr-x  2 paul paul 4096 2007-01-10 21:13 .
drwxr-xr-x 39 paul paul 4096 2007-01-10 21:13 ..
paul@laika:~/MyDir$ mkdir stuff
paul@laika:~/MyDir$ mkdir otherstuff
paul@laika:~/MyDir$ ls -l
total 8
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 otherstuff
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 stuff
paul@laika:~/MyDir$ 
			</screen>
			<para>When given the option <command>-p</command><indexterm><primary>mkdir -p</primary></indexterm>, then mkdir will create parent directories as needed.</para>
			<screen>
paul@laika:~$ mkdir -p MyDir2/MySubdir2/ThreeDeep
paul@laika:~$ ls MyDir2
MySubdir2
paul@laika:~$ ls MyDir2/MySubdir2
ThreeDeep
paul@laika:~$ ls MyDir2/MySubdir2/ThreeDeep/
			</screen>
		</section>
		<section><title>rmdir</title>
			<para>When a directory is empty, you can use <command>rmdir</command><indexterm><primary>rmdir</primary></indexterm> to remove the directory.</para>
			<screen>
paul@laika:~/MyDir$ rmdir otherstuff
paul@laika:~/MyDir$ ls
stuff
paul@laika:~/MyDir$ cd ..
paul@laika:~$ rmdir MyDir
rmdir: MyDir/: Directory not empty
paul@laika:~$ rmdir MyDir/stuff
paul@laika:~$ rmdir MyDir
			</screen>
			<para>And similar to the mkdir -p option, you can also use rmdir to recursively remove directories.</para>
			<screen>
paul@laika:~$ mkdir -p dir/subdir/subdir2
paul@laika:~$ rmdir -p dir/subdir/subdir2
paul@laika:~$ 	
			</screen>
		</section>
		<section><title>pushd and popd</title>
			<para><emphasis>These two commands are not essential, if you think there are too many commands to remember, then you are allowed to forget about these two.</emphasis></para>
			<para>Some administrators find it useful to work with <command>pushd</command><indexterm><primary>pushd</primary></indexterm> and <command>popd</command><indexterm><primary>popd</primary></indexterm>. Both commands work with a common stack of previous directories. Pushd adds a directory to the stack and changes to a new current directory, popd removes a directory from the stack and sets the current directory.</para>
			<screen>
paul@laika:/etc$ cd /bin
paul@laika:/bin$ pushd /lib
/lib /bin
paul@laika:/lib$ pushd /proc
/proc /lib /bin
paul@laika:/proc$ 
paul@laika:/proc$ popd 
/lib /bin
paul@laika:/lib$ 
paul@laika:/lib$ 
paul@laika:/lib$ popd
/bin
paul@laika:/bin$ 
			</screen>
		</section>
		<section><title>Practice: Working with directories</title>
			<para>1. Display your current directory.</para>
			<para>2. Change to the /etc directory.</para>
			<para>3. Now change to your home directory using only three key presses.</para>
			<para>4. Change to the /boot/grub directory using only eleven key presses.</para>
			<para>5. Go to the parent directory of the current directory.</para>
			<para>6. Go to the root directory.</para>
			<para>7. List the contents of the root directory.</para>
			<para>8. List a long listing of the root directory.</para>
			<para>9. Stay where you are, and list the contents of /etc.</para>
			<para>10. Stay where you are, and list the contents of /bin and /sbin.</para>
			<para>11. Stay where you are, and list the contents of &#126;.</para>
			<para>12. List all the files (including hidden files) in your homedirectory.</para>
			<para>13. List the files in /boot in a human readable format.</para>
			<para>14. Create a directory testdir in your homedirectory.</para>
			<para>15. Change to the /etc directory, stay here and create a directory newdir in your homedirectory.</para>
			<para>16. Create in one command the directories ~/dir1/dir2/dir3 (dir3 is a subdirectory from dir2, and dir2 is a subdirectory from dir1 ).</para>
			<para>17. Remove the directory testdir.</para>
			<para>18. If time permits (or if you are waiting for other students to finish this practice), use and understand pushd and popd. Use the man page of bash to find information about pushd, popd and dirs.</para>
			<para></para>
			<para></para>	
		</section>
		<section><title>Solutions to the practice</title>
			<para>1. Display your current directory.</para>
			<para>pwd</para>	
			<para>2. Change to the /etc directory.</para>
			<para>cd /etc</para>	
			<para>3. Now change to your home directory using only three key presses.</para>
			<para>cd (and the enter key)</para>	
			<para>4. Change to the /boot/grub directory using only eleven key presses.</para>
			<para>cd /boot/grub (use the tab key)</para>	
			<para>5. Go to the parent directory of the current directory.</para>
			<para>cd .. (with space between cd and ..)</para>	
			<para>6. Go to the root directory.</para>
			<para>cd /</para>	
			<para>7. List the contents of the root directory.</para>
			<para>ls</para>	
			<para>8. List a long listing of the root directory.</para>
			<para>ls -l</para>	
			<para>9. Stay where you are, and list the contents of /etc.</para>
			<para>ls /etc</para>	
			<para>10. Stay where you are, and list the contents of /bin and /sbin.</para>
			<para>ls /bin /sbin</para>	
			<para>11. Stay where you are, and list the contents of &#126;.</para>
			<para>ls &#126;</para>	
			<para>12. List all the files (including hidden files) in your homedirectory.</para>
			<para>ls -al &#126;</para>	
			<para>13. List the files in /boot in a human readable format.</para>
			<para>ls -lh /boot</para>	
			<para>14. Create a directory testdir in your homedirectory.</para>
			<para>mkdir &#126;/testdir</para>	
			<para>15. Change to the /etc directory, stay here and create a directory newdir in your homedirectory.</para>
			<para>cd /etc ; mkdir &#126;/newdir</para>	
			<para>16. Create in one command the directories &#126;/dir1/dir2/dir3 (dir3 is a subdirectory from dir2, and dir2 is a subdirectory from dir1 ).</para>
			<para>mkdir -p &#126;/dir1/dir2/dir3</para>	
			<para>17. Remove the directory testdir.</para>
			<para>rm testdir</para>	
			<para>18. If time permits (or if you are waiting for other students to finish this practice), use and understand pushd and popd. Use the man page of bash to find information about pushd, popd and dirs.</para>
			<para></para>	
			<para></para>
			<para></para>	
		</section>
	</section>
	<section><title>Working with files</title>
		<section><title>file</title>
			<para>The <command>file</command><indexterm><primary>file(1)</primary></indexterm> utility determines the file type. Unlike some other desktop operating system, Unix does not use extensions to determine the file type. Your editor does not care whether a file ends in .TXT or .DOC. As a system administrator, you should use the <command>file</command> command to determine the file type. First some examples on a typical Linux system.</para>
			<screen>
paul@laika:~$ file Desktop/Screenshot.png 
Desktop/Screenshot.png: PNG image data, 3840 x 1200, 8-bit/color RGBA, \
non-interlaced
paul@laika:~$ file /bin/cat
/bin/cat: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for \
GNU/Linux2.6.0, dynamically linked (uses shared libs), for GNU/Linux 2.\
6.0, stripped
paul@laika:~$ file /etc/passwd
/etc/passwd: ASCII text
paul@laika:~$ file HelloWorld.c 
HelloWorld.c: ASCII C program text
			</screen>
			<para>Here's another example of the file utility. It shows the different type of binaries on different architectures.</para>
			<screen>
# Solaris 9 on Intel
bash-2.05$ file /bin/date
/bin/date:      ELF 32-bit LSB executable 80386 Version 1, dynamically \
linked, stripped

# Ubuntu Linux on AMD64
paul@laika:~$ file /bin/date 
/bin/date: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for\
 GNU/Linux 2.6.0, dynamically linked (uses shared libs), for GNU/Linux \
2.6.0, stripped

# Debian Sarge on SPARC
paul@pasha:~$ file /bin/date 
/bin/date: ELF 32-bit MSB executable, SPARC, version 1 (SYSV), for GNU/\
Linux 2.4.1, dynamically linked (uses shared libs), for GNU/Linux 2.4.1\
, stripped
			</screen>
		</section>
		<section><title>touch</title>
			<para>One easy way to create a file is with <command>touch</command><indexterm><primary>touch</primary></indexterm>. (We will see many other creative avenues for spawning files later in this book.)</para>
			<screen>
paul@laika:~/test$ touch file1
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
paul@laika:~/test$ touch file2
paul@laika:~/test$ touch file555
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file2
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file555
			</screen>
			<para>Of course, touch can do more than just create files. Can you find out what by looking at the next screenshot ? If not, check the manual of touch.</para>
			<screen>
paul@laika:~/test$ touch -t 200505050000 SinkoDeMayo
paul@laika:~/test$ touch -t 130207111630 BigBattle
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 1302-07-11 16:30 BigBattle
-rw-r--r-- 1 paul paul 0 2005-05-05 00:00 SinkoDeMayo
			</screen>
		</section>
		<section><title>rm</title>
			<para>When you no longer need a file, use <command>rm</command><indexterm><primary>rm</primary></indexterm> to remove it. Unlike some graphical user interfaces, the command line in general does not have a <emphasis>waste bin</emphasis> or <emphasis>trashcan</emphasis> to recover files. When you use rm to remove a file, the file is gone. So be careful before removing files! </para>
			<screen>
paul@laika:~/test$ ls
BigBattle  SinkoDeMayo
paul@laika:~/test$ rm BigBattle 
paul@laika:~/test$ ls
SinkoDeMayo
			</screen>
			<para>By default, rm will not remove non-empty directories. However rm accepts several options that will allow you to remove any directory. The <command>rm -rf</command><indexterm><primary>rm -rf</primary></indexterm> statement is famous because it will erase anything (providing that you have the permissions to do so). When you are logged on as root, be very careful with <command>rm -rf</command>, because being root implies that permissions don't apply to you, so you can literally erase your entire system by accident.</para>
			<screen>
paul@laika:~$ ls test
SinkoDeMayo
paul@laika:~$ rm test
rm: cannot remove `test': Is a directory
paul@laika:~$ rm -rf test
paul@laika:~$ ls test
ls: test: No such file or directory
			</screen>
		</section>
		<section><title>cp</title>
			<para>To copy a file, use <command>cp</command><indexterm><primary>cp</primary></indexterm> with a source and a target argument. If the target is a directory, then the sourcefiles are copied in that target directory.</para>
			<screen>
paul@laika:~/test$ touch FileA
paul@laika:~/test$ ls
FileA
paul@laika:~/test$ cp FileA FileB
paul@laika:~/test$ ls
FileA  FileB
paul@laika:~/test$ mkdir MyDir
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ cp FileA MyDir/
paul@laika:~/test$ ls MyDir/
FileA
			</screen>
			<para>To copy complete directories, use <command>cp -r</command><indexterm><primary>cp -r</primary></indexterm>.</para>
			<screen>
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ ls MyDir/
FileA
paul@laika:~/test$ cp -r MyDir MyDirB
paul@laika:~/test$ ls
FileA  FileB  MyDir  MyDirB
paul@laika:~/test$ ls MyDirB
FileA
			</screen>
			<para>You can also use cp to copy multiple file into a directory. In that case, the last argument (aka the target) must be a directory.</para>
			<screen>
paul@laika:~/test$ cp fire water
paul@laika:~/test$ cp -i fire water
cp: overwrite `water'? no
paul@laika:~/test$
			</screen>
			<screen>cp file1 file2 dir1/file3 dir1/file55 dir2</screen>
			<para>To prevent cp from overwriting existing files, use the -i (for interacgtive) option.</para>
		</section>
		<section><title>mv</title>
			<para>Use <command>mv</command><indexterm><primary>mv</primary></indexterm> to rename a file, or to move the file to another directory.</para>
			<screen>
paul@laika:~/test$ touch file100
paul@laika:~/test$ ls
file100
paul@laika:~/test$ mv file100 ABC.txt
paul@laika:~/test$ ls
ABC.txt
paul@laika:~/test$
			</screen>
			<para>The <command>rename</command><indexterm><primary>rename</primary></indexterm> command can also be used, but it has a more complex syntax to enable renaming of many files at once. Below two examples, the first switches all occurrences of txt in png for all filenames ending in .txt. The second example switches all occurrences of uppercase ABC in lowercase abc for all filenames ending in .png . The following syntax will work on debian and ubuntu.</para>
			<screen>
paul@laika:~/test$ ls
123.txt  ABC.txt
paul@laika:~/test$ rename 's/txt/png/' *.txt
paul@laika:~/test$ ls
123.png  ABC.png
paul@laika:~/test$ rename 's/ABC/abc/' *.png
paul@laika:~/test$ ls
123.png  abc.png
paul@laika:~/test$ 
			</screen>
			<para>On Red Hat Enterprise Linux, the syntax of rename is a bit different. The first example below renames all *.conf files, replace any occurrence of conf with bak. The second example renames all(*) files, replacing one with ONE.</para>
			<screen>
[paul@RHEL4a test]$ ls
one.conf  two.conf
[paul@RHEL4a test]$ rename conf bak *.conf
[paul@RHEL4a test]$ ls
one.bak  two.bak
[paul@RHEL4a test]$ rename one ONE *
[paul@RHEL4a test]$ ls
ONE.bak  two.bak
[paul@RHEL4a test]$ 
			</screen>
		</section>
		<section><title>Practice: Working with files</title>
			<para>1. List the files in the /bin directory</para>
			<para>2. Display the type of file of /bin/cat, /etc/passwd and /usr/bin/passwd.</para>
			<para>3a. Download wolf.jpg and book.pdf from http://linux-training.be (wget http://linux-training.be/studentfiles/wolf.jpg)</para>
			<para>3b. Display the type of file of wolf.jpg and book.pdf</para>
			<para>3c. Rename wolf.jpg to wolf.pdf (use mv).</para>
			<para>3d. Display the type of file of wolf.pdf and book.pdf.</para>
			<para>4. Create a directory &#126;/touched and enter it.</para>
			<para>5. Create the files today.txt and yesterday.txt in touched.</para>
			<para>6. Change the date on yesterday.txt to match yesterday's date.</para>
			<para>7. Copy yesterday.txt to copy.yesterday.txt</para>
			<para>8. Rename copy.yesterday.txt to kim</para>
			<para>9. Create a directory called &#126;/testbackup and copy all files from &#126;/touched in it.</para>
			<para>10. Use one command to remove the directory &#126;/testbackup and all files in it.</para>
			<para>11. Create a directory &#126;/etcbackup and copy all *.conf files from /etc in it. Did you include all subdirectories of /etc ?</para>
			<para>12. Use rename to rename all *.BAK files to *.BACKUP. (if you have a debian and red hat derived distro available, try it on both!)</para>
			<para></para>
			<para></para>
		</section>
		<section><title>Solutions to the practice</title>
			<para>1. List the files in the /bin directory</para>
			<para>ls /bin</para>
			<para>2. Display the type of file of /bin/cat, /etc/passwd and /usr/bin/passwd.</para>
			<para>file /bin/cat /etc/passwd /usr/bin/passwd</para>
			<para>3a. Download wolf.jpg and book.pdf from http://linux-training.be (wget http://linux-training.be/studentfiles/wolf.jpg)</para>
			<para>wget http://linux-training.be/studentfiles/wolf.jpg</para>
			<para>wget http://linux-training.be/studentfiles/book.pdf</para>
			<para>3b. Display the type of file of wolf.jpg and book.pdf</para>
			<para>file wolf.jpg wolf.pdf</para>
			<para>3c. Rename wolf.jpg to wolf.pdf (use mv).</para>
			<para>mv wolf.jpg wolf.pdf</para>
			<para>3d. Display the type of file of wolf.pdf and book.pdf.</para>
			<para>file wolf.pdf book.pdf</para>
			<para>4. Create a directory &#126;/touched and enter it.</para>
			<para>mkdir &#126;/touched ; cd &#126;/touched</para>
			<para>5. Create the files today.txt and yesterday.txt in touched.</para>
			<para>touch today.txt yesterday.txt</para>
			<para>6. Change the date on yesterday.txt to match yesterday's date.</para>
			<para>touch -t 200810251405 yesterday (substitute 20081025 with yesterdays date)</para>
			<para>7. Copy yesterday.txt to copy.yesterday.txt</para>
			<para>cp yesterday.txt copy.yesterday.txt</para>
			<para>8. Rename copy.yesterday.txt to kim</para>
			<para>mv copy.yesterday.txt kim</para>
			<para>9. Create a directory called &#126;/testbackup and copy all files from &#126;/touched in it.</para>
			<para>mkdir &#126;/testbackup ; cp -r &#126;/touched &#126;/testbackup/ </para>
			<para>10. Use one command to remove the directory &#126;/testbackup and all files in it.</para>
			<para>rm -rf &#126;/testbackup </para>
			<para>11. Create a directory &#126;/etcbackup and copy all *.conf files from /etc in it. Did you include all subdirectories of /etc ?</para>
			<para>cp -r /etc/*.conf &#126;/etcbackup</para>
			<para>12. Use rename to rename all *.BAK files to *.BACKUP. (if you have a debian and red hat derived distro available, try it on both!)</para>
			<para>On RHEL: touch 1.bak 2.bak ; rename BAK BACKUP *.bak</para>
			<para>On Debian: touch 1.bak 2.bak ; rename 's/BAK/BACKUP/' *.bak</para>
			<para></para>
			<para></para>
		</section>
	</section>
	<section><title>File contents</title>
		<section><title>head</title>
			<para>You can use <command>head</command><indexterm><primary>head(1)</primary></indexterm> to display the first ten lines of a file.</para>
			<screen>
paul@laika:~$ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
paul@laika:~$ 
			</screen>
			<para>The head command has some options for displaying the first n lines of a file.</para>
			<screen>
paul@laika:~$ head -4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
			</screen>
			<para>Head can also display the first n bytes.</para>
			<screen>
paul@laika:~$ head -c4 /etc/passwd
rootpaul@laika:~$
			</screen>		
		</section>
		<section><title>tail</title>
			<para>Similar to head, the <command>tail</command><indexterm><primary>tail(1)</primary></indexterm> command will display the last ten lines of a file.</para>
			<screen>
paul@laika:~$ tail /etc/services 
vboxd           20012/udp
binkp           24554/tcp             # binkp fidonet protocol
asp             27374/tcp             # Address Search Protocol
asp             27374/udp
csync2          30865/tcp             # cluster synchronization tool
dircproxy       57000/tcp             # Detachable IRC Proxy
tfido           60177/tcp             # fidonet EMSI over telnet
fido            60179/tcp             # fidonet EMSI over TCP

# Local services
paul@laika:~$
			</screen>
			<para>The tail command has many options, we will use some of them during this course.</para>
		</section>
		<section><title>cat</title>
			<para>The <command>cat</command><indexterm><primary>cat(1)</primary></indexterm> command is one of the most universal tools. All it does is copying standard input to standard output, but in combination with the shell, this can be very powerful and diverse. Some examples will give a glimpse of the possibilities. The first example is simple, you can use cat to display a file on the screen. If the file is longer than the screen, it will scroll by until the end.</para>
			<screen>
paul@laika:~$ cat /etc/resolv.conf
nameserver 194.7.1.4
paul@laika:~$
			</screen>
			<para>You can use cat to create files with one or more lines of text. Just type the command as is shown in the screenshot below. Then type one or more lines, finish each line with the enter key. After the last line, type and hold the Control (Ctrl) key and press d. The <command>Ctrl d</command><indexterm><primary>Ctrl D</primary></indexterm> key combination will send an EOF (End of File) to the running process, this will end the cat command.</para>
			<screen>
paul@laika:~/test$ cat > winter.txt
It is very cold today!
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$
			</screen>
			<para>You can actually choose this end marker for cat with <command>&#060;&#060;</command> as is shown in this screenshot.</para>
			<screen>
paul@laika:~/test$ cat &#062; hot.txt &#060;&#060;stop
&#062; It is hot today!
&#062; Yes it is summer.
&#062; stop
paul@laika:~/test$ cat hot.txt 
It is hot today!
Yes it is summer.
paul@laika:~/test$ 
			</screen>
			<para>In the third example you will see that cat can be used to copy files. We will explain in detail what happens here in the bash shell chapter.</para>
			<screen>
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$ cat winter.txt > cold.txt
paul@laika:~/test$ cat cold.txt 
It is very cold today!
paul@laika:~/test$
			</screen>		
		</section>
		<section><title>tac</title>
			<para>Just one example will show you the purpose of <command>tac</command><indexterm><primary>tac(1)</primary></indexterm> (as the opposite of cat).</para>
			<screen>
paul@laika:~/test$ cat count 
one
two
three
four
paul@laika:~/test$ tac count 
four
three
two
one
paul@laika:~/test$
			</screen>
		</section>
		<section><title>more and less</title>
			<para>The <command>more</command><indexterm><primary>more(1)</primary></indexterm> command is useful for displaying files that take up more than one screen. More will allow you to see the contents of the file page by page. You can use the spacebar to see the next page, or q to quit more. Some people prefere the <command>less</command><indexterm><primary>less(1)</primary></indexterm> command instead of more.</para>
		</section>
		<section><title>strings</title>
			<para>With the <command>strings</command><indexterm><primary>strings(1)</primary></indexterm> command you can display readable ascii strings found in (binary) files. This example locates the ls binary, and then displays readable strings in the binary file (output is truncated).</para>
			<screen>
paul@laika:~$ which ls
/bin/ls
paul@laika:~$ strings /bin/ls
/lib/ld-linux.so.2
librt.so.1
__gmon_start__
_Jv_RegisterClasses
clock_gettime
libacl.so.1
...
			</screen>
		</section>
		<section><title>split</title>
			<para>The <command>split</command><indexterm><primary>split(1)</primary></indexterm> command is useful to split files into smaller file. This can be useful to fit the file onto multiple instances of a medium too small to contain the complete file. In the example below, a file of size 5000 bytes is split into three smaller files, with maximum 2000 bytes each.</para>
			<screen>
paul@laika:~/test$ ls -l
total 8
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
paul@laika:~/test$ split -b 2000 bigfile1 splitfile.
paul@laika:~/test$ ls -l
total 20
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
			</screen>
			<para>In a similar example below the file is split into max 800 bytes parts.</para>
			<screen>
paul@laika:~/test$ split -b 800 bigfile1 size800.
paul@laika:~/test$ ls -l
total 48
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.aa
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ab
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ac
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ad
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ae
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.af
-rw-r--r-- 1 paul paul  200 2007-09-09 20:48 size800.ag
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
paul@laika:~/test$ 
			</screen>
		</section>
		<section><title>Practice: File contents</title>
			<para>1. Display the first 12 lines of /etc/X11/xorg.conf.</para>
			<para>2. Display the last line of /etc/passwd.</para>
			<para>3. Use cat to create a file named count.txt that looks like this:</para>
			<screen>
One
Two
Three
Four
Five
			</screen>
			<para>4. Use cp to make a backup of this file to cnt.txt.</para>
			<para>5. Use cat to make a backup of this file to catcnt.txt</para>
			<para>6. Display catcnt.txt, but with all lines in reverse order (the last line first).</para>
			<para>7. Use more to display /var/log/messages.</para>
			<para>8. Display the readable character strings from the passwd command.</para>
			<para>9. Use ls to find the biggest file in /etc. Make a testsplit directory in your home directory. Copy this biggest file to your ~/testsplit and name it biggest. Then split this file in smaller 200 bytes parts.</para>	
		</section>
		<section><title>Solutions to the practice</title>
			<para>1. Display the first 12 lines of /etc/X11/xorg.conf.</para>
			<para>head -12 /etc/X11/xorg.conf</para>
			<para>2. Display the last line of /etc/passwd.</para>
			<para>tail -1 /etc/passwd</para>
			<para>3. Use cat to create a file named count.txt that looks like this:</para>
			<screen>
One
Two
Three
Four
Five
			</screen>
			<para>cat > count.txt</para>
			<para>4. Use cp to make a backup of this file to cnt.txt.</para>
			<para>cp count.txt cnt.txt</para>
			<para>5. Use cat to make a backup of this file to catcnt.txt</para>
			<para>cat count.txt catcnt.txt</para>
			<para>6. Display catcnt.txt, but with all lines in reverse order (the last line first).</para>
			<para>tac catcnt.txt</para>
			<para>7. Use more to display /var/log/messages.</para>
			<para>more /var/log/messages</para>
			<para>8. Display the readable character strings from the passwd command.</para>
			<para>strings /usr/bin/passwd</para>
			<para>9. Use ls to find the biggest file in /etc. Make a testsplit directory in your home directory. Copy this biggest file to your ~/testsplit and name it biggest. Then split this file in smaller 200 bytes parts.</para>	
			<para>9. cd ; ls -lrS /etc</para>
			<para>mkdir testsplit</para>
			<para>cp /etc/bash_completion testsplit/biggest</para>
			<para>split -b 200 biggest parts</para>
			<para></para>
			<para></para>
		</section>
	</section>
