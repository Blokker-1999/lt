<chapter><title>Booting Linux</title>
<section><title>Booting the system</title>
	<para>Booting the system starts (once the hardware is powered on and configured) with a bootloader.</para>
        <para>There are a variety of boot loaders available, most common on intel architecture is <command>GRUB</command><indexterm><primary>grub</primary></indexterm>, which is replacing <command>Lilo</command><indexterm><primary>lilo</primary></indexterm> in many places. When installing Linux on SPARC architecture, you can choose <command>Silo</command><indexterm><primary>silo</primary></indexterm>, Itanium systems can use <command>ELILO</command><indexterm><primary>elilo</primary></indexterm>, IBM S/390 and zSeries use <command>z/IPL</command><indexterm><primary>z/IPL</primary></indexterm> and PowerPC architectures use <command>YABOOT</command><indexterm><primary>yaboot</primary></indexterm> (which means Yet Another boot loader).</para>
	<para> Once the Linux kernel is loaded, the bootloader turns control over to it. From that moment on, the kernel is in control of the system. After discussing bootloaders, we continue with the init system that starts all the daemons.</para>
</section>

<section><title>GRUB</title>
	<section><title>GRand Unified Bootloader</title>
	<para>The most common bootloader on linux systems today is <command>grub</command><indexterm><primary>grub</primary></indexterm>. On almost all intel based systems grub is replacing <command>lilo</command><indexterm><primary>lilo</primary></indexterm> (LInux LOader). Even Solaris switched to grub on x86 architecture.</para>
	<para>One of the big advantages of rub over lilo is the capability to change the configuration during boot (by pressing e to edit the boot commandline).</para>
	</section>
	<section><title>menu.lst</title>
	<para>Grub's configuration file is called <command>menu.lst</command><indexterm><primary>menu.lst</primary></indexterm> (old versions used <command>grub.conf</command><indexterm><primary>grub.conf</primary></indexterm>) and is located in /boot/grub. The screenshot below shows (part of) a typical grub configuration file.</para>
<screen>
paul@barry:~$ cat /boot/grub/menu.lst
default		0
timeout		5
color cyan/blue white/blue

title		Debian GNU/Linux, kernel 2.6.17-2-686
root		(hd0,0)
kernel		/boot/vmlinuz-2.6.17-2-686 root=/dev/hda1 ro 
initrd		/boot/initrd.img-2.6.17-2-686
savedefault
boot

title		Debian GNU/Linux, kernel 2.6.15-1-686 (recovery mode)
root		(hd0,0)
kernel		/boot/vmlinuz-2.6.15-1-686 root=/dev/hda1 ro single
initrd		/boot/initrd.img-2.6.15-1-686
savedefault
boot

title		Debian GNU/Linux, kernel 2.6.15-1-686
root		(hd0,0)
kernel		/boot/vmlinuz-2.6.15-1-686 root=/dev/hda1 ro 
initrd		/boot/initrd.img-2.6.15-1-686
savedefault
...
</screen>
	<para>In the screenshot, you see some parameters at the top like <command>default</command> and <command>timeout</command>, followed by three <command>stanzas</command>. Each stanza is shown as a seperate choice on the bootmenu, and can be booted by grub by selecting it and pressing enter. The stanzas are automatically numbered, starting with 0. So when the default switch marks 0, then the first stanza will be booted, unless another choice is manually selected at boot time. Setting the default switch to 1 will boot the second stanza.</para>
	<para>The <command>timeout</command> switch defines the amount of seconds a user has to make a choice in the bootmenu. In this example, the timeout is set to five seconds, so grub will wait five seconds before booting the first stanza.</para>
	<para>Another interesting switch is <command>fallback</command>. This parameter allows you to set a backup stanza in case the first one fails. </para>
	</section>
	<section><title>Stanza commands</title>
	<para>The <command>title</command> command serves as a description of the stanza that is visible in the bootmenu. It can be anything you like. In this example it describes the distro and kernel version.</para>
<screen>
title		Debian GNU/Linux, kernel 2.6.17-2-686
root		(hd0,0)
kernel		/boot/vmlinuz-2.6.17-2-686 root=/dev/hda1 ro 
initrd		/boot/initrd.img-2.6.17-2-686
</screen>
	<para>The <command>root</command> command will point to the hard disk to use. (hd0) is the first hard disk device, (hd1) is the second hard disk device. (hd0,0) is the first partition on the first disk, (hd0,1) is the second partition on that disk.</para>
	<para>The <command>kernel</command> command point to the kernel(file) that grub needs to load. And <command>initrd</command><indexterm><primary>initrd</primary></indexterm> points to an initial RAM disk to accompany the kernel at system boot before mounting / .</para>
	</section>
	<section><title>Chainloading</title>
	<para>Chainloading refers to grub loading another operating systems bootloader. The <command>chainloader</command><indexterm><primary>chainloader</primary></indexterm> switch receives one opetion: the number of sectors to read and boot. For DOS one sector is enough, so a grub entry for a DOS or OS/2 partition might look like this. Note that MS-DOS requires the boot/root partition to be active!</para>
<screen>
title MS-DOS 6.22
root  (hd0,1)
makeactive
chainloader +1
</screen>
	</section>
<section><title>Installing grub</title>
	<para>Run the <command>grub-install</command><indexterm><primary>grub-install</primary></indexterm> to install grub. The command requires a destination for overwriting the boot sector or mbr.</para>
<screen>
# grub-install /dev/hda
</screen>
	</section>
</section>



<section><title>Lilo</title>
	<section><title>Linux Loader</title>
		<para><command>Lilo</command><indexterm><primary>lilo</primary></indexterm> used to be the most used Linux bootloader, but is steadily being replaced in x86 with grub.</para>
	</section>
	<section><title>lilo.conf</title>
		<para>Here is an example of a typical <command>lilo.conf</command><indexterm><primary>lilo.conf</primary></indexterm> file. The <command>delay</command> switch receives a number in tenths of a second. So the delay below is three seconds, not thirty!</para>
		<screen>
boot = /dev/hda
delay = 30

image = /boot/vmlinuz
  root = /dev/hda1
  label = Red Hat 5.2

image = /boot/vmlinuz
  root = /dev/hda2
  label = S.U.S.E. 8.0

other = /dev/hda4
  table = /dev/hda
  label = MS-DOS 6.22
		</screen>
		<para>The configration file shows three example stanzas. The first one boots Red Hat from the first partition on the first disk (hda1). The second stanza boots Suse 8.0 from the next partition. The last one loads MS-DOS.</para>
	</section>
</section>



	<section><title>Booting</title>
		<para>The kernel receives system control from the bootloader. After a while the kernel starts the <command>init daemon</command><indexterm><primary>init</primary></indexterm>. The init daemon has <command>PID 1</command>. Many unix and linux systems use(d) init scripts to start daemons in the <command>System V release 4</command><indexterm><primary>System V</primary></indexterm> style (explained in detail below).</para>
		<para>But this synchronous (one after the other) method of starting daemons is slow, and although slow booting is not a problem on servers where uptime is measured in years, the recent uptake of linux on the desktop results in user complaints. To improve linux (and Solaris) startup speed, <command>Canonical</command><indexterm><primary>Canonical</primary></indexterm> has developed <command>upstart</command><indexterm><primary>upstart</primary></indexterm> (first used in Ubuntu) and <command>Sun</command><indexterm><primary>Sun</primary></indexterm> has developed <command>Service Management Facility</command><indexterm><primary>SMF</primary></indexterm> for Solaris 10. Both systems are asynchronous and can replace the SysV init scripts. There is also an ongoing effort to create <command>initng</command><indexterm><primary>initng</primary></indexterm> (init next generation).</para>
	</section>
	<section><title>Daemons</title>
		<para>A <command>daemon</command><indexterm><primary>daemon</primary></indexterm> is a process that runs in background, without a link to a GUI or terminal. Daemons are usually started at system boot, and stay alive until the system shuts down. In more recent technical writings, daemons are often refered to as <command>services</command>.</para>
		<para>Unix <command>daemons</command> are not to be confused with demons. Evi Nemeth, co-author of the UNIX System Administration Handbook has the following to say about daemons:</para>
		<para><emphasis>Many people equate the word "daemon" with the word "demon", implying some kind of satanic connection between UNIX and the underworld. This is an egregious misunderstanding. "Daemon" is actually a much older form of "demon"; daemons have no particular bias towards good or evil, but rather serve to help define a person's character or personality. The ancient Greeks' concept of a "personal daemon" was similar to the modern concept of a "guardian angel" ...</emphasis>.</para>
	</section>
	<section><title>Init</title>
		<section><title>/etc/inittab</title>
			<para>After the kernel, <command>/sbin/init</command><indexterm><primary>/sbin/init</primary></indexterm> is started with PID 1. Init will read its configuration file <command>/etc/inittab</command><indexterm><primary>/etc/inittab</primary></indexterm>. In that file, it will look for the value of initdefault (3 in the screenshot below).</para>
			<screen>
[paul@rhel4 ~]$ grep &#094;id /etc/inittab 
id:3:initdefault:
			</screen>
		</section>	
		<section><title>Runlevel</title>
			<para>This number indicates the default <command>runlevel</command><indexterm><primary>runlevel</primary></indexterm>. Some linuxes have a brief description of runlevels in /etc/inittab, like here on Red Hat Enterprise Linux 4.</para>
			<screen>
# Default runlevel. The runlevels used by RHS are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you don't have network)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
			</screen>
			<para>Runlevel 0 means the system is shutting down. Runlevel 1 is used for troubleshooting, only the root user can log on, and only at the console. Runlevel 3 is typical for servers, whereas runlevel 5 is typical for desktops (graphical logon). Besides runlevels 0, 1 and 6, the use may vary depending on the distribution. Some Debian and derived linux systems have full network and GUI logon on runlevels 2 to 5. So always verify the proper meaning of runlevels on your system.</para>
		</section>
		<section><title>sysinit</title>
			<para>Independent of the runlevel, init will run the <command>/etc/rc.d/rc.sysinit</command><indexterm><primary>/etc/rc.d/rc.sysinit</primary></indexterm> script (<command>/etc/init.d/rcS</command><indexterm><primary>/etc/init.d/rcS</primary></indexterm> on debian). This script does a lot of things : setting environment, populating /etc/mtab, mounting file systems, starting swap and more.</para>
			<screen>
[paul ~]$ egrep -e"^# Ini" -e"^# Sta" -e"^# Che" /etc/rc.d/rc.sysinit 
# Check SELinux status
# Initialize hardware
# Start the graphical boot, if necessary; /usr may not be mounted yet...
# Initialiaze ACPI bits
# Check filesystems
# Start the graphical boot, if necessary and not done yet.
# Check to see if SELinux requires a relabel
# Initialize pseudo-random number generator
# Start up swapping.
# Initialize the serial ports.
[paul ~]$ 
			</screen>
			<para>That <command>egrep</command><indexterm><primary>egrep</primary></indexterm> command could also have been written with <command>grep</command><indexterm><primary>grep</primary></indexterm> like this : grep "^# \(Ini\|Sta\|Che\)". The screenshot above was made on Red Hat Enterprise Linux 4.</para>
		</section>
		<section><title>rc scripts</title>
			<para>Init will continue to read /etc/inittab and meets this section on debian linux.</para>
			<screen>
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6
			</screen>
			<para>(on Red Hat Enterprise Linux it is identical except init.d is rc.d.</para>
			<screen>
l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2
l3:3:wait:/etc/rc.d/rc 3
l4:4:wait:/etc/rc.d/rc 4
l5:5:wait:/etc/rc.d/rc 5
l6:6:wait:/etc/rc.d/rc 6
			</screen>
			<para>In both cases, this means that init will start the rc script with as only parameter the runlevel. Actually /etc/inittab has fields seperated by colons. The second field determines the runlevel in which this line should be executed. So in both cases, only one line of the seven will be executed, depending on the runlevel set by initdefault.</para>
			<para>When you take a look in the relevant <command>/etc/rc3.d</command><indexterm><primary>/etc/rc3.d</primary></indexterm> directory, which is real on debian and a symbolic link to <command>/etc/rc.d/rc3.d</command> on Red Hat, then you will see a lot of (links to) scripts who's name start with either uppercase K or uppercase S. When entering a runlevel, scripts with uppercase S are started in alphabetical order with "start" as the only parameter. When leaving a runlevel, the same happens for scripts starting with K. All this is done by the rc script.</para>
		</section>
		<section><title>Power and Ctrl-Alt-Del</title>
			<para>When rc is finished starting all those scripts, init will continue to read /etc/inittab. It will read commands on what to execute in case of <command>powerfailure</command>, powerok and <command>Ctrl-Alt-Delete</command><indexterm><primary>Ctrl-Alt-Delete</primary></indexterm>. The init process never stops keeping an eye on power failures and that triple key combo.</para>
			<para>The relevant part on Red Hat Enterprise Linux.</para>
			<screen>
[paul@RHEL4b ~]$ grep "\(^c\|^p\)" /etc/inittab 
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
pf::powerfail:/sbin/shutdown -f -h +2 "PowerFailure;System Shutting Down"
pr:12345:powerokwait:/sbin/shutdown -c "PowerRestored;Shutdown Cancelled"
			</screen>
			<para>And very similar on Debian Etch.</para>
			<screen>
paul@barry:~$ grep "\(^c\|^p\)" /etc/inittab
ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
pf::powerwait:/etc/init.d/powerfail start
pn::powerfailnow:/etc/init.d/powerfail now
po::powerokwait:/etc/init.d/powerfail stop
 			</screen>
		</section>
		<section><title>getty</title>
			<para>Almost at the end of /etc/inittab, there is a section to start and <command>respawn</command><indexterm><primary>respawn(init)</primary></indexterm> several mingetty's.</para>
			<screen>
[root@RHEL4b ~]# grep getty /etc/inittab 
# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
[root@RHEL4b ~]#
			</screen>
			<para>A mingetty will display a message on a virtual console and allow you to type a userid and sends that info to the login program. The login program will verify whether that user exists in /etc/passwd and prompt for (and verify) a password. If the password is correct, login passes control to the shell listed in /etc/passwd.</para>
			<para>So the getty's are started by init, and watched until they die (user exit's the shell and is logged out). When this happens, the init daemon will respawn a new mingetty. So even if you kill the mingetty's, they will be reborn automatically.</para>
			<screen>
[root@RHEL4b ~]# ps fax |grep mingetty
 3038 tty1     Ss+    0:00 /sbin/mingetty tty1
 3039 tty2     Ss+    0:00 /sbin/mingetty tty2
 3040 tty3     Ss+    0:00 /sbin/mingetty tty3
 3041 tty4     Ss+    0:00 /sbin/mingetty tty4
 3042 tty5     Ss+    0:00 /sbin/mingetty tty5
 3043 tty6     Ss+    0:00 /sbin/mingetty tty6
[root@RHEL4b ~]# kill 3038 3039 3040 3041 3042 3043
[root@RHEL4b ~]# ps fax |grep mingetty
 4774 tty1     Ss+    0:00 /sbin/mingetty tty1
 4884 tty2     Ss+    0:00 /sbin/mingetty tty2
 4974 tty3     Ss+    0:00 /sbin/mingetty tty3
 5026 tty4     Ss+    0:00 /sbin/mingetty tty4
 5073 tty5     Ss+    0:00 /sbin/mingetty tty5
 5098 tty6     Ss+    0:00 /sbin/mingetty tty6
[root@RHEL4b ~]# 			
			</screen>
			<para>You can disable a mingetty for a certain tty by removing the runlevel from the second field in its line in /etc/inittab. Don't forget to tell init about the change of its configuration file with <command>kill -1 1</command><indexterm><primary>kill(1)</primary></indexterm>.</para>
		</section>
	</section>
	<section><title>Starting and stopping daemons</title>
		<para>The K and S scripts usually are links to the real scripts in <command>/etc/init.d</command><indexterm><primary>/etc/init.d</primary></indexterm> or <command>/etc/rc.d/init.d</command><indexterm><primary>/etc/rc.d/init.d</primary></indexterm>. These can also be used when the system is running to start and stop daemons (or services). Most of them accept the following parameters: start, stop, restart, status.</para>
		<screen>
root@laika:~# /etc/init.d/samba restart
 * Stopping Samba daemons...                               [ OK ] 
 * Starting Samba daemons...                               [ OK ] 
root@laika:~# 				
		</screen>
		<para>You can achieve the same result on Red Hat and derived linuxes with the <command>service</command><indexterm><primary>service(1)</primary></indexterm> command. </para>
		<screen>
[root@RHEL4b ~]# service smb restart
Shutting down SMB services:                                [  OK  ]
Shutting down NMB services:                                [  OK  ]
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b ~]# 
		</screen>
	</section>
	<section><title>Display the runlevel</title>
		<para>You can see your current runlevel with the <command>runlevel</command><indexterm><primary>runlevel(1)</primary></indexterm> or <command>who -r</command><indexterm><primary>who -r</primary></indexterm> commands.</para>
		<para>The runlevel command is typical linux and will output the previous and the current runlevel. If there was no previous runlevel, then it will mark it with the letter N.</para>
		<screen>
[root@RHEL4b ~]# runlevel 
N 3
		</screen>
		<para>The history of who -r dates back to older unixes, and it still works on linux.</para>
		<screen>
[root@RHEL4b ~]# who -r
         run-level 3  Jul 28 09:15                   last=S
		</screen>
	</section>
	<section><title>Changing the runlevel</title>
		<para>You can switch to another runlevel with the <command>telinit</command><indexterm><primary>telinit(1)</primary></indexterm> command. On Linux <command>/sbin/telinit</command><indexterm><primary>/sbin/telinit</primary></indexterm> is usually a hard link to /sbin/init.</para>
	</section>
	<section><title>more info</title>
	<para>You might also want to take a look at <command>chkconfig</command><indexterm><primary>chkconfig</primary></indexterm>, <command>update-rc.d</command><indexterm><primary>update-rc.d</primary></indexterm>, <command>shutdown</command><indexterm><primary>shutdown</primary></indexterm>, <command>poweroff</command><indexterm><primary>poweroff</primary></indexterm> and passing <command>init=/bin/bash</command> to the kernel.</para>
</section>
<section><title>Practice</title>
	<para>1. Take a copy of the kernel, initrd and System.map files in /boot in /boot, naming them 3.0 instead of 2.6. Then add a stanza in grub for this 3.0 files.</para>
        <para>2. Change /etc/inittab so that only two mingetty's are respawned. Kill the other mingetty's and verify that they don't come back.</para>
        <para>3. Use the Red Hat Enterprise Linux virtual machine. Go to runlevel 5, display the current and previous runlevel, then go back to runlevel 3.</para>
        <para>4. Is the sysinit script on your computers setting or changing the PATH environment variable ?</para>
        <para>5. Write a script that acts like a daemon script in /etc/init.d/. It should have a case statement to act on start/stop/restart and status. Test the script!</para>
        <para>6. Have your script started automatically in runlevel 3, test that it works. If it works, also try stopping it in a runlevel.</para>
        <para>7. If time permits, use chkconfig to setup your script in runlevels 2 and 3.</para>
	<para></para>
	<para></para>
</section>
<section><title>Solutions</title>
	<para>1. The files should look like in this screenshot, verify the names in /boot. You could do a reboot and test your stanza.</para>
	<screen>
[root@RHEL5 ~]# grep 3.0.18 /boot/grub/menu.lst 
title Red Hat Enterprise Linux Server (3.0.18)
	kernel /vmlinuz-3.0.18 ro root=/dev/VolGroup00/LogVol00 rhgb quiet
	initrd /initrd-3.0.18.img
[root@RHEL5 ~]# 
	</screen>
	<para>2. Killing the mingetty's will result in init respawning them. You can edit /etc/inittab so it looks like the screenshot below. Don't forget to also run kill -1 1. </para>
	<screen>
[root@RHEL5 ~]# grep tty /etc/inittab 
# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2:respawn:/sbin/mingetty tty3
4:2:respawn:/sbin/mingetty tty4
5:2:respawn:/sbin/mingetty tty5
6:2:respawn:/sbin/mingetty tty6
[root@RHEL5 ~]# 
	</screen>
	<para></para>
	<para></para>
	<para></para>
	<para></para>
</section>
</chapter>
