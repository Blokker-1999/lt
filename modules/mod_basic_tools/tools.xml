<section><title>common tools</title>
	<section><title>find</title>
		<para>The <command>find</command><indexterm><primary>find(1)</primary></indexterm> command can be very useful at the start of a pipe, to search for files. Here are some examples. You might want to add <command>2&#062;/dev/null</command> to the command lines to avoid cluttering your screen with error messages.</para>
		<para>Find all files in <command>/etc</command> and put the list in etcfiles.txt</para>
		<screen>find /etc &#062; etcfiles.txt</screen>
		<para>Find all files of the entire system and put the list in allfiles.txt</para>
		<screen>find / &#062; allfiles.txt</screen>
		<para>Find files that end in .conf in the current directory (and all subdirs).</para>
		<screen>find . -name "*.conf"</screen>
		<para>Find files of type file (so not directory or pipe...) that end in .conf.</para>
		<screen>find . -type f -name "*.conf"</screen>
		<para>Find files of type directory that end in .bak .</para>
		<screen>find /data -type d -name "*.bak"</screen>
		<para>Find files that are newer than file42.txt</para>
		<screen>find . -newer file42.txt</screen>
		<para>Find can also execute another command on every file found. This example will look for *.odf files and copy them to /backup/.</para>
		<screen>find "/data/*.odf" -exec cp {} /backup/ \;</screen>
		<para>Find can also execute, after your confirmation, another command on every file found. This example will remove *.odf files if you approve of it for every file found.</para>
		<screen>find "/data/*.odf" -ok rm {} \;</screen>
	</section>
	<section><title>locate</title>
		<para>The <command>locate</command><indexterm><primary>locate(1)</primary></indexterm> tool is very different from <command>find</command> in that it uses an index to locate files. This is a lot faster than traversing all the directories, but it also means that it is always outdated. If the index does not exist yet, then you have to create it (as root on Red Hat Enterprise Linux) with the <command>updatedb</command><indexterm><primary>updatedb(1)</primary></indexterm> command.</para>
		<screen>
[paul@RHEL4b ~]$ locate Samba
warning: locate: could not open database: /var/lib/slocate/slocate.db:...
warning: You need to run the 'updatedb' command (as root) to create th...
Please have a look at /etc/updatedb.conf to enable the daily cron job.
[paul@RHEL4b ~]$ updatedb 
fatal error: updatedb: You are not authorized to create a default sloc...
[paul@RHEL4b ~]$ su -
Password: 
[root@RHEL4b ~]# updatedb
[root@RHEL4b ~]# 
		</screen>
		<para>Most Linux distributions will schedule the <command>updatedb</command> to run once every day.</para>
	</section>
	<section><title>date</title>
		<para>The <command>date</command><indexterm><primary>date</primary></indexterm> can display the date, time, timezone and more.</para>
		<screen>paul@rhel55 ~$ date
Sat Apr 17 12:44:30 CEST 2010
		</screen>
		<para>The date string can be customized to display the format of your choice. Check the manual page for more options.</para>
		<screen>paul@rhel55 ~$ date +'%A %d-%m-%Y'
Saturday 17-04-2010
		</screen>
		<para>Time on any Unix is calculated in number of seconds since 1969 (the first second being the first second of the first of January 1970). Use <command>date +%s</command> to display Unix time in seconds.</para>
		<screen>paul@rhel55 ~$ date +%s
1271501080
		</screen>
		<para>When will this seconds counter reach two thousand million ?</para>
		<screen>paul@rhel55 ~$ date -d '1970-01-01 + 2000000000 seconds'
Wed May 18 04:33:20 CEST 2033
		</screen>
	</section>
	<section><title>cal</title>
		<para>The <command>cal</command><indexterm><primary>cal</primary></indexterm> command displays the current month, with the current day highlighted.</para>
		<screen>
paul@rhel55 ~$ cal
     April 2010     
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30
		</screen>
		<para>You can select any month in the past or the future.</para>
		<screen>paul@rhel55 ~$ cal 2 1970
   February 1970    
Su Mo Tu We Th Fr Sa
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
		</screen>
	</section>
	<section><title>sleep</title>
		<para>The <command>sleep</command><indexterm><primary>sleep</primary></indexterm> is sometimes used in scripts to wait a couple of seconds. This example shows a five second sleep.</para>
		<screen>paul@rhel55 ~$ sleep 5
paul@rhel55 ~$</screen>
	</section>
	<section><title>time</title>
		<para>With <command>time</command><indexterm><primary>time</primary></indexterm> you can display how long it takes to execute a command. The <command>date</command> command takes only a little time.</para>
		<screen>
paul@rhel55 ~$ time date
Sat Apr 17 13:08:27 CEST 2010

real    0m0.014s
user    0m0.008s
sys     0m0.006s
		</screen>
		<para>This <command>sleep 5</command> takes five <command>real</command> seconds to execute, but consumes little <command>cpu time</command>.</para>
		<screen>
paul@rhel55 ~$ time sleep 5

real    0m5.018s
user    0m0.005s
sys     0m0.011s
		</screen>
		<para>This <command>bzip2</command> command compresses a file and uses a lot of <command>cpu time</command>.</para>
		<screen>
paul@rhel55 ~$ time bzip2 text.txt 

real    0m2.368s
user    0m0.847s
sys     0m0.539s
		</screen>
	</section>
</section>
<section><title>compression tools</title>
	<section><title>gzip - gunzip</title>
		<para>Users never have enough space, so compression comes in handy. The <command>gzip</command><indexterm><primary>gzip(1)</primary></indexterm> command can make files take up less space.</para>
		<screen>
paul@rhel55 ~$ ls -lh text.txt 
-rw-rw-r-- 1 paul paul 6.4M Apr 17 13:11 text.txt
paul@rhel55 ~$ gzip text.txt 
paul@rhel55 ~$ ls -lh text.txt.gz 
-rw-rw-r-- 1 paul paul 760K Apr 17 13:11 text.txt.gz
		</screen>
		<para>You can get the original back with <command>gunzip</command><indexterm><primary>gunzip(1)</primary></indexterm>.</para>
		<screen>
paul@rhel55 ~$ gunzip text.txt.gz 
paul@rhel55 ~$ ls -lh text.txt
-rw-rw-r-- 1 paul paul 6.4M Apr 17 13:11 text.txt
		</screen>
	</section>
	<section><title>bzip2 - bunzip2</title>
		<para>Files can also be compressed with <command>bzip2</command><indexterm><primary>bzip2</primary></indexterm> which takes a little more time than <command>gzip</command>, but compresses better.</para>
		<screen>
paul@rhel55 ~$ bzip2 text.txt 
paul@rhel55 ~$ ls -lh text.txt.bz2 
-rw-rw-r-- 1 paul paul 569K Apr 17 13:11 text.txt.bz2
		</screen>
		<para>Files can be uncompressed again with <command>bunzip2</command><indexterm><primary>bunzip2</primary></indexterm>.</para>
		<screen>
paul@rhel55 ~$ bunzip2 text.txt.bz2 
paul@rhel55 ~$ ls -lh text.txt 
-rw-rw-r-- 1 paul paul 6.4M Apr 17 13:11 text.txt
		</screen>
	</section>
	<section><title>zcat - zmore</title>
		<para>Text files that are compressed with <command>gzip</command><indexterm><primary>gzip</primary></indexterm> can be viewed with <command>zcat</command><indexterm><primary>zcat</primary></indexterm> and <command>zmore</command><indexterm><primary>zmore</primary></indexterm>.</para>
		<screen>
paul@rhel55 ~$ head -4 text.txt 
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
paul@rhel55 ~$ gzip text.txt 
paul@rhel55 ~$ zcat text.txt.gz | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
		</screen>
	</section>
	<section><title>bzcat - bzmore</title>
		<para>And in the same way <command>bzcat</command><indexterm><primary>bzcat</primary></indexterm> and <command>bzmore</command><indexterm><primary>bzmore</primary></indexterm> can display files compressed with <command>bzip2</command><indexterm><primary>bzip2</primary></indexterm>.</para>
		<screen>
paul@rhel55 ~$ bzip2 text.txt 
paul@rhel55 ~$ bzcat text.txt.bz2 | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
		</screen>
	</section>
	<section><title>Practice tools and filters</title>
		<para>1. Explain the difference between these two commands. This question is very important. If you don't know the answer, then look back at the bash chapters.</para>
		<screen>find . -name "*.txt"</screen>
		<screen>find . -name *.txt</screen>
		<para>2. Explain the difference between these two statements. Will they both work when there are 200 .odf files in /data/ ? How about when there are 2 million .odf files ?</para>
		<screen>find /data -name "*.odf" > data_odf.txt</screen>
		<screen>find /data/*.odf > data_odf.txt</screen>
	<para>3. Write a find command that finds all files created after january 30th this year.</para>	
	<para>4. Write a find command that finds all *.odf files created in september last year.</para>
	<para>5. Put a sorted list of all bash users in bashusers.txt.</para>
	<para>6. Put a sorted list of all bash users, with their username, userid and home directory in bashusers.info.</para>
	<para>7. Make a list of all non-bash and non-korn users.</para>
	<para>8. Make a list of all files (not directories) in /etc/ that contain the string smb, nmb or samba.</para>
	<para>9. Look at the output of /sbin/ifconfig. Make an ipconfig command that shows only the nic name (eth0), the ip address and the subnet mask.</para>
	<para>10. Make a command abc that removes all non-letters from a file (and replaces them with spaces).</para>
	<para>11. Count the number of *.conf files in /etc and all its subdirs.</para>	
	<para>12. Two commands that do the same thing: copy *.odf files to /backup/ . What would be a reason to replace the first command with the second ? Again, this is an important question.</para>
	<screen>cp -r /data/*.odf /backup/</screen>
	<screen>find /data -name "*.odf" -exec cp {} /backup/ \;</screen>
	<para>13. Create a file called loctest.txt. Can you find this file with locate ? Why not ? How do you make locate find this file ?</para>
	<para>14. Create a file named text.txt that contains this sentence: The zun is shining today. Create a file DICT that contains the words "is shining sun the today", one word on each line. The first file is a text, the second file is a dictionary. Now create a spell checker that uses those two files and outputs the misspelled words (in this case that would be 'zun').</para>
	<para>15. Use find and -exec to rename all .htm files to .html.</para>	
	<para>16. Find the hexadecimal byte value for ascii characters : " 'space' 'tab' A and a .</para>	
	<para>17. List all files in the current directory of size between 10 and 20 bytes.</para>
	<para>18. List all files in your home directory that have more than one hard link (hint: use the find tool).</para>	
	<para></para>	
	<para></para>	
	<para>Always take time to properly <command>document</command> every script that you write!</para>
	<para></para>	
	<para>Image copied from <command>xkcd.com</command><indexterm><primary>http://xkcd.com</primary></indexterm>.</para>
	<mediaobject><imageobject><imagedata fileref="images/command_line_fu.jpg" format="EPS" align="center"></imagedata></imageobject></mediaobject>	
	<para></para>	
	</section>
	<section><title>Solutions: tools and filters</title>
	<para>1. The shell will not touch the *.txt because it is between double quotes. The find tool will look in the current directory for all files ending in .txt.</para>
	<screen>find . -name "*.txt"</screen>
	<para>The shell will expand the *.txt to all files in the current directory that end in .txt. Then find will give you a syntax error.</para>
	<screen>find . -name *.txt</screen>
	<para>3. use find with the -newer option related to a marker file</para>
	<screen>touch -t 200901302359 marker_date
find . -type f -newer marker_date </screen>
	<para>4. the same as 3. but add a negation to create an "older than" statement</para>
	<screen>touch -t 200808312359 marker_date_start
touch -t 2008100100 marker_date_end
find . -type f -newer marker -_date_start ! -newer marker_date_end </screen>
	<para>14. The one line spell checker.</para>
	<screen>
[paul]$ echo "The zun is shining today" > text.txt
[paul]$ cat > DICT
is
shining
sun
the
today
[paul]$ cat text.txt| tr 'A-Z ' 'a-z\n' |sort|uniq|comm -2 -3 - DICT
zun
[paul]$
	</screen>
	<para>18. Use find to look in your home directory(~) for regular files(-type f) that do not(!) have one hard link(-links 1).</para>
	<screen>find ~ ! -links 1 -type f</screen>
	</section>
</section>
