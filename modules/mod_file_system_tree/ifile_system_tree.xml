	<section><title>Unix is case sensitive</title>
		<para>Unix is <command>case sensitive</command><indexterm><primary>case sensitive</primary></indexterm>, this means that FILE1 is different from file1, and /etc/hosts is different from /etc/Hosts (the latter one does not exist on a typical Unix). </para>
	</section>
	<section><title>The linux file system tree</title>
		<para>All Unix systems have a directory structure that starts at the <command>root directory</command><indexterm><primary>root directory</primary></indexterm>. The root directory is represented by a slash, like this: <command>/</command><indexterm><primary>/</primary></indexterm> . Everything that exists on your linux system can be found below this root directory. Let's take a brief look at the contents of the root directory.</para>
		<screen>
[paul@RHELv4u3 ~]$ ls /
bin   dev  home  media  mnt  proc  sbin     srv  tftpboot  usr
boot  etc  lib   misc   opt  root  selinux  sys  tmp       var
[paul@RHELv4u3 ~]$ 
		</screen>
		<section><title>Filesystem Hierarchy</title>
			<para>There are some differences between the flavors of Unix. For help about your machine, enter <command>man hier</command><indexterm><primary>man hier</primary></indexterm> to find information about the file system hierarchy. Red Hat, Novell Suse, even Sun's Solaris all aim to follow the <command>Filesystem Hierarchy Standard</command><indexterm><primary>Filesystem Hierarchy Standard</primary></indexterm> (FHS). Maybe the FHS will make more Unix file systems unite in the future. Let's take a look at the <command>FHS</command><indexterm><primary>FHS</primary></indexterm>.</para>
		</section>
		<section><title>Filesystem Hierarchy Standard</title>
			<para>On http://www.pathname.com/fhs/ we read "The filesystem hierarchy standard has been designed to be used by Unix distribution developers, package developers, and system implementors. However, it is primarily intended to be a reference and is not a tutorial on how to manage a Unix filesystem or directory hierarchy." Below we will discuss a couple of root directories. <emphasis>For a complete reference, you'll have to check with every developer and system administrator in the world ;-)</emphasis></para>
		</section>
		<section><title>/bin binaries</title>
			<para>The <command>/bin</command><indexterm><primary>/bin</primary></indexterm> directory contains binaries for use by all users. According to the FHS /bin/date should exist, and /bin should contain /bin/cat. You will find a bin subdirectory in many other directories. Binaries are sometimes called <command>executables</command><indexterm><primary>executables</primary></indexterm>. In the screenshot below you see a lot of common unix commands like cat, cp, cpio, date, dd, echo, grep and so on. A lot of these will be covered in this book.</para>
<screen>
paul@laika:~$ ls /bin
archdetect       egrep             mt               setupcon
autopartition    false             mt-gnu           sh
bash             fgconsole         mv               sh.distrib
bunzip2          fgrep             nano             sleep
bzcat            fuser             nc               stralign
bzcmp            fusermount        nc.traditional   stty
bzdiff           get_mountoptions  netcat           su
bzegrep          grep              netstat          sync
bzexe            gunzip            ntfs-3g          sysfs
bzfgrep          gzexe             ntfs-3g.probe    tailf
bzgrep           gzip              parted_devices   tar
bzip2            hostname          parted_server    tempfile
bzip2recover     hw-detect         partman          touch
bzless           ip                partman-commit   true
bzmore           kbd_mode          perform_recipe   ulockmgr
cat              kill              pidof            umount
check-fc         ld_static         ping             uname
chgrp            list-devices      ping6            uncompress
chmod            ln                ps               update-dev
chown            loadkeys          pwd              user-params
cp               login             rbash            vdir
cpio             log-output        readlink         which
dash             ls                register-module  zcat
date             lsmod             rm               zcmp
dd               lspci             rmdir            zdiff
debconf-get      mapdevfs          rnano            zegrep
df               mkdir             run-parts        zfgrep
dir              mknod             search-path      zforce
dmesg            mktemp            sed              zgrep
...
</screen>
		</section>
		<section><title>/boot static files to boot the system</title>
			<para>The <command>/boot</command><indexterm><primary>/boot</primary></indexterm> directory contains all files needed to boot the computer. These files don't change very often. On Linux systems you typically find the <command>/boot/grub</command><indexterm><primary>/boot/grub</primary></indexterm> directory here. This /boot/grub contains <command>/boot/grub/menu.lst</command><indexterm><primary>/boot/grub/menu.lst</primary></indexterm> (the grub configuration file), which defines the bootmenu that is being displayed before the kernel starts.</para>
		</section>
		<section><title>/dev device files</title>
			<para>Device files in <command>/dev</command><indexterm><primary>/dev</primary></indexterm> appear to be ordinary files, but are not located on the harddisk. Instead they are an interface for a device driver toward a (physical or special) device.</para>
			<section><title>Common physical devices</title>
				<para>Common hardware such as hard disk devices are represented by device files in <command>/dev</command>. Below a screenshot of SATA device files on a laptop and then IDE attached drives on a desktop. (The detailed meaning of these devices will be discussed later.)</para>
				<screen>
#
# SATA or SCSI
#
paul@laika:~$ ls /dev/sd*
/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb  /dev/sdb1  /dev/sdb2

#
# IDE or ATAPI
#
paul@barry:~$ ls /dev/hd*
/dev/hda  /dev/hda1  /dev/hda2  /dev/hdb  /dev/hdb1  /dev/hdb2  /dev/hdc
				</screen>
				<para>Besides representing physical hardware, some device files are special. These special devices can be very useful.</para>
			</section>
			<section><title>/dev/tty and /dev/pts</title>
				<para>For example <command>/dev/tty1</command><indexterm><primary>/dev/tty1</primary></indexterm> represents a terminal or console attached to the system. (Don't break your head on the exact terminology of 'terminal' or 'console', what we mean here is a commandline interface.) When typing commands in a terminal that is part of a graphical interface like Gnome or KDE, then your terminal will be represented as <command>/dev/pts/1</command><indexterm><primary>/dev/pts/1</primary></indexterm> (1 can be another number).</para>
			</section>
			<section><title>/dev/null</title>
				<para>On Linux you will find special devices like <command>/dev/null</command><indexterm><primary>/dev/null</primary></indexterm> which can be considered a black hole, it has unlimited storage, but nothing can be retrieved from it. Technically speaking, anything given to /dev/null will be discarded. /dev/null can be useful to discard unwanted output from commands. <emphasis>/dev/null is not a good location to store all your backups ;-)</emphasis>.</para>
			</section>
			<section><title>/dev/zero</title>
				<para>Another Linux special device is <command>/dev/zero</command><indexterm><primary>/dev/zero</primary></indexterm>, which can be considered a source of zeroes. You cannot sent something to /dev/zero, but you can read zeroes from it.</para>
			</section>
			<section><title>/dev/random</title>
				<para>This device acts as a <command>random number generator</command><indexterm><primary>random number generator</primary></indexterm> on any Unix machine.</para>
			</section>
		</section>
		<section><title>/etc Configuration Files</title>
			<para>All of the machine-specific configuration files should be located in <command>/etc</command><indexterm><primary>/etc</primary></indexterm>. Many times the name of a configuration files is the same as the application or daemon or protocol with .conf added as an extension. But there is much more to be found in /etc.</para>
			<screen>
paul@laika:~$ ls /etc/*.conf
/etc/adduser.conf        /etc/ld.so.conf       /etc/scrollkeeper.conf
/etc/brltty.conf         /etc/lftp.conf        /etc/sysctl.conf
/etc/ccertificates.conf  /etc/libao.conf       /etc/syslog.conf
/etc/cvs-cron.conf       /etc/logrotate.conf   /etc/ucf.conf
/etc/ddclient.conf       /etc/ltrace.conf      /etc/uniconf.conf
/etc/debconf.conf        /etc/mke2fs.conf      /etc/updatedb.conf
/etc/deluser.conf        /etc/netscsid.conf    /etc/usplash.conf
/etc/fdmount.conf        /etc/nsswitch.conf    /etc/uswsusp.conf
/etc/hdparm.conf         /etc/pam.conf         /etc/vnc.conf
/etc/host.conf           /etc/pnm2ppa.conf     /etc/wodim.conf
/etc/inetd.conf          /etc/povray.conf      /etc/wvdial.conf
/etc/kernel-img.conf     /etc/resolv.conf
paul@laika:~$ 
			</screen>
			<section><title>/etc/X11/</title>
				<para>The graphical display (aka <command>X Window System</command><indexterm><primary>X Window System</primary></indexterm> or just <command>X</command><indexterm><primary>X</primary></indexterm>) is driven by software from the X.org foundation. The configuration file for your graphical display is <command>/etc/X11/xorg.conf</command><indexterm><primary>/etc/X11/xorg.conf</primary></indexterm>. </para>
			</section>
			<section><title>/etc/filesystems</title>
				<para>When mounting a file system without specifying explicitly the file system, then <command>mount</command><indexterm><primary>mount</primary></indexterm> will first probe <command>/etc/filesystems</command><indexterm><primary>/etc/filesystems</primary></indexterm>. Mount will skip lines with the <command>nodev</command><indexterm><primary>nodev</primary></indexterm> directive, and should this file end with a single * on the last line, then mount will continue probing <command>/proc/filesystems</command><indexterm><primary>/proc/filesystems</primary></indexterm>.</para>
				<screen>
paul@RHELv4u4:~$ cat /etc/filesystems 
ext3
ext2
nodev proc
nodev devpts
iso9660
vfat
hfs
paul@RHELv4u4:~$
				</screen>
			</section>
			<section><title>/etc/redhat-release</title>
			<para>This file contains the Red Hat version on most of the Red Hat and Red Hat derived systems.</para>
			<screen>
paul@RHELv4u4:~$ cat /etc/redhat-release 
Red Hat Enterprise Linux AS release 4 (Nahant Update 4)
paul@RHELv4u4:~$
			</screen>
			</section>
			<section><title>/etc/skel/</title>
				<para>The <command>skeleton</command><indexterm><primary>skeleton</primary></indexterm> directory <command>/etc/skel</command><indexterm><primary>/etc/skel</primary></indexterm> is copied to the home directory of a newly created user.</para>
			</section>
			<section><title>/etc/sysconfig/</title>
				<para>This directory, which is not mentioned in the FHS, contains a lot of Red Hat Enterprise Linux configuration files. We will discuss some of them in greater detail. The screenshot below is the <command>/etc/sysconfig</command><indexterm><primary>/etc/sysconfig</primary></indexterm> from RHELv4u4 with everything installed.</para>
				<screen>
paul@RHELv4u4:~$ ls /etc/sysconfig/
apmd         firstboot     irda              network      saslauthd
apm-scripts  grub          irqbalance        networking   selinux
authconfig   hidd          keyboard          ntpd         spamassassin
autofs       httpd         kudzu             openib.conf  squid
bluetooth    hwconf        lm_sensors        pand         syslog
clock        i18n          mouse             pcmcia       sys-config-sec
console      init          mouse.B           pgsql        sys-config-users
crond        installinfo   named             prelink      sys-logviewer
desktop      ipmi          netdump           rawdevices   tux
diskdump     iptables      netdump_id_dsa    rhn          vncservers
dund         iptables-cfg  netdump_id_dsa.p  samba        xinetd
paul@RHELv4u4:~$ 
				</screen>
				<para>The file <command>/etc/sysconfig/firstboot</command><indexterm><primary>/etc/sysconfig/firstboot</primary></indexterm> tells the Red Hat Setup Agent to not run at boot time. If you want to run the Red Hat Setup Agent at the next reboot, then simply remove this file, and run <command>chkconfig --level 5 firstboot on</command><indexterm><primary>chkconfig</primary></indexterm>. The Red Hat Setup Agent allows you to install the latest updates, create a user account, join the Red Hat Network and more. It will then create the /etc/sysconfig/firstboot file again.</para>
				<screen>
paul@RHELv4u4:~$ cat /etc/sysconfig/firstboot 
RUN_FIRSTBOOT=NO
				</screen>
				<para>The file <command>/etc/sysconfig/harddisks</command><indexterm><primary>/etc/sysconfig/harddisks</primary></indexterm> contains some parameters to tune the hard disks. The file explains itself.</para>
				<para>You can see hardware detected by <command>kudzu</command><indexterm><primary>kudzu</primary></indexterm> in <command>/etc/sysconfig/hwconf</command><indexterm><primary>/etc/sysconfig/hwconf</primary></indexterm>. Kudzu is software from Red Hat for automatic discovery and configuration of hardware.</para>
				<para>The keyboard type and table are set in the <command>/etc/sysconfig/keyboard</command><indexterm><primary>/etc/sysconfig/keyboard</primary></indexterm> file. For more console keyboard information, check the manual pages of <command>keymaps(5)</command><indexterm><primary>keymaps(5)</primary></indexterm>, <command>dumpkeys(1)</command><indexterm><primary>dumpkeys(1)</primary></indexterm>, <command>loadkeys(1)</command><indexterm><primary>loadkeys(1)</primary></indexterm> and the directory <command>/lib/kbd/keymaps/</command><indexterm><primary>/lib/kbd/keymaps/</primary></indexterm>.</para>
				<screen>
root@RHELv4u4:/etc/sysconfig# cat keyboard 
KEYBOARDTYPE="pc"
KEYTABLE="us"
				</screen>
				<para>We will discuss the networking files in this directory in the networking chapter.</para>
			</section>
		</section>
		<section><title>/home sweet home</title>
			<para>You will find a lot of locations with an extensive hierarchy of personal or project data under <command>/home</command><indexterm><primary>/home</primary></indexterm>. It is common practice (but not mandatory) to name the users home directory after their username in the format /home/$USERNAME. Like in this example:</para>
			<screen>
paul@pasha:~$ ls /home 
geert  guillaume  maria  paul  tom
			</screen>
			<para>Besides giving every user (or every project or group) a location to store personal files, the home directory of a user also serves as a location to store the user profile. A typical Unix user profile contains a bunch of hidden files (files who's filename starts with a dot). The hidden files of the Unix user profile contain settings specific for that user.</para>
			<screen>
paul@pasha:~$ ls -d /home/paul/.*
/home/paul/.              /home/paul/.bash_profile  /home/paul/.ssh
/home/paul/..             /home/paul/.bashrc        /home/paul/.viminfo
/home/paul/.bash_history  /home/paul/.lesshst       /home/paul/.Xauthority
			</screen>
		</section>
		<section><title>/initrd</title>
			<para>This empty directory is used as a mount point by Red Hat Enterprise Linux during boot time. Removing it causes a kernel panic during the next boot.</para>
		</section>
		<section><title>/lib shared libraries</title>
			<para>Binaries, like those found in /bin, often use shared libraries located in <command>/lib</command><indexterm><primary>/lib</primary></indexterm>. Below a partial screenshot of the contents of /lib.</para>
			<screen>
paul@laika:~$ ls /lib/libc*
/lib/libc-2.5.so     /lib/libcfont.so.0.0.0  /lib/libcom_err.so.2.1    
/lib/libcap.so.1     /lib/libcidn-2.5.so     /lib/libconsole.so.0      
/lib/libcap.so.1.10  /lib/libcidn.so.1       /lib/libconsole.so.0.0.0  
/lib/libcfont.so.0   /lib/libcom_err.so.2    /lib/libcrypt-2.5.so      
			</screen>
			<section><title>/lib/modules</title>
				<para>Typically, the kernel loads kernel modules from <command>/lib/modules</command><indexterm><primary>/lib/modules</primary></indexterm>. </para>
			</section>
			<section><title>/lib32 and /lib64</title>
				<para>We are now (the year 2007) in a transition between 32-bit and 64-bit systems. So you might encounter directories named <command>/lib32</command><indexterm><primary>/lib32</primary></indexterm> and <command>/lib64</command><indexterm><primary>/lib64</primary></indexterm>, to clarify the register size used at compilation time of the libraries. My current 64-bit laptop has some older 32-bit binaries and libraries for compatibility with legacy applications. The screenshot uses the <command>file</command><indexterm><primary>file(1)</primary></indexterm> utility to point out the difference.</para>
				<screen>
paul@laika:~$ file /lib32/libc-2.5.so 
/lib32/libc-2.5.so: ELF 32-bit LSB shared object, Intel 80386, \
version 1 (SYSV), for GNU/Linux 2.6.0, stripped
paul@laika:~$ file /lib64/libcap.so.1.10 
/lib64/libcap.so.1.10: ELF 64-bit LSB shared object, AMD x86-64, \
version 1 (SYSV), stripped
				</screen>
				<para>The ELF <command>Executable and Linkable Format</command><indexterm><primary>ELF</primary></indexterm> is used in almost every Unix-like operating system since System V.</para>
			</section>
		</section>
		<section><title>/media for Removable Media</title>
			<para>The <command>/media</command><indexterm><primary>/media</primary></indexterm> directory serves as a mount point for removable media, meaning devices such as CD-ROM's, digital cameras and various usb-attached devices. Since <command>/media</command> is rather new in the Unix world, you could very well encounter systems running without this directory. Solaris 9 does not have it, Solaris 10 does.</para>
			<screen>
paul@laika:~$ ls /media/
cdrom  cdrom0  usbdisk
			</screen>
		</section>
		<section><title>/mnt standard mount point</title>
			<para>Older Unixes (and Linuxes) used to mount all kind of stuff under /mnt/something/. According to the FHS, <command>/mnt</command><indexterm><primary>/mnt</primary></indexterm> should only be used to temporarily mount something. But you will most likely witness a lot of systems with more than one directory underneath /mnt used as a mountpoint for various local and remote filesystems.</para>
		</section>
		<section><title>/opt Optional software</title>
			<para>Most of my systems today have an empty <command>/opt</command><indexterm><primary>/opt</primary></indexterm> directory. It is considered outdated, but you might find some systems with add-on software installed in /opt. If that is the case, the package should install all its files in the typical bin, lib, etc subdirectories in /opt/$packagename/. If for example the package is called wp, then it installs in /opt/wp, putting binaries in /opt/wp/bin and manpages in /opt/wp/man. Most of the default software which comes along with the distribution, will not be installed in /opt.</para>
		</section>
		<section><title>/proc conversation with the kernel</title>
		<para><command>/proc</command><indexterm><primary>/proc</primary></indexterm> is another special directory, appearing to be ordinary files, but not taking up diskspace. It is actually a view on the kernel, or better on what the kernel sees, and a means to talk to the kernel directly. <command>/proc</command> is a proc filesystem.</para>
			<screen>
paul@RHELv4u4:~$ mount -t proc
none on /proc type proc (rw)
			</screen>
			<para>When listing the /proc directory, you will see a lot of numbers (on any Unix), and some interesting files (on Linux)</para>
			<screen>
mul@laika:~$ ls /proc
1      2339   4724  5418  6587  7201       cmdline      mounts
10175  2523   4729  5421  6596  7204       cpuinfo      mtrr
10211  2783   4741  5658  6599  7206       crypto       net
10239  2975   4873  5661  6638  7214       devices      pagetypeinfo
141    29775  4874  5665  6652  7216       diskstats    partitions
15045  29792  4878  5927  6719  7218       dma          sched_debug
1519   2997   4879  6     6736  7223       driver       scsi
1548   3      4881  6032  6737  7224       execdomains  self
1551   30228  4882  6033  6755  7227       fb           slabinfo
1554   3069   5     6145  6762  7260       filesystems  stat
1557   31422  5073  6298  6774  7267       fs           swaps
1606   3149   5147  6414  6816  7275       ide          sys
180    31507  5203  6418  6991  7282       interrupts   sysrq-trigger
181    3189   5206  6419  6993  7298       iomem        sysvipc
182    3193   5228  6420  6996  7319       ioports      timer_list
18898  3246   5272  6421  7157  7330       irq          timer_stats
19799  3248   5291  6422  7163  7345       kallsyms     tty
19803  3253   5294  6423  7164  7513       kcore        uptime
19804  3372   5356  6424  7171  7525       key-users    version
1987   4      5370  6425  7175  7529       kmsg         version_signature
1989   42     5379  6426  7188  9964       loadavg      vmcore
2      45     5380  6430  7189  acpi       locks        vmnet
20845  4542   5412  6450  7191  asound     meminfo      vmstat
221    46     5414  6551  7192  buddyinfo  misc         zoneinfo
2338   4704   5416  6568  7199  bus        modules
			</screen>
			<para>Let's investigate the file properties inside /proc. Looking at the date and time will display the current date and time, meaning the files are constantly updated (A view on the kernel).</para>
			<screen>
paul@RHELv4u4:~$ date
Mon Jan 29 18:06:32 EST 2007
paul@RHELv4u4:~$ ls -al /proc/cpuinfo 
-r--r--r--  1 root root 0 Jan 29 18:06 /proc/cpuinfo
paul@RHELv4u4:~$ 
paul@RHELv4u4:~$  ...time passes...
paul@RHELv4u4:~$ 
paul@RHELv4u4:~$ date
Mon Jan 29 18:10:00 EST 2007
paul@RHELv4u4:~$ ls -al /proc/cpuinfo 
-r--r--r--  1 root root 0 Jan 29 18:10 /proc/cpuinfo
			</screen>
			<para>Most files in /proc are 0 bytes, yet they contain data, sometimes a lot of data. You can see this by executing cat on files like <command>/proc/cpuinfo</command><indexterm><primary>/proc/cpuinfo</primary></indexterm>, which contains information on the CPU. </para>
			<screen>
paul@RHELv4u4:~$ file /proc/cpuinfo 
/proc/cpuinfo: empty
paul@RHELv4u4:~$ cat /proc/cpuinfo 
processor       : 0
vendor_id       : AuthenticAMD
cpu family      : 15
model           : 43
model name      : AMD Athlon(tm) 64 X2 Dual Core Processor 4600+
stepping        : 1
cpu MHz         : 2398.628
cache size      : 512 KB
fdiv_bug        : no
hlt_bug         : no
f00f_bug        : no
coma_bug        : no
fpu             : yes
fpu_exception   : yes
cpuid level     : 1
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge...
bogomips        : 4803.54
			</screen>
			<para><emphasis>Just for fun, here is /proc/cpuinfo on a Sun Sunblade 1000...</emphasis></para>
			<screen>
paul@pasha:~$ cat /proc/cpuinfo
cpu : TI UltraSparc III (Cheetah)
fpu : UltraSparc III integrated FPU
promlib : Version 3 Revision 2
prom : 4.2.2
type : sun4u
ncpus probed : 2
ncpus active : 2
Cpu0Bogo : 498.68
Cpu0ClkTck : 000000002cb41780
Cpu1Bogo : 498.68
Cpu1ClkTck : 000000002cb41780
MMU Type : Cheetah
State:
CPU0: online
CPU1: online 
			</screen>
			<para><emphasis>... and on a Sony Playstation 3.</emphasis></para>
			<screen>
[root@ps3 tmp]# uname -a
Linux ps3 2.6.20-rc5 #58 SMP Thu Jan 18 13:35:01 CET 2007 ppc64 ppc64
ppc64 GNU/Linux
[root@ps3 tmp]# cat /proc/cpuinfo
processor       : 0
cpu             : Cell Broadband Engine, altivec supported
clock           : 3192.000000MHz
revision        : 5.1 (pvr 0070 0501)

processor       : 1
cpu             : Cell Broadband Engine, altivec supported
clock           : 3192.000000MHz
revision        : 5.1 (pvr 0070 0501)

timebase        : 79800000
platform        : PS3
machine         : PS3 
			</screen>
			<para>Most of the files in /proc are read only, some require root privileges. But some files are writable, a lot of files in <command>/proc/sys</command><indexterm><primary>/proc/sys</primary></indexterm> are writable. Let's discuss some of the files in /proc.</para>
			<section><title>/proc/cmdline</title>
				<para>The parameters that were passed to the kernel at boot time are in <command>/proc/cmdline</command><indexterm><primary>/proc/cmdline</primary></indexterm>.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/cmdline 
ro root=/dev/VolGroup00/LogVol00 rhgb quiet
				</screen>
			</section>
			<section><title>/proc/filesystems</title>
				<para>The <command>/proc/filesystems</command><indexterm><primary>/proc/filesystems</primary></indexterm> file displays a list of supported file systems. When you mount a file system without explicitly defining one, then mount will first try to probe <command>/etc/filesystems</command><indexterm><primary>/etc/filesystems</primary></indexterm> and then probe <command>/proc/filesystems</command> for all the filesystems in there without the <command>nodev</command><indexterm><primary>nodev</primary></indexterm> label. If /etc/filesystems ends with a line containing nothing but a *, then both files are probed.</para> 
				<screen>
paul@RHELv4u4:~$ cat /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
nodev   sockfs
nodev   binfmt_misc
nodev   usbfs
nodev   usbdevfs
nodev   futexfs
nodev   tmpfs
nodev   pipefs
nodev   eventpollfs
nodev   devpts
        ext2
nodev   ramfs
nodev   hugetlbfs
        iso9660
nodev   relayfs
nodev   mqueue
nodev   selinuxfs
        ext3
nodev   rpc_pipefs
nodev   vmware-hgfs
nodev   autofs
paul@RHELv4u4:~$
				</screen>
			</section>
			<section><title>/proc/interrupts</title>
				<para>On the x86 architecture, <command>/proc/interrupts</command><indexterm><primary>/proc/interrupts</primary></indexterm> displays the interrupts.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/interrupts 
           CPU0       
  0:   13876877    IO-APIC-edge  timer
  1:         15    IO-APIC-edge  i8042
  8:          1    IO-APIC-edge  rtc
  9:          0   IO-APIC-level  acpi
 12:         67    IO-APIC-edge  i8042
 14:        128    IO-APIC-edge  ide0
 15:     124320    IO-APIC-edge  ide1
169:     111993   IO-APIC-level  ioc0
177:       2428   IO-APIC-level  eth0
NMI:          0 
LOC:   13878037 
ERR:          0
MIS:          0
paul@RHELv4u4:~$ 
				</screen>
				<para>On a machine with two CPU's, the file looks like this.</para>
				<screen>
paul@laika:~$ cat /proc/interrupts 
          CPU0      CPU1       
  0:    860013        0  IO-APIC-edge     timer
  1:      4533        0  IO-APIC-edge     i8042
  7:         0        0  IO-APIC-edge     parport0
  8:   6588227        0  IO-APIC-edge     rtc
 10:      2314        0  IO-APIC-fasteoi  acpi
 12:       133        0  IO-APIC-edge     i8042
 14:         0        0  IO-APIC-edge     libata
 15:     72269        0  IO-APIC-edge     libata
 18:         1        0  IO-APIC-fasteoi  yenta
 19:    115036        0  IO-APIC-fasteoi  eth0
 20:    126871        0  IO-APIC-fasteoi  libata, ohci1394
 21:     30204        0  IO-APIC-fasteoi  ehci_hcd:usb1, uhci_hcd:usb2
 22:      1334        0  IO-APIC-fasteoi  saa7133[0], saa7133[0]
 24:    234739        0  IO-APIC-fasteoi  nvidia
NMI:        72       42 
LOC:    860000   859994 
ERR:         0
paul@laika:~$
				</screen>
			</section>
			<section><title>/proc/kcore</title>
				<para>The physical memory is represented in <command>/proc/kcore</command><indexterm><primary>/proc/kcore</primary></indexterm>. Do not try to cat this file, instead use a debugger. The size of /proc/kcore is the same as your physical memory, plus four bytes.</para>
				<screen>
paul@laika:~$ ls -lh /proc/kcore 
-r-------- 1 root root 2.0G 2007-01-30 08:57 /proc/kcore
paul@laika:~$ 
				</screen>
			</section>
			<section><title>/proc/mdstat</title>
				<para>You can obtain RAID information from the kernel by displaying <command>/proc/mdstat</command><indexterm><primary>/proc/mdstat</primary></indexterm>. With a RAID configured, it looks like this.</para>
				<screen>
paul@RHELv4u2:~$ cat /proc/mdstat 
Personalities : [raid5] 
md0 : active raid5 sdd1[2] sdc1[1] sdb1[0]
      2088192 blocks level 5, 64k chunk, algorithm 2 [3/3] [UUU]
      
unused devices: &#060;none&#062;
paul@RHELv4u2:~$ 
				</screen>
				<para>When there is no RAID present, the following is displayed.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/mdstat 
Personalities : 
unused devices: &#060;none&#062;
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/meminfo</title>
				<para>You will rarely want to look at <command>/proc/meminfo</command><indexterm><primary>/proc/meminfo</primary></indexterm>...</para>
			<screen>
paul@RHELv4u4:~$ cat /proc/meminfo 
MemTotal:       255864 kB
MemFree:          5336 kB
Buffers:         42396 kB
Cached:         159912 kB
SwapCached:          0 kB
Active:         104184 kB
Inactive:       119724 kB
HighTotal:           0 kB
HighFree:            0 kB
LowTotal:       255864 kB
LowFree:          5336 kB
SwapTotal:     1048568 kB
SwapFree:      1048568 kB
Dirty:              40 kB
Writeback:           0 kB
Mapped:          33644 kB
Slab:            21956 kB
CommitLimit:   1176500 kB
Committed_AS:    82984 kB
PageTables:        960 kB
VmallocTotal:   761848 kB
VmallocUsed:      2588 kB
VmallocChunk:   759096 kB
HugePages_Total:     0
HugePages_Free:      0
Hugepagesize:     4096 kB
				</screen>
				<para> ...since the <command>free</command><indexterm><primary>free(1)</primary></indexterm> command displays the same information in a more user friendly output.</para>
				<screen>
paul@RHELv4u4:~$ free -om
           total      used      free    shared   buffers    cached
Mem:         249       244         5         0        41       156
Swap:       1023         0      1023
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/modules</title>
				<para><command>/proc/modules</command><indexterm><primary>/proc/modules</primary></indexterm> lists all modules loaded by the kernel. The output would be too long to display here, so lets <command>grep</command><indexterm><primary>grep</primary></indexterm> for a few. First vm (from Vmware), which tells us that vmmon and vmnet are both loaded. You can display the same information with <command>lsmod</command><indexterm><primary>lsmod</primary></indexterm>. </para>
				<screen>
paul@laika:~$ cat /proc/modules | grep vm
vmnet 36896 13 - Live 0xffffffff88b21000 (P)
vmmon 194540 0 - Live 0xffffffff88af0000 (P)
paul@laika:~$ lsmod | grep vm
vmnet                  36896  13 
vmmon                 194540  0 
paul@laika:~$ 
				</screen>
				<para>Some modules depend on others. In the following example, you can see that the nfsd module is used by exportfs, lockd and sunrpc. </para>
				<screen>
paul@laika:~$ cat /proc/modules | grep nfsd
nfsd 267432 17 - Live 0xffffffff88a40000
exportfs 7808 1 nfsd, Live 0xffffffff88a3d000
lockd 73520 3 nfs,nfsd, Live 0xffffffff88a2a000
sunrpc 185032 12 nfs,nfsd,lockd, Live 0xffffffff889fb000
paul@laika:~$ lsmod | grep nfsd
nfsd                  267432  17 
exportfs                7808  1 nfsd
lockd                  73520  3 nfs,nfsd
sunrpc                185032  12 nfs,nfsd,lockd
paul@laika:~$ 
				</screen>
			</section>
			<section><title>/proc/mounts</title>
				<para>Like the <command>mount</command><indexterm><primary>mount</primary></indexterm> command and the <command>/etc/mtab</command><indexterm><primary>/etc/mtab</primary></indexterm> file, <command>/proc/mounts</command><indexterm><primary>/proc/mounts</primary></indexterm> lists all the mounted file systems. But /proc/mounts displays what the kernel sees, so it is always up to date and correct. You see the device, mount point, file system, read-only or read-write and two zero's.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/mounts 
rootfs / rootfs rw 0 0
/proc /proc proc rw,nodiratime 0 0
none /dev tmpfs rw 0 0
/dev/root / ext3 rw 0 0
none /dev tmpfs rw 0 0
none /selinux selinuxfs rw 0 0
/proc /proc proc rw,nodiratime 0 0
/proc/bus/usb /proc/bus/usb usbfs rw 0 0
/sys /sys sysfs rw 0 0
none /dev/pts devpts rw 0 0
/dev/sda1 /boot ext3 rw 0 0
none /dev/shm tmpfs rw 0 0
none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0
sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw 0 0
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/partitions</title>
				<para>The <command>/proc/partitions</command><indexterm><primary>/proc/partitions</primary></indexterm> file contains a table with major and minor number of partitioned devices, their number of blocks and the device name in <command>/dev</command><indexterm><primary>/dev</primary></indexterm>. Verify with <command>/proc/devices</command><indexterm><primary>/proc/devices</primary></indexterm> to link the major number to the proper device.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/partitions 
major minor  #blocks  name

   3     0     524288 hda
   3    64     734003 hdb
   8     0    8388608 sda
   8     1     104391 sda1
   8     2    8281507 sda2
   8    16    1048576 sdb
   8    32    1048576 sdc
   8    48    1048576 sdd
 253     0    7176192 dm-0
 253     1    1048576 dm-1
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/swaps</title>
				<para>You can find information about <command>swap partition(s)</command><indexterm><primary>swap partition(s)</primary></indexterm> in <command>/proc/swaps</command><indexterm><primary>/proc/swaps</primary></indexterm>.</para>
				<screen>paul@RHELv4u4:~$ cat /proc/swaps 
Filename                           Type        Size    Used    Priority
/dev/mapper/VolGroup00-LogVol01    partition   1048568 0       -1
paul@RHELv4u4:~$ 
				</screen>
			</section>
		</section>
		<section><title>/root the superuser's home</title>
			<para>On many systems, <command>/root</command><indexterm><primary>/root</primary></indexterm> is the default location for the root user's personal data and profile. If it does not exist by default, then some administrators create it. </para>
		</section>
		<section><title>/sbin system binaries</title>
			<para>Similar to /bin, but mainly for booting and for tools to configure the system. A lot of the system binaries will require root privileges for certain tasks. You will also find a <command>/sbin</command><indexterm><primary>/sbin</primary></indexterm> subdirectory in other directories.</para>
		</section>
		<section><title>/srv served by your system</title>
			<para>You may find <command>/srv</command><indexterm><primary>/srv</primary></indexterm> to be empty on many systems, but not for long. The FHS suggests locating cvs, rsync, ftp and www data to this location. The FHS also approves administrative naming in /srv, like /srv/project55/ftp and /srv/sales/www. Red Hat plans to move some data that is currently located in /var to /srv. </para>
		</section>
		<section><title>/sys Linux 2.6 hot plugging</title>
			<para>The <command>/sys</command><indexterm><primary>/sys</primary></indexterm> directory is created for the Linux 2.6 kernel. Since 2.6, Linux uses <command>sysfs</command><indexterm><primary>sysfs</primary></indexterm> to support <command>usb</command><indexterm><primary>usb</primary></indexterm> and <command>IEEE 1394</command><indexterm><primary>IEEE 1394</primary></indexterm> (aka <command>FireWire</command><indexterm><primary>FireWire</primary></indexterm>) hot plug devices. See the manual pages of udev(8) (the successor of <command>devfs</command><indexterm><primary>devfs</primary></indexterm>) and hotplug(8) for more info (Or visit http://linux-hotplug.sourceforge.net/ ).</para>
		<screen>
paul@RHELv4u4:~$ ls /sys/*
/sys/block:
dm-0 fd0 hdb md0  ram1  ram11 ram13 ram15 ram3 ram5 ram7 ram9   
dm-1 hda hdc ram0 ram10 ram12 ram14 ram2  ram4 ram6 ram8 sda  

/sys/bus:
i2c  ide  pci  platform  pnp  scsi  serio  usb

/sys/class:
firmware i2c-adapter input misc netlink printer scsi_device tty  
graphics i2c-dev     mem   net  pci_bus raw     scsi_host   usb 

/sys/devices:
pci0000:00  platform  system

/sys/firmware:
acpi

/sys/module:
ac       dm_mirror    ext3      ip_conntrack    ipt_state  md5      
autofs4  dm_mod       floppy    iptable_filter  ipv6       mii        
battery  dm_snapshot  i2c_core  ip_tables       jbd        mptbase   
button   dm_zero      i2c_dev   ipt_REJECT      lp         mptfc      

/sys/power:
state
paul@RHELv4u4:~$
		</screen>
		</section>
		<section><title>/tmp for temporary files</title>
			<para>When applications (or Users) need to store temporary data, they should use <command>/tmp</command><indexterm><primary>/tmp</primary></indexterm>. /tmp might take up diskspace, then again, it might also not (as in being mounted inside RAM memory). In any case, files in /tmp can be cleared by the operating system. Never use /tmp to store data that you want to archive.</para>
		</section>
		<section><title>/usr Unix System Resources</title>
			<para>Although <command>/usr</command><indexterm><primary>/usr</primary></indexterm> is pronounced like user, never forget that it stands for Unix System Resources. The /usr hierarchy should contain <command>sharable, read only</command> data. Some people even choose to mount /usr as read only. This can be done from its own partition, or from a read only NFS share.</para>
		</section>
		<section><title>/var variable data</title>
			<para>Data that is unpredictable in size, such as log files (<command>/var/log</command><indexterm><primary>/var/log</primary></indexterm>), print spool directories (<command>/var/spool</command><indexterm><primary>/var/spool</primary></indexterm>) and various caches (<command>/var/cache</command><indexterm><primary>/var/cache</primary></indexterm>) should be located in <command>/var</command><indexterm><primary>/var</primary></indexterm>. But /var is much more than that, it contains Process ID files in <command>/var/run</command><indexterm><primary>/var/run</primary></indexterm> and temporary files that survive a reboot in <command>/var/tmp</command><indexterm><primary>/var/tmp</primary></indexterm>. There will be more examples of /var usage further in this book.</para>
			<section><title>/var/lib/rpm</title>
				<para>Red Hat Enterprise Linux keeps files pertaining to <command>RPM</command><indexterm><primary>RPM</primary></indexterm> in <command>/var/lib/rpm/</command><indexterm><primary>/var/lib/rpm</primary></indexterm>.</para>
			</section>
			<section><title>/var/spool/up2date</title>
				<para>The <command>Red Hat Update Agent</command><indexterm><primary>Red Hat Update Agent</primary></indexterm> uses files in <command>/var/spool/up2date</command><indexterm><primary>/var/spool/up2date</primary></indexterm>. This location is also used when files are downloaded from the <command>Red Hat Network</command><indexterm><primary>Red Hat Network</primary></indexterm>.</para>
			</section>
		</section>
	</section>
	<section><title>Working with directories</title>
		<para>It is one thing to know the structure of the Unix filetree, it is another to walk around in it. To explore the filesystem, you will need some tools. Here's a small overview of the most common commands, available on any Unix or Linux system. </para>
		<section><title>pwd</title>
			<para>The <command>you are here</command> sign can be displayed with the <command>pwd</command><indexterm><primary>pwd</primary></indexterm> command (Print Working Directory). Go ahead, try it: open a commandline interface (like gnome-terminal or an xterm) and type <command>pwd</command>. The tool displays your <command>current directory</command><indexterm><primary>current directory</primary></indexterm>.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
			</screen>
		</section>
		<section><title>cd</title>
			<para>You can change your current directory with the <command>cd</command><indexterm><primary>cd</primary></indexterm> command (Change Directory). </para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd /bin
paul@laika$ pwd
/bin
paul@laika$ cd /boot/grub
paul@laika$ pwd
/boot/grub
paul@laika$ cd /home/paul/
paul@laika$ pwd
/home/paul
			</screen>
			<para>You can pull off a trick with cd. Just typing <command>cd</command> without a target directory, will put you in your home directory. Typing <command>cd ~</command><indexterm><primary>cd ~</primary></indexterm> has the same effect.</para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd
paul@laika$ pwd
/home/paul
paul@laika$ cd ~
paul@laika$ pwd
/home/paul
			</screen>
			<para>To go to the <command>parent directory</command><indexterm><primary>parent directory</primary></indexterm> (the one just above your current directory in the directory tree), type <command>cd ..</command><indexterm><primary>cd ..</primary></indexterm> . <emphasis>To stay in the current directory, type <command>cd .</command> ;-)</emphasis></para>
			<screen>
paul@laika:/usr/share/games/wesnoth$ pwd
/usr/share/games/wesnoth
paul@laika:/usr/share/games/wesnoth$ cd ..
paul@laika:/usr/share/games$ pwd
/usr/share/games
paul@laika:/usr/share/games$ cd ..
paul@laika:/usr/share$ cd ..
paul@laika:/usr$ cd ..
paul@laika:/$ pwd
/
paul@laika:/$ 
			</screen>
			<para>Another useful shortcut with cd is to just type <command>cd -</command><indexterm><primary>cd -</primary></indexterm> to go to the previous directory.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
paul@laika:~$ cd /etc
paul@laika:/etc$ pwd
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ cd -
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ 			</screen>
			<para>You should be aware of <command>absolute and relative paths</command><indexterm><primary>absolute and relative paths</primary></indexterm> in the filetree. When you type a path starting with a slash, then the root of the filetree is assumed. If you don't start your path with a slash, then the current directory is the assumed starting point. The screenshot below first shows the current directory (/home/paul). From within this directory, you have to type <command>cd /home</command> instead of <command>cd home</command> to go to the /home directory. When inside /home, you have to type <command>cd paul</command> instead of <command>cd /paul</command> to enter the subdirectory paul of the current directory /home.</para>
			<screen>
paul@laika$ pwd
/home/paul
paul@laika$ cd home
bash: cd: home: No such file or directory
paul@laika$ cd /home
paul@laika$ pwd
/home
paul@laika$ cd /paul
bash: cd: /paul: No such file or directory
paul@laika$ cd paul
paul@laika$ pwd
/home/paul
paul@laika$ 
			</screen>
			<para>In case your current directory is the root directory, then both <command>cd /home</command> and <command>cd home</command> will get you in the /home directory.</para>
			<screen>
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd home
paul@laika$ pwd
/home
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd /home 
paul@laika$ pwd
/home
			</screen>
			<para>This was the last screenshot with pwd statements. From now on, the current directory will always be displayed in the prompt. We will explain later in this book, how the shell variable $PS1 can be configured to do this.</para>
		</section>

		<section><title>ls</title>
			<para>You can list the contents of a directory with <command>ls</command><indexterm><primary>ls</primary></indexterm>. Many times you will be using options with ls to display the contents of the directory in different formats, or to display different parts of the directory. Just typing ls gives you a list of files in the directory.Typing <command>ls -l</command><indexterm><primary>ls -l</primary></indexterm> (that is a letter L, not the number 1) gives you a long listing (more information on the contents).</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -l
total 23992
-rw-r--r-- 1 paul paul 24506857 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul    14744 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul     8189 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul     4096 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul        0 2006-03-30 22:45 summer.txt
			</screen>
			<para>A frequently used option with ls is <command>-a</command> to show all files. All files means including the <command>hidden files</command><indexterm><primary>hidden files</primary></indexterm>. When a filename on a Unix file system starts with a dot, it is considered a hidden file, and it doesn't show up in regular file listings.</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -a
.   allfiles.txt   .bash_profile  dmesg.txt   .lesshst  stuff       
..  .bash_history  .bashrc        httpd.conf  .ssh      summer.txt 
paul@pasha:~$ 
			</screen>
			<para>Another frequently used ls option is <command>-h</command>. It shows the numbers (file sizes) in a more human readable format. Also shown below is some variation in the way you can give the options to ls. We will explain the details of the output later in this book!</para>
			<screen>
paul@pasha:~$ ls -l -h
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -lh
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -hl
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -h -l
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
			</screen>
		</section>
		<section><title>mkdir</title>
			<para>Walking around the Unix filetree is fun, but it is even more fun to create your own directories with <command>mkdir</command><indexterm><primary>mkdir</primary></indexterm>. You have to give at least one parameter to <command>mkdir</command>, the name of the new directory to be created. Think before you type a leading / . </para>
			<screen>
paul@laika:~$ mkdir MyDir
paul@laika:~$ cd MyDir
paul@laika:~/MyDir$ ls -al
total 8
drwxr-xr-x  2 paul paul 4096 2007-01-10 21:13 .
drwxr-xr-x 39 paul paul 4096 2007-01-10 21:13 ..
paul@laika:~/MyDir$ mkdir stuff
paul@laika:~/MyDir$ mkdir otherstuff
paul@laika:~/MyDir$ ls -l
total 8
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 otherstuff
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 stuff
paul@laika:~/MyDir$ 
			</screen>
			<para>When given the option <command>-p</command><indexterm><primary>mkdir -p</primary></indexterm>, then mkdir will create parent directories as needed.</para>
			<screen>
paul@laika:~$ mkdir -p MyDir2/MySubdir2/ThreeDeep
paul@laika:~$ ls MyDir2
MySubdir2
paul@laika:~$ ls MyDir2/MySubdir2
ThreeDeep
paul@laika:~$ ls MyDir2/MySubdir2/ThreeDeep/
			</screen>
		</section>
		<section><title>rmdir</title>
			<para>When a directory is empty, you can use <command>rmdir</command><indexterm><primary>rmdir</primary></indexterm> to remove the directory.</para>
			<screen>
paul@laika:~/MyDir$ rmdir otherstuff
paul@laika:~/MyDir$ ls
stuff
paul@laika:~/MyDir$ cd ..
paul@laika:~$ rmdir MyDir
rmdir: MyDir/: Directory not empty
paul@laika:~$ rmdir MyDir/stuff
paul@laika:~$ rmdir MyDir
			</screen>
			<para>And similar to the mkdir -p option, you can also use rmdir to recursively remove directories.</para>
			<screen>
paul@laika:~$ mkdir -p dir/subdir/subdir2
paul@laika:~$ rmdir -p dir/subdir/subdir2
paul@laika:~$ 	
			</screen>
		</section>
		<section><title>pushd and popd</title>
			<para><emphasis>These two commands are not essential, if you think there are too many commands to remember, then you are allowed to forget about these two.</emphasis></para>
			<para>Some administrators find it useful to work with <command>pushd</command><indexterm><primary>pushd</primary></indexterm> and <command>popd</command><indexterm><primary>popd</primary></indexterm>. Both commands work with a common stack of previous directories. Pushd adds a directory to the stack and changes to a new current directory, popd removes a directory from the stack and sets the current directory.</para>
			<screen>
paul@laika:/etc$ cd /bin
paul@laika:/bin$ pushd /lib
/lib /bin
paul@laika:/lib$ pushd /proc
/proc /lib /bin
paul@laika:/proc$ 
paul@laika:/proc$ popd 
/lib /bin
paul@laika:/lib$ 
paul@laika:/lib$ 
paul@laika:/lib$ popd
/bin
paul@laika:/bin$ 
			</screen>
		</section>
		<section><title>Practice: Working with directories</title>
			<para>1. Display your current directory.</para>
			<para>2. Change to the /etc directory.</para>
			<para>3. Now change to your home directory using only three key presses.</para>
			<para>4. Change to the /boot/grub directory using only eleven key presses.</para>
			<para>5. Go to the parent directory of the current directory.</para>
			<para>6. Go to the root directory.</para>
			<para>7. List the contents of the root directory.</para>
			<para>8. List a long listing of the root directory.</para>
			<para>9. Stay where you are, and list the contents of /etc.</para>
			<para>10. Stay where you are, and list the contents of /bin and /sbin.</para>
			<para>11. Stay where you are, and list the contents of &#126;.</para>
			<para>12. List all the files (including hidden files) in your homedirectory.</para>
			<para>13. List the files in /boot in a human readable format.</para>
			<para>14. Create a directory testdir in your homedirectory.</para>
			<para>15. Change to the /etc directory, stay here and create a directory newdir in your homedirectory.</para>
			<para>16. Create in one command the directories ~/dir1/dir2/dir3 (dir3 is a subdirectory from dir2, and dir2 is a subdirectory from dir1 ).</para>
			<para>17. Remove the directory testdir.</para>
			<para>18. If time permits (or if you are waiting for other students to finish this practice), use and understand pushd and popd. Use the man page of bash to find information about pushd, popd and dirs.</para>
			<para></para>
			<para></para>	
		</section>
	</section>
	<section><title>Working with files</title>
		<section><title>file</title>
			<para>The <command>file</command><indexterm><primary>file(1)</primary></indexterm> utility determines the file type. Unlike some other desktop operating system, Unix does not use extensions to determine the file type. Your editor does not care whether a file ends in .TXT or .DOC. As a system administrator, you should use the <command>file</command> command to determine the file type. First some examples on a typical Linux system.</para>
			<screen>
paul@laika:~$ file Desktop/Screenshot.png 
Desktop/Screenshot.png: PNG image data, 3840 x 1200, 8-bit/color RGBA, \
non-interlaced
paul@laika:~$ file /bin/cat
/bin/cat: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for \
GNU/Linux2.6.0, dynamically linked (uses shared libs), for GNU/Linux 2.\
6.0, stripped
paul@laika:~$ file /etc/passwd
/etc/passwd: ASCII text
paul@laika:~$ file HelloWorld.c 
HelloWorld.c: ASCII C program text
			</screen>
			<para>Here's another example of the file utility. It shows the different type of binaries on different architectures.</para>
			<screen>
# Solaris 9 on Intel
bash-2.05$ file /bin/date
/bin/date:      ELF 32-bit LSB executable 80386 Version 1, dynamically \
linked, stripped

# Ubuntu Linux on AMD64
paul@laika:~$ file /bin/date 
/bin/date: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for\
 GNU/Linux 2.6.0, dynamically linked (uses shared libs), for GNU/Linux \
2.6.0, stripped

# Debian Sarge on SPARC
paul@pasha:~$ file /bin/date 
/bin/date: ELF 32-bit MSB executable, SPARC, version 1 (SYSV), for GNU/\
Linux 2.4.1, dynamically linked (uses shared libs), for GNU/Linux 2.4.1\
, stripped
			</screen>
		</section>
		<section><title>touch</title>
			<para>One easy way to create a file is with <command>touch</command><indexterm><primary>touch</primary></indexterm>. (We will see many other creative avenues for spawning files later in this book.)</para>
			<screen>
paul@laika:~/test$ touch file1
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
paul@laika:~/test$ touch file2
paul@laika:~/test$ touch file555
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file2
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file555
			</screen>
			<para>Of course, touch can do more than just create files. Can you find out what by looking at the next screenshot ? If not, check the manual of touch.</para>
			<screen>
paul@laika:~/test$ touch -t 200505050000 SinkoDeMayo
paul@laika:~/test$ touch -t 130207111630 BigBattle
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 1302-07-11 16:30 BigBattle
-rw-r--r-- 1 paul paul 0 2005-05-05 00:00 SinkoDeMayo
			</screen>
		</section>
		<section><title>rm</title>
			<para>When you no longer need a file, use <command>rm</command><indexterm><primary>rm</primary></indexterm> to remove it. Unlike some graphical user interfaces, the command line in general does not have a <emphasis>waste bin</emphasis> or <emphasis>trashcan</emphasis> to recover files. When you use rm to remove a file, the file is gone. So be careful before removing files! </para>
			<screen>
paul@laika:~/test$ ls
BigBattle  SinkoDeMayo
paul@laika:~/test$ rm BigBattle 
paul@laika:~/test$ ls
SinkoDeMayo
			</screen>
			<para>By default, rm will not remove non-empty directories. However rm accepts several options that will allow you to remove any directory. The <command>rm -rf</command><indexterm><primary>rm -rf</primary></indexterm> statement is famous because it will erase anything (providing that you have the permissions to do so). When you are logged on as root, be very careful with <command>rm -rf</command>, because being root implies that permissions don't apply to you, so you can literally erase your entire system by accident.</para>
			<screen>
paul@laika:~$ ls test
SinkoDeMayo
paul@laika:~$ rm test
rm: cannot remove `test': Is a directory
paul@laika:~$ rm -rf test
paul@laika:~$ ls test
ls: test: No such file or directory
			</screen>
		</section>
		<section><title>cp</title>
			<para>To copy a file, use <command>cp</command><indexterm><primary>cp</primary></indexterm> with a source and a target argument. If the target is a directory, then the sourcefiles are copied in that target directory.</para>
			<screen>
paul@laika:~/test$ touch FileA
paul@laika:~/test$ ls
FileA
paul@laika:~/test$ cp FileA FileB
paul@laika:~/test$ ls
FileA  FileB
paul@laika:~/test$ mkdir MyDir
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ cp FileA MyDir/
paul@laika:~/test$ ls MyDir/
FileA
			</screen>
			<para>To copy complete directories, use <command>cp -r</command><indexterm><primary>cp -r</primary></indexterm>.</para>
			<screen>
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ ls MyDir/
FileA
paul@laika:~/test$ cp -r MyDir MyDirB
paul@laika:~/test$ ls
FileA  FileB  MyDir  MyDirB
paul@laika:~/test$ ls MyDirB
FileA
			</screen>
			<para>You can also use cp to copy multiple file into a directory. In that case, the last argument (aka the target) must be a directory.</para>
			<screen>
paul@laika:~/test$ cp fire water
paul@laika:~/test$ cp -i fire water
cp: overwrite `water'? no
paul@laika:~/test$
			</screen>
			<screen>cp file1 file2 dir1/file3 dir1/file55 dir2</screen>
			<para>To prevent cp from overwriting existing files, use the -i (for interacgtive) option.</para>
		</section>
		<section><title>mv</title>
			<para>Use <command>mv</command><indexterm><primary>mv</primary></indexterm> to rename a file, or to move the file to another directory.</para>
			<screen>
paul@laika:~/test$ touch file100
paul@laika:~/test$ ls
file100
paul@laika:~/test$ mv file100 ABC.txt
paul@laika:~/test$ ls
ABC.txt
paul@laika:~/test$
			</screen>
			<para>The <command>rename</command><indexterm><primary>rename</primary></indexterm> command can also be used, but it has a more complex syntax to enable renaming of many files at once. Below two examples, the first switches all occurrences of txt in png for all filenames ending in .txt. The second example switches all occurrences of uppercase ABC in lowercase abc for all filenames ending in .png . The following syntax will work on debian and ubuntu.</para>
			<screen>
paul@laika:~/test$ ls
123.txt  ABC.txt
paul@laika:~/test$ rename 's/txt/png/' *.txt
paul@laika:~/test$ ls
123.png  ABC.png
paul@laika:~/test$ rename 's/ABC/abc/' *.png
paul@laika:~/test$ ls
123.png  abc.png
paul@laika:~/test$ 
			</screen>
			<para>On Red Hat Enterprise Linux, the syntax of rename is a bit different. The first example below renames all *.conf files, replace any occurrence of conf with bak. The second example renames all(*) files, replacing one with ONE.</para>
			<screen>
[paul@RHEL4a test]$ ls
one.conf  two.conf
[paul@RHEL4a test]$ rename conf bak *.conf
[paul@RHEL4a test]$ ls
one.bak  two.bak
[paul@RHEL4a test]$ rename one ONE *
[paul@RHEL4a test]$ ls
ONE.bak  two.bak
[paul@RHEL4a test]$ 
			</screen>
		</section>
		<section><title>Practice: Working with files</title>
			<para>1. List the files in the /bin directory</para>
			<para>2. Display the type of file of /bin/cat, /etc/passwd and /usr/bin/passwd.</para>
			<para>3a. Download wolf.jpg from http://cobbaut.be (wget http://cobbaut.be/wolf.jpg)</para>
			<para>3b. Display the type of file of wolf.jpg</para>
			<para>3c. Rename the file to wolf.pdf</para>
			<para>3d. Display the type of file of wolf.pdf</para>
			<para>4. Create a directory &#126;/touched and enter it.</para>
			<para>5. Create the files today.txt and yesterday.txt in touched.</para>
			<para>6. Change the date on yesterday.txt to match yesterday's date.</para>
			<para>7. Copy yesterday.txt to copy.yesterday.txt</para>
			<para>8. Rename copy.yesterday.txt to kim</para>
			<para>9. Create a directory called &#126;/testbackup and copy all files from &#126;/touched in it.</para>
			<para>10. Use one command to remove the directory &#126;/testbackup and all files in it.</para>
			<para>11. Create a directory &#126;/etcbackup and copy all *.conf files from /etc in it. Did you include all subdirectories of /etc ?</para>
			<para>12. Use rename to rename all *.BAK files to *.BACKUP. (if you have a debian and red hat derived distro available, try it on both!)</para>
			<para></para>
			<para></para>
		</section>
	</section>
	<section><title>File contents</title>
		<section><title>head</title>
			<para>You can use <command>head</command><indexterm><primary>head(1)</primary></indexterm> to display the first ten lines of a file.</para>
			<screen>
paul@laika:~$ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
paul@laika:~$ 
			</screen>
			<para>The head command has some options for displaying the first n lines of a file.</para>
			<screen>
paul@laika:~$ head -4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
			</screen>
			<para>Head can also display the first n bytes.</para>
			<screen>
paul@laika:~$ head -c4 /etc/passwd
rootpaul@laika:~$
			</screen>		
		</section>
		<section><title>tail</title>
			<para>Similar to head, the <command>tail</command><indexterm><primary>tail(1)</primary></indexterm> command will display the last ten lines of a file.</para>
			<screen>
paul@laika:~$ tail /etc/services 
vboxd           20012/udp
binkp           24554/tcp             # binkp fidonet protocol
asp             27374/tcp             # Address Search Protocol
asp             27374/udp
csync2          30865/tcp             # cluster synchronization tool
dircproxy       57000/tcp             # Detachable IRC Proxy
tfido           60177/tcp             # fidonet EMSI over telnet
fido            60179/tcp             # fidonet EMSI over TCP

# Local services
paul@laika:~$
			</screen>
			<para>The tail command has many options, we will use some of them during this course.</para>
		</section>
		<section><title>cat</title>
			<para>The <command>cat</command><indexterm><primary>cat(1)</primary></indexterm> command is one of the most universal tools. All it does is copying standard input to standard output, but in combination with the shell, this can be very powerful and diverse. Some examples will give a glimpse of the possibilities. The first example is simple, you can use cat to display a file on the screen. If the file is longer than the screen, it will scroll by until the end.</para>
			<screen>
paul@laika:~$ cat /etc/resolv.conf
nameserver 194.7.1.4
paul@laika:~$
			</screen>
			<para>You can use cat to create files with one or more lines of text. Just type the command as is shown in the screenshot below. Then type one or more lines, finish each line with the enter key. After the last line, type and hold the Control (Ctrl) key and press d. The <command>Ctrl d</command><indexterm><primary>Ctrl D</primary></indexterm> key combination will send an EOF (End of File) to the running process, this will end the cat command.</para>
			<screen>
paul@laika:~/test$ cat > winter.txt
It is very cold today!
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$
			</screen>
			<para>You can actually choose this end marker for cat with <command>&#060;&#060;</command> as is shown in this screenshot.</para>
			<screen>
paul@laika:~/test$ cat &#062; hot.txt &#060;&#060;stop
&#062; It is hot today!
&#062; Yes it is summer.
&#062; stop
paul@laika:~/test$ cat hot.txt 
It is hot today!
Yes it is summer.
paul@laika:~/test$ 
			</screen>
			<para>In the third example you will see that cat can be used to copy files. We will explain in detail what happens here in the bash shell chapter.</para>
			<screen>
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$ cat winter.txt > cold.txt
paul@laika:~/test$ cat cold.txt 
It is very cold today!
paul@laika:~/test$
			</screen>		
		</section>
		<section><title>tac</title>
			<para>Just one example will show you the purpose of <command>tac</command><indexterm><primary>tac(1)</primary></indexterm> (as the opposite of cat).</para>
			<screen>
paul@laika:~/test$ cat count 
one
two
three
four
paul@laika:~/test$ tac count 
four
three
two
one
paul@laika:~/test$
			</screen>
		</section>
		<section><title>more and less</title>
			<para>The <command>more</command><indexterm><primary>more(1)</primary></indexterm> command is useful for displaying files that take up more than one screen. More will allow you to see the contents of the file page by page. You can use the spacebar to see the next page, or q to quit more. Some people prefere the <command>less</command><indexterm><primary>less(1)</primary></indexterm> command instead of more.</para>
		</section>
		<section><title>strings</title>
			<para>With the <command>strings</command><indexterm><primary>strings(1)</primary></indexterm> command you can display readable ascii strings found in (binary) files. This example locates the ls binary, and then displays readable strings in the binary file (output is truncated).</para>
			<screen>
paul@laika:~$ which ls
/bin/ls
paul@laika:~$ strings /bin/ls
/lib/ld-linux.so.2
librt.so.1
__gmon_start__
_Jv_RegisterClasses
clock_gettime
libacl.so.1
...
			</screen>
		</section>
		<section><title>split</title>
			<para>The <command>split</command><indexterm><primary>split(1)</primary></indexterm> command is useful to split files into smaller file. This can be useful to fit the file onto multiple instances of a medium too small to contain the complete file. In the example below, a file of size 5000 bytes is split into three smaller files, with maximum 2000 bytes each.</para>
			<screen>
paul@laika:~/test$ ls -l
total 8
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
paul@laika:~/test$ split -b 2000 bigfile1 splitfile.
paul@laika:~/test$ ls -l
total 20
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
			</screen>
			<para>In a similar example below the file is split into max 800 bytes parts.</para>
			<screen>
paul@laika:~/test$ split -b 800 bigfile1 size800.
paul@laika:~/test$ ls -l
total 48
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.aa
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ab
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ac
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ad
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ae
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.af
-rw-r--r-- 1 paul paul  200 2007-09-09 20:48 size800.ag
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
paul@laika:~/test$ 
			</screen>
		</section>
		<section><title>Practice: File contents</title>
			<para>1. Display the first 12 lines of /etc/X11/xorg.conf.</para>
			<para>2. Display the last line of /etc/passwd.</para>
			<para>3. Use cat to create a file named count.txt that looks like this:</para>
			<screen>
One
Two
Three
Four
Five
			</screen>
			<para>4. Use cp to make a backup of this file to cnt.txt.</para>
			<para>5. Use cat to make a backup of this file to catcnt.txt</para>
			<para>6. Display catcnt.txt, but with all lines in reverse order (the last line first).</para>
			<para>7. Use more to display /var/log/messages.</para>
			<para>8. Display the readable character strings from the passwd command.</para>
			<para>9. Use ls to find the biggest file in /etc. Make a testsplit directory in your home directory. Copy this biggest file to your ~/testsplit and name it biggest. Then split this file in smaller 200 bytes parts.</para>	
		</section>
		<section><title>Solution</title>
			<para>9. ls -lrS /etc</para>
			<para>mkdir ~/testsplit</para>
			<para>cp /etc/bash_completion ~/testsplit/biggest</para>
			<para>split -b 200 biggest parts</para>
		</section>
	</section>
