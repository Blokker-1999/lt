<section><title>shell arguments</title>
	<section><title>white space removal</title>
		<para>Before execution, the shell scans at the command line. Parts that are separated by one or more consecutive <command>white spaces</command> (or tabs) are considered separate <command>arguments</command>, any white space is removed. The first <command>argument</command> is the command to be executed, the other <command>arguments</command> are given to the command. The shell effectively cuts your command into one or more arguments.</para>
		<para>This explains why the following four different command lines are the same after <command>shell expansion</command><indexterm><primary>shell expansion</primary></indexterm>.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
		</screen>
		<para>The <command>echo</command> command will display each argument it receives from the shell. The <command>echo</command> command will also add a new whitespace between the arguments it received.</para>
		<para>It is important for troubleshooting any script to know that the shell cuts your command line in distinct arguments.</para>
	</section>
	<section><title>single quotes</title>
		<para>You can prevent the removal of white spaces by quoting the spaces. The contents of the quoted string are considered as one argument. In the screenshot below the <command>echo</command> receives only one <command>argument</command>.</para>
		<screen>
[paul@RHEL4b ~]$ echo 'A line with      single    quotes'
A line with      single    quotes
[paul@RHEL4b ~]$
		</screen>
	</section>
	<section><title>double quotes</title>
		<para>You can also prevent the removal of white spaces by double quoting the spaces. Same as above, <command>echo</command> only receives one <command>argument</command>.</para>
		<screen>
[paul@RHEL4b ~]$ echo "A line with      double    quotes"
A line with      double    quotes
[paul@RHEL4b ~]$
		</screen>
		<para>The only difference between single and double quotes is the parsing of shell <command>variables</command>. You can already see the difference in this screenshot.</para>
		<screen>
paul@laika:~$ echo 'My user is $USER'
My user is $USER
paul@laika:~$ echo "My user is $USER"
My user is paul
		</screen>
	</section>
	<section><title>echo and quotes</title>
		<para>Quoted lines can include special escaped characters recognized by the <command>echo</command> command (when using <command>echo -e</command><indexterm><primary>echo(1)</primary></indexterm>). The screenshot below shows how to use <command>\n</command> for a newline and <command>\t</command> for a tab (usually eight white spaces).</para>
		<screen>
[paul@RHEL4b ~]$ echo -e "A line with \na newline"
A line with 
a newline
[paul@RHEL4b ~]$ echo -e 'A line with \na newline'
A line with 
a newline
[paul@RHEL4b ~]$ echo -e "A line with \ta tab"
A line with     a tab
[paul@RHEL4b ~]$ echo -e 'A line with \ta tab'
A line with     a tab
[paul@RHEL4b ~]$ 
		</screen>
		<para>The echo command can generate more than white spaces, tabs and newlines. Look in the man page for a list of options (and remember that echo may be both built-in and external).</para>
	</section>
	<section><title>shell embedding</title>
		<para>Shells can be embedded on the command line, or in other words, the command line scan can spawn new processes containing a fork of the current shell. You can use variables to prove that new shells are created. In the screenshot below, the variable $var1 only exists in the (temporary) sub shell.</para>
		<screen>
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ echo $(var1=5;echo $var1)
5
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ 
		</screen>
		<para>You can embed a shell in an <command>embedded shell</command><indexterm><primary>embedding(shell)</primary></indexterm>, this is called <command>nested embedding</command> of shells.</para>
		<para>This screenshot shows an embedded shell inside an embedded shell.</para>
		<screen>
paul@deb503:~$ A=shell
paul@deb503:~$ echo $C$B$A $(B=sub;echo $C$B$A; echo $(A=sub;echo $C$B$A))
shell subshell subsub
		</screen>
	</section>
	<section><title>back ticks</title>
		<para>Single embedding can be useful to avoid changing your current directory. The screenshot below uses <command>back ticks</command> instead of dollar-bracket to embed.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo `cd /etc; ls -d * | grep pass`
passwd passwd- passwd.OLD
[paul@RHELv4u3 ~]$ 
		</screen>
	</section>
	<section><title>back ticks or single quotes</title>
		<para>Placing the embedding between <command>backticks</command><indexterm><primary>backticks</primary></indexterm> uses one character less than the dollar and parenthesis combo. Be careful however, backticks are often confused with single quotes. The technical difference between <command>'</command><indexterm><primary>'(single quote)</primary></indexterm> and <command>`</command><indexterm><primary>`(backtick)</primary></indexterm> is significant! You can not use <command>backticks</command> to nest embedded shells.</para>
		<screen>
[paul@RHELv4u3 gen]$ echo `var1=5;echo $var1`
5
[paul@RHELv4u3 gen]$ echo 'var1=5;echo $var1'
var1=5;echo $var1
[paul@RHELv4u3 gen]$
		</screen>
	</section>
</section>
