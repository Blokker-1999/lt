<section><title>shell expansion</title>
	<section><title>white space squeezing</title>
		<para>Multiple consecutive <command>white spaces</command> on the command line will be reduced to one white space. That is why the following four different command lines are the same after <command>shell expansion</command><indexterm><primary>shell expansion</primary></indexterm>.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
[paul@RHELv4u3 ~]$ 
		</screen>
	</section>
	<section><title>single and double quotes</title>
		<para>You can prevent the squeezing of white spaces to a single white space character by quoting the spaces.</para>
		<screen>
[paul@RHEL4b ~]$ echo "A line with      double    quotes"
A line with      double    quotes
[paul@RHEL4b ~]$ echo 'A line with      single    quotes'
A line with      single    quotes
[paul@RHEL4b ~]$
		</screen>
	</section>
	<section><title>echo and quotes</title>
		<para>Quoted lines can include special escaped characters recognized by the <command>echo</command> command (when using <command>echo -e</command><indexterm><primary>echo(1)</primary></indexterm>). The screenshot below shows how to use escaped n for a newline and escaped t for a tab (usually eight white spaces).</para>
		<screen>
[paul@RHEL4b ~]$ echo -e "A line with \na newline"
A line with 
a newline
[paul@RHEL4b ~]$ echo -e 'A line with \na newline'
A line with 
a newline
[paul@RHEL4b ~]$ echo -e "A line with \ta tab"
A line with     a tab
[paul@RHEL4b ~]$ echo -e 'A line with \ta tab'
A line with     a tab
[paul@RHEL4b ~]$ 
		</screen>
		<para>The echo command can generate more than white spaces, tabs and newlines ; check the man page. More information about quoting and escaping later in this chapter.</para>
	</section>
	<section><title>file globbing</title>
		<section><title>* asterisk</title>
			<para>The shell is also responsible for <command>file globbing</command><indexterm><primary>file globbing</primary></indexterm> (or dynamic filename generation). The asterisk <command>*</command><indexterm><primary>* (file globbing)</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching the asterisk to any combination of characters (even none). When no path is given, the shell will use filenames in the current directory. See the man page of <command>glob(7)</command><indexterm><primary>glob(7)</primary></indexterm> for more information. (This is part of LPI topic 1.103.3.)</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File*
File4  File55  FileA  Fileab  FileAB
[paul@RHELv4u3 gen]$ ls file*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls *ile55
File55
[paul@RHELv4u3 gen]$ ls F*ile55
File55
[paul@RHELv4u3 gen]$ ls F*55
File55
[paul@RHELv4u3 gen]$ 
			</screen>
		</section>
		<section><title>? question mark</title>
			<para>Similar to the asterisk, the question mark <command>?</command><indexterm><primary>? (file globbing)</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching the question mark with exactly one character.</para>
		<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File?
File4  FileA
[paul@RHELv4u3 gen]$ ls Fil?4
File4
[paul@RHELv4u3 gen]$ ls Fil??
File4  FileA
[paul@RHELv4u3 gen]$ ls File??
File55  Fileab  FileAB
[paul@RHELv4u3 gen]$
			</screen>
		</section>
		<section><title>[] square brackets</title>
			<para>The square bracket <command>[</command><indexterm><primary>[</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching any of the characters between <command>[</command> and the first subsequent <command>]</command>. The order in this list between the brackets is not important. Each pair of brackets is replaced by exactly one character.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File[5A]
FileA
[paul@RHELv4u3 gen]$ ls File[A5]
FileA
[paul@RHELv4u3 gen]$ ls File[A5][5b]
File55
[paul@RHELv4u3 gen]$ ls File[a5][5b]
File55  Fileab
[paul@RHELv4u3 gen]$ ls File[a5][5b][abcdefghijklm]
ls: File[a5][5b][abcdefghijklm]: No such file or directory
[paul@RHELv4u3 gen]$ ls file[a5][5b][abcdefghijklm]
fileabc
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can also exclude characters from a list between square brackets with the exclamation mark <command>!</command><indexterm><primary>!</primary></indexterm>. And you are allowed to make combinations of these <command>wild cards</command><indexterm><primary>wild cards</primary></indexterm>.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls file[a5][!Z]
fileab
[paul@RHELv4u3 gen]$ ls file[!5]*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls file[!5]?
fileab
[paul@RHELv4u3 gen]$ 
			</screen>
		</section>
		<section><title>a-z and 0-9 ranges</title>
			<para>The bash shell will also understand ranges of characters between brackets.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ ls file[a-z]*
fileab  fileab2  fileabc
[paul@RHELv4u3 gen]$ ls file[0-9]
file1  file2  file3
[paul@RHELv4u3 gen]$ ls file[a-z][a-z][0-9]*
fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
		</section>
		<section><title>$LANG and square brackets</title>
			<para>But, don't forget the influence of the <command>LANG</command><indexterm><primary>$LANG</primary></indexterm> variable. Some languages include lowercase letters in an uppercase range (and vice versa).</para>
			<screen>
paul@RHELv4u4:~/test$ ls [A-Z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ echo $LANG
en_US.UTF-8
paul@RHELv4u4:~/test$ LANG=C
paul@RHELv4u4:~/test$ echo $LANG
C
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3
paul@RHELv4u4:~/test$ ls [A-Z]ile?
File4
paul@RHELv4u4:~/test$ 
			</screen>
		</section>
	</section>
	<section><title>shell embedding</title>
		<para>Shells can be embedded on the command line, or in other words the command line scan can spawn new processes, containing a fork of the current shell. You can use variables to prove that new shells are created. In the screenshot below, the variable $var1 only exists in the (temporary) sub shell.</para>
		<screen>
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ echo $(var1=5;echo $var1)
5
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ 
		</screen>
		<para>You can embed a shell in an <command>embedded shell</command><indexterm><primary>embedding(shell)</primary></indexterm>, this is called <command>nested embedding</command> of shells.</para>
		<screen>
$ P=Parent;
$ echo $P$C$G - $(C=Child;echo $P$C$G - ;echo $(G=Grand;echo $P$C$G))
Parent - ParentChild - ParentChildGrand
		</screen>
		<para>Single embedding can be useful to avoid changing your current directory. The screenshot below uses back ticks instead of dollar-bracket to embed.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo `cd /etc; ls -d * | grep pass`
passwd passwd- passwd.OLD
[paul@RHELv4u3 ~]$ 
		</screen>
		<para>Placing the embedding between <command>back ticks</command><indexterm><primary>back ticks</primary></indexterm> uses one character less than the dollar and parenthesis combo. Be careful however, back ticks are often confused with single quotes. The technical difference between <command>'</command><indexterm><primary>'(single quote)</primary></indexterm> and <command>`</command><indexterm><primary>`(back tick)</primary></indexterm> is significant! You can not use back ticks to nest embedded shells.</para>
		<screen>
[paul@RHELv4u3 gen]$ echo `var1=5;echo $var1`
5
[paul@RHELv4u3 gen]$ echo 'var1=5;echo $var1'
var1=5;echo $var1
[paul@RHELv4u3 gen]$
		</screen>
	</section>
	<section><title>shell alias</title>
		<para>The shell will allow you to create aliases. An <command>alias</command><indexterm><primary>alias(shell)</primary></indexterm> can be useful to abbreviate commands.</para>
		<screen>
paul@laika:~$ alias dir='ls -lh --color=auto'
paul@laika:~$ alias c='clear'
paul@laika:~$
		</screen>
		<para>You can give multiple aliases as arguments to the <command>alias</command> command to get a small list. Not providing any argument will give you a complete list of current aliases.</para>
		<screen>
paul@laika:~$ alias c ll
alias c='clear'
alias ll='ls -lh'
		</screen>
		<para>Aliases can also be used to create an easier to remember alias for an existing command.</para>
		<screen>
[paul@RHELv4u3 ~]$ cat count.txt 
one
two
three
[paul@RHELv4u3 ~]$ alias dog=tac
[paul@RHELv4u3 ~]$ dog count.txt 
three
two
one
		</screen>
		<para>Aliases can be used to supply some commands with default options.</para>
		<screen>
[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: remove regular file `winter.txt'? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: winter.txt: No such file or directory
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm: remove regular empty file `winter.txt'? no
[paul@RHELv4u3 ~]$ 
		</screen>
		<para>You can undo an alias with the <command>unalias</command><indexterm><primary>unalias(shell)</primary></indexterm> command.</para>
		<screen>
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$</screen>
	</section>
        <section><title>Displaying shell expansion</title>
                <para>You can display the shell expansion with <command>set -x</command><indexterm><primary>set -x</primary></indexterm>, and stop displaying it with <command>set +x</command><indexterm><primary>set +x</primary></indexterm>. You might want to use this further on in this course, or when in doubt about what exactly the shell is doing with your command.</para>
                <screen>
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo \$USER
$USER
[paul@RHELv4u3 ~]$
                </screen>
        </section>
</section>
