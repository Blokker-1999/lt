<chapter><title>Introduction to Bash</title>
<section><title>About Bash</title>
	<para>The command line interface used on most Linux systems is <command>bash</command><indexterm><primary>bash</primary></indexterm>, which stands for <command>Bourne again shell</command><indexterm><primary>Bourne again shell</primary></indexterm>. Bash incorporates features from <command>sh</command><indexterm><primary>sh</primary></indexterm> (the original Bourne shell), <command>csh</command><indexterm><primary>csh</primary></indexterm> (the C shell) and <command>ksh</command><indexterm><primary>ksh</primary></indexterm> (the Korn shell). The manual page of bash contains more than one hundred pages. Bash is important, because every command on your linux system is processed by bash after you type it, before it is executed.</para>
	<para>Not all commands are external to the shell, some are built-in. To find out whether a command given to the shell will be executed as an <command>external shell command</command> or as a <command>shell built-in command</command>, use the (external) <command>which</command><indexterm><primary>which(1)</primary></indexterm> command. In the screenshot below, it looks like cd is built-in, and ls cp rm mv mkdir pwd file and rename are external.</para> 
	<screen>
[root@RHEL4b ~]# which ls cp rm mv cd mkdir pwd file rename which
/bin/cp
/bin/ls
/bin/mv
/bin/rm
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:...
/bin/mkdir
/bin/pwd
/usr/bin/file
/usr/bin/rename
/usr/bin/which
[root@RHEL4b ~]# 	</screen>
</section>
	<section><title>Shell Expansion</title>
		<para>One of the primary features of a shell is to perform a <command>command line scan</command><indexterm><primary>command line scan</primary></indexterm>. When you enter a command on the shell's command prompt, and press the enter key, then the shell will start scanning that line. After the shell has finished scanning that line, the line will be executed. Shell expansion is influenced by the following topics (more will follow later) : control operators, white space removal, filename generation, variables, escaping, embedding and shell aliases.</para>
		<section><title>Control Operators</title>
			<para>You can put two or more commands on the same line, separated by a semicolon <command>;</command><indexterm><primary>;</primary></indexterm>. The scan will then go until each semicolon, and the lines will be executed sequentially, with the shell waiting for each command to end before starting the next one.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo Hello
Hello
[paul@RHELv4u3 ~]$ echo World
World
[paul@RHELv4u3 ~]$ echo Hello;echo World
Hello
World
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>When on the other hand you end a line with an ampersand <command>&#038;</command><indexterm><primary>&#038;</primary></indexterm>, then the shell will not wait for the command to finish. You will get your shell prompt back, and the command is executed in background. You will get a message when it has finished executing in background.</para>
			<screen>
[paul@RHELv4u3 ~]$ sleep 20 &#038;
[1] 7925
[paul@RHELv4u3 ~]$ 
[paul@RHELv4u3 ~]$ 
[paul@RHELv4u3 ~]$ 
[1]+  Done                     sleep 20
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can control execution of commands with <command>&#038;&#038;</command><indexterm><primary>&#038;&#038;</primary></indexterm> denoting a logical AND and <command>||</command><indexterm><primary>||</primary></indexterm> denoting a logical OR. With &#038;&#038; the second command is only executed when the first one succeeds (returns a zero exit status). </para>
			<screen>
paul@barry:~$ echo first &#038;&#038; echo second ; echo third
first
second
third
paul@barry:~$ zecho first &#038;&#038; echo second ; echo third
-bash: zecho: command not found
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>bash logical AND</command><indexterm><primary>bash logical AND</primary></indexterm> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen &#038;&#038; ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ cd gen &#038;&#038; ls
-bash: cd: gen: No such file or directory
[paul@RHELv4u3 gen]$
			</screen>		
			<para>The reverse is true for || . Meaning the second command is only executed when the first command fails (or in other words: returns a non-zero exit status).</para>
			<screen>
paul@barry:~$ echo first || echo second ; echo third
first
third
paul@barry:~$ zecho first || echo second ; echo third
-bash: zecho: command not found
second
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>bash logical OR</command><indexterm><primary>bash logical OR</primary></indexterm> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen || ls
[paul@RHELv4u3 gen]$ cd gen || ls
-bash: cd: gen: No such file or directory
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can use the logical AND and OR to echo whether a command worked or not.</para>
			<screen>
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
It worked!
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
rm: cannot remove `file1': No such file or directory
It failed!
paul@laika:~/test$
			</screen>
			<para>Lines ending in a backslash are continued on the next line. The shell will wait with executing the command line until a return without backslash is encountered.</para>
			<screen>
[paul@RHEL4b ~]$ echo This command line \
> is split in three \
> parts
This command line is split in three parts
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Comment</title>
			<para>Inserting <command>bash comments</command><indexterm><primary>bash comment</primary></indexterm> has no influence on the command. Comments start with a # (pound sign).</para>
			<screen>
paul@barry:~$ mkdir test    # we create a directory
paul@barry:~$ cd test       #### we enter the directory
paul@barry:~/test$ ls       # is it empty ?
paul@barry:~/test$
			</screen>
		</section>
		<section><title>White space squeezing</title>
			<para>Multiple consecutive <command>white spaces</command> on the command line will be reduced to one white space. That is why the following four different command lines are the same after <command>shell expansion</command><indexterm><primary>shell expansion</primary></indexterm>.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can prevent the squeezing of white spaces to a single white space character by quoting the spaces.</para>
			<screen>
[paul@RHEL4b ~]$ echo "A line with      double    quotes"
A line with      double    quotes
[paul@RHEL4b ~]$ echo 'A line with      single    quotes'
A line with      single    quotes
[paul@RHEL4b ~]$
			</screen>
			<para>Quoted lines can include special escaped charachters recognized by echo (when using <command>echo -e</command><indexterm><primary>echo -e</primary></indexterm>). The screenshot below shows how to use escaped n for a newline and escaped t for a tab (usually eight white spaces).</para>
			<screen>
[paul@RHEL4b ~]$ echo -e "A line with \na newline"
A line with 
a newline
[paul@RHEL4b ~]$ echo -e 'A line with \na newline'
A line with 
a newline
[paul@RHEL4b ~]$ echo -e "A line with \ta tab"
A line with     a tab
[paul@RHEL4b ~]$ echo -e 'A line with \ta tab'
A line with     a tab
[paul@RHEL4b ~]$ 
			</screen>
			<para>The echo command can generate more than white spaces, tabs and newlines ; check the man page. More information about quoting and escaping later in this chapter.</para>
		</section>
		<section><title>File globbing</title>
			<para>The shell is also responsible for <command>file globbing</command><indexterm><primary>file globbing</primary></indexterm> (or dynamic filename generation). The asterisk <command>*</command><indexterm><primary>*</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching the asterisk to any combination of characters (even none). When no path is given, the shell will use filenames in the current directory. See the man page of glob(7) for more information. (This is part of LPI topic 1.103.3.)</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File*
File4  File55  FileA  Fileab  FileAB
[paul@RHELv4u3 gen]$ ls file*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls *ile55
File55
[paul@RHELv4u3 gen]$ ls F*ile55
File55
[paul@RHELv4u3 gen]$ ls F*55
File55
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>Similar to the asterisk, the question mark <command>?</command><indexterm><primary>?</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching the question mark with exactly one character.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File?
File4  FileA
[paul@RHELv4u3 gen]$ ls Fil?4
File4
[paul@RHELv4u3 gen]$ ls Fil??
File4  FileA
[paul@RHELv4u3 gen]$ ls File??
File55  Fileab  FileAB
[paul@RHELv4u3 gen]$
			</screen>
			<para>The square bracket <command>[</command><indexterm><primary>[</primary></indexterm> is interpreted by the shell as a sign to generate filenames, matching any of the characters between <command>[</command> and the first subsequent <command>]</command>. The order in this list between the brackets is not important. Each pair of brackets is replaced by exactly one character.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File[5A]
FileA
[paul@RHELv4u3 gen]$ ls File[A5]
FileA
[paul@RHELv4u3 gen]$ ls File[A5][5b]
File55
[paul@RHELv4u3 gen]$ ls File[a5][5b]
File55  Fileab
[paul@RHELv4u3 gen]$ ls File[a5][5b][abcdefghijklm]
ls: File[a5][5b][abcdefghijklm]: No such file or directory
[paul@RHELv4u3 gen]$ ls file[a5][5b][abcdefghijklm]
fileabc
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can also exclude characters from a list between square brackets with the exclamation mark <command>!</command><indexterm><primary>!</primary></indexterm>. And you are allowed to make combinations of these <command>wild cards</command><indexterm><primary>wild cards</primary></indexterm>.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls file[a5][!Z]
fileab
[paul@RHELv4u3 gen]$ ls file[!5]*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls file[!5]?
fileab
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>The bash shell will also understand ranges of characters between brackets.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ ls file[a-z]*
fileab  fileab2  fileabc
[paul@RHELv4u3 gen]$ ls file[0-9]
file1  file2  file3
[paul@RHELv4u3 gen]$ ls file[a-z][a-z][0-9]*
fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>But, don't forget the influence of the <command>LANG</command><indexterm><primary>$LANG</primary></indexterm> variable. Some languages include lowercase letters in an uppercase range (and vice versa).</para>
			<screen>
paul@RHELv4u4:~/test$ ls [A-Z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ echo $LANG
en_US.UTF-8
paul@RHELv4u4:~/test$ LANG=C
paul@RHELv4u4:~/test$ echo $LANG
C
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3
paul@RHELv4u4:~/test$ ls [A-Z]ile?
File4
paul@RHELv4u4:~/test$ 
			</screen>
		</section>
		<section><title>Shell variables</title>
			<para>Another important character interpreted by the shell is the dollar sign <command>$</command><indexterm><primary>$</primary></indexterm>. The shell will look for an <command>environment variable</command><indexterm><primary>environment variable</primary></indexterm> named like the string behind the dollar sign and replace it with the value of the variable (or with nothing if the variable does not exist).</para>
			<screen>
[paul@RHELv4u3 gen]$ echo Hello $USER
Hello paul
[paul@RHELv4u3 gen]$ echo Hello $user
Hello
[paul@RHELv4u3 gen]$ echo This is the $SHELL shell
This is the /bin/bash shell
[paul@RHELv4u3 gen]$ echo This is $SHELL on computer $HOSTNAME
This is /bin/bash on computer RHELv4u3.localdomain
[paul@RHELv4u3 gen]$ echo The userid of $USER is $UID
The userid of paul is 500
[paul@RHELv4u3 gen]$ echo My homedir is $HOME
My homedir is /home/paul
[paul@RHELv4u3 gen]$
			</screen>
			<para>The exit code of the previous command is stored in the shell variable $?. Actually $? is a shell parameter and not a variable, you cannot assign a value to $?.</para>
			<screen>
paul@laika:~/test$ touch file1 ; echo $?
0
paul@laika:~/test$ rm file1 ; echo $?
0
paul@laika:~/test$ rm file1 ; echo $?
rm: cannot remove `file1': No such file or directory
1
paul@laika:~/test$
			</screen>
			<para>Bash will let you create your own variables.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo $MyVar
				
[paul@RHELv4u3 gen]$ MyVar=555
[paul@RHELv4u3 gen]$ echo $MyVar
555
[paul@RHELv4u3 gen]$ 
			</screen>
		</section>
		<section><title>set, unset and env</title>			
			<para>You can use the <command>set</command><indexterm><primary>set</primary></indexterm> and <command>env</command><indexterm><primary>env</primary></indexterm> commands to display a list of environment variables. On Ubuntu and Debian systems, the set command will end the list of shell variables with a list of shell functions, use <command>set | more</command> to see the variables then.</para>
			<para>The env command can also be useful for other neat things, like starting a clean shell (a shell without any inherited environment). The <command>env -i</command><indexterm><primary>env -i</primary></indexterm> command clears the environment for the subshell. Notice that bash will set the $SHELL variable on startup.</para>
			<screen>
[paul@RHEL4b ~]$ bash -c 'echo $SHELL $HOME $USER'
/bin/bash /home/paul paul
[paul@RHEL4b ~]$ env -i bash -c 'echo $SHELL $HOME $USER'
/bin/bash
[paul@RHEL4b ~]$
			</screen>
			<para>You can also use the env tool to set the LANG variable (or any other) for an instance of bash with one command. The example below uses this to show the influence of the LANG variable on file globbing.</para>
			<screen>
[paul@RHEL4b test]$ env LANG=C bash -c 'ls File[a-z]'
Filea  Fileb
[paul@RHEL4b test]$ env LANG=en_US.UTF-8 bash -c 'ls File[a-z]'
Filea  FileA  Fileb  FileB
[paul@RHEL4b test]$
			</screen>
			<para>Use the <command>unset</command><indexterm><primary>unset</primary></indexterm> command to remove a variable from your shell environment.</para>
			<screen>
[paul@RHEL4b ~]$ MyVar=8472
[paul@RHEL4b ~]$ echo $MyVar;unset MyVar;echo $MyVar
8472

[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Bash shell options</title>
			<para>Both <command>set</command><indexterm><primary>set</primary></indexterm> and <command>unset</command><indexterm><primary>unset</primary></indexterm> are built-in shell commands. They can be used to set options of the bash shell itself. The next example will clarify this. By default, the shell will treat unset variables as a variable having no value. By setting the -u option, the shell will treat any reference to unset variables as an error. See the man page of bash for more information.</para>
			<screen>
[paul@RHEL4b ~]$ echo $var123

[paul@RHEL4b ~]$ set -u
[paul@RHEL4b ~]$ echo $var123
-bash: var123: unbound variable
[paul@RHEL4b ~]$ set +u
[paul@RHEL4b ~]$ echo $var123

[paul@RHEL4b ~]$
			</screen>
			<para>To list all the set options for your Bash shell, use <command>echo $-</command><indexterm><primary>echo $-</primary></indexterm>. The noclobber option will be explained later in this book (in the I/O redirection chapter).</para>
			<screen>
[paul@RHEL4b ~]$ echo $-
himBH
[paul@RHEL4b ~]$ set -C ; set -u
[paul@RHEL4b ~]$ echo $-
himuBCH
[paul@RHEL4b ~]$ set +C ; set +u
[paul@RHEL4b ~]$ echo $-
himBH
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Exporting variables</title>
			<para>You can export shell variables to other shells with the <command>export</command><indexterm><primary>export</primary></indexterm> command. This will export the variable to child shells, not to the parent shell.</para>
			<screen>
[paul@RHEL4b ~]$ var3=three
[paul@RHEL4b ~]$ var4=four
[paul@RHEL4b ~]$ export var4
[paul@RHEL4b ~]$ echo $var3 $var4
three four
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $var3 $var4
four
[paul@RHEL4b ~]$ export var5=five
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
four five
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
three four
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Delineate variables</title>
			<para>Until now, we have seen that bash interpretes a variable starting from a dollar sign, until the first occurence of a non-alphanumerical character that is not an underscore. In some situations, this can be a problem. This issue can be resolved with curly braces like in this example.</para>
			<screen>
[paul@RHEL4b ~]$ prefix=Super
[paul@RHEL4b ~]$ echo Hello $prefixman and $prefixgirl
Hello  and
[paul@RHEL4b ~]$ echo Hello ${prefix}man and ${prefix}girl
Hello Superman and Supergirl
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Escaping</title>
			<para>When you want to use one of these characters that are automatically interpreted by the shell, you can <command>escape</command><indexterm><primary>escaping</primary></indexterm> them with a backslash <command>\</command><indexterm><primary>\</primary></indexterm> (or with quotes as seen earlier).</para>
			<screen>
[paul@RHELv4u3 ~]$ echo hello   world
hello world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo escaping \\\ \?\ \*\ \"\ \'
escaping \ ? * " '
[paul@RHELv4u3 ~]$ echo escaping \\\?\*\"\'
escaping \?*"'
			</screen>
			<para>Notice however that double quotes still allow the parsing of variables, whereas single quotes prevent this.</para>
			<screen>
[paul@RHELv4u3 ~]$ MyVar=555
[paul@RHELv4u3 ~]$ echo $MyVar
555
[paul@RHELv4u3 ~]$ echo "$MyVar"
555
[paul@RHELv4u3 ~]$ echo '$MyVar'
$MyVar
			</screen>
			<para>The bash shell will replace variables with their value in double quoted lines, but not in single quoted lines.</para>
			<screen>
[[paul@RHEL4b ~]$ echo "$var3  $SHELL"
three  /bin/bash
paul@RHEL4b ~]$ echo '$var3  $SHELL'
$var3  $SHELL
			</screen>
		</section>
		<section><title>Shell embedding</title>
			<para>Shells can be embedded on the command line, or in other words the command line scan can spawn new processes, containing a fork of the current shell. You can use variables to prove that new shells are created. In the screenshot below (which uses POSIX compliant embedding), the variable $var1 only exists in the (temporary) sub shell.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ echo $(var1=5;echo $var1)
5
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can embed a shell in an <command>embedded shell</command><indexterm><primary>embedding(shell)</primary></indexterm>, this is called nested embedding of bash.</para>
			<screen>
$ P=Parent;
$ echo $P$C$G - $(C=Child;echo $P$C$G - ;echo $(G=Grand;echo $P$C$G))
Parent - ParentChild - ParentChildGrand
			</screen>
			<para>Single embedding can be useful to avoid changing your current directory. The screenshot below uses back ticks instead of dollar-bracket to embed.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo `cd /etc; ls -d * | grep pass`
passwd passwd- passwd.OLD
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>Placing the embedding between <command>back ticks</command><indexterm><primary>back ticks</primary></indexterm> has the same meaning. But be careful, back ticks are often confused with single quotes. The technical difference between <command>'</command><indexterm><primary>'(single quote)</primary></indexterm> and <command>`</command><indexterm><primary>`(back tick)</primary></indexterm> is significant! You can not use back ticks to nest embedded shells.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo `var1=5;echo $var1`
5
[paul@RHELv4u3 gen]$ echo 'var1=5;echo $var1'
var1=5;echo $var1
[paul@RHELv4u3 gen]$
			</screen>
		</section>
		<section><title>Shell alias</title>
			<para>The shell will allow you to create aliases. An <command>alias</command><indexterm><primary>alias</primary></indexterm> can be useful to abbreviate commands.</para>
			<screen>
[paul@RHELv4u3 ~]$ cat count.txt 
one
two
three
[paul@RHELv4u3 ~]$ tac count.txt 
three
two
one
[paul@RHELv4u3 ~]$ dog count.txt 
-bash: dog: command not found
[paul@RHELv4u3 ~]$ alias dog=tac
[paul@RHELv4u3 ~]$ dog count.txt 
three
two
one
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>Aliases can be used to supply some commands with default options.</para>
			<screen>
[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: remove regular file `winter.txt'? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: winter.txt: No such file or directory
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm: remove regular empty file `winter.txt'? no
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can undo an alias with the <command>unalias</command><indexterm><primary>unalias</primary></indexterm> command.</para>
			<screen>
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$</screen>
		</section>
		<section><title>Displaying shell expansion</title>
			<para>You can display the shell expansion with <command>set -x</command><indexterm><primary>set -x</primary></indexterm>, and stop displaying it with <command>set +x</command><indexterm><primary>set +x</primary></indexterm>. You might want to use this further on in this course, or when in doubt about what exactly the shell is doing with your command.</para>
			<screen>
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo \$USER
$USER
[paul@RHELv4u3 ~]$ 
			</screen>
		</section>
	</section>
<section><title>bash shell history</title>
	<para>The bash shell will remember the commands you type, so you can easily repeat previous commands. Some variables are defining this process: <command>$HISTFILE</command><indexterm><primary>$HISTFILE</primary></indexterm> points to the location of the history file, <command>$HISTSIZE</command><indexterm><primary>$HISTSIZE</primary></indexterm> will tell you how many commands will be remembered in your current shell session, <command>$HISTFILESIZE</command><indexterm><primary>$HISTFILESIZE</primary></indexterm> is the truncate limit for the number of commands in the history file. Your shell session history is written to the file when exiting the shell.</para>
	<screen>
[paul@RHELv4u3 ~]$ echo $HISTFILE
/home/paul/.bash_history
[paul@RHELv4u3 ~]$ echo $HISTFILESIZE
1000
[paul@RHELv4u3 ~]$ echo $HISTSIZE
1000
[paul@RHELv4u3 ~]$ 
	</screen>
	<para>To repeat the last command, type <command>!!</command><indexterm><primary>!!</primary></indexterm>. This is pronounced as <command>bash bash</command>. To repeat older commands, use <command>history</command><indexterm><primary>history</primary></indexterm> to display your history and type <command>!</command><indexterm><primary>!</primary></indexterm> followed by a number. The shell will echo the command and execute it.</para>
	<screen>
[paul@RHELv4u3 ~]$ history
2  cat /etc/redhat-release 
3  uname -r
4  rpm -qa | grep ^parted
...
[paul@RHELv4u3 ~]$ !3
uname -r
2.6.9-34.EL
[paul@RHELv4u3 ~]$ 
	</screen>
	<para>You can also use the bash with one or more characters, the shell will then repeat the last command that started with those characters. But this can be very very dangerous, you have to be sure about the last command in your current shell history that starts with those characters! You can also use a colon followed by a regular expression to manipulate the previous command.</para>
	<screen>
[paul@RHEL4b ~]$ ls file4
file4
[paul@RHEL4b ~]$ !ls
ls file4
file4
[paul@RHEL4b ~]$ !ls:s/4/5
ls file5
file5
[paul@RHEL4b ~]$ history 4
  422  ls file4
  423  ls file4
  424  ls file5
  425  history 4
[paul@RHEL4b ~]$ 
	</screen>
</section>	
</chapter>
