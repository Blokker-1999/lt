<section><title>control operators</title>
	<section><title>; semicolon</title>
		<para>You can put two or more commands on the same line, separated by a semicolon <command>;</command><indexterm><primary>;</primary></indexterm>. The scan will then go until each semicolon, and the lines will be executed sequentially, with the shell waiting for each command to end before starting the next one.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo Hello
Hello
[paul@RHELv4u3 ~]$ echo World
World
[paul@RHELv4u3 ~]$ echo Hello ; echo World
Hello
World
[paul@RHELv4u3 ~]$ 
		</screen>
	</section>
	<section><title>&#038; ampersand</title>
		<para>When on the other hand you end a line with an ampersand <command>&#038;</command><indexterm><primary>&#038;</primary></indexterm>, then the shell will not wait for the command to finish. You will get your shell prompt back, and the command is executed in background. You will get a message when it has finished executing in background.</para>
		<screen>
[paul@RHELv4u3 ~]$ sleep 20 &#038;
[1] 7925
[paul@RHELv4u3 ~]$ 
...wait 20 seconds...
[paul@RHELv4u3 ~]$ 
[1]+  Done                     sleep 20
		</screen>
		<para>The technical explanation of what happens in this case is explained in the chapter about <command>processes</command>.</para>
	</section>
	<section><title>&#038;&#038; double ampersand</title>
		<para>You can control execution of commands with <command>&#038;&#038;</command><indexterm><primary>&#038;&#038;</primary></indexterm> denoting a logical AND. With &#038;&#038; the second command is only executed when the first one succeeds (returns a zero exit status). </para>
			<screen>
paul@barry:~$ echo first &#038;&#038; echo second ; echo third
first
second
third
paul@barry:~$ zecho first &#038;&#038; echo second ; echo third
-bash: zecho: command not found
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>logical AND</command><indexterm><primary>logical AND</primary></indexterm> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen &#038;&#038; ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ cd gen &#038;&#038; ls
-bash: cd: gen: No such file or directory
[paul@RHELv4u3 gen]$
			</screen>
	</section>
	<section><title>|| double vertical bar</title>
			<para>The reverse is true for || . Meaning the second command is only executed when the first command fails (or in other words: returns a non-zero exit status).</para>
			<screen>
paul@barry:~$ echo first || echo second ; echo third
first
third
paul@barry:~$ zecho first || echo second ; echo third
-bash: zecho: command not found
second
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>logical OR</command><indexterm><primary>logical OR</primary></indexterm> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen || ls
[paul@RHELv4u3 gen]$ cd gen || ls
-bash: cd: gen: No such file or directory
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
	</section>
	<section><title>Combining AND and OR</title>
			<para>You can use the logical AND and OR to echo whether a command worked or not.</para>
			<screen>
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
It worked!
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
rm: cannot remove `file1': No such file or directory
It failed!
paul@laika:~/test$
			</screen>
	</section>
	<section><title>\ backslash</title>
		<para>Lines ending in a backslash are continued on the next line. The shell will wait with shell expansion and execution of the command line until a return without backslash is encountered.</para>
			<screen>
[paul@RHEL4b ~]$ echo This command line \
> is split in three \
> parts
This command line is split in three parts
[paul@RHEL4b ~]$
			</screen>
	</section>
	<section><title># pound sign</title>
		<para>Anything written after a pound sign (#) is ignored by the shell. This is useful to write <command>shell comment</command><indexterm><primary>shell comment</primary></indexterm>, but has no influence on the command execution or shell expansion.</para>
			<screen>
paul@barry:~$ mkdir test    # we create a directory
paul@barry:~$ cd test       #### we enter the directory
paul@barry:~/test$ ls       # is it empty ?
paul@barry:~/test$
			</screen>
	</section>
	<section><title>Escaping special characters</title>
		<para>When you want to use one of the shell control characters, but without the shell interpreting them, then you can <command>escape</command><indexterm><primary>shell escaping</primary></indexterm> them with a backslash <command>\</command><indexterm><primary>\</primary></indexterm>.</para>
		<screen>
[paul@RHELv4u3 ~]$ echo hello \; world
hello ; world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo escaping \\\ \#\ \&#038;\ \"\ \'
escaping \ # &#038; " '
[paul@RHELv4u3 ~]$ echo escaping \\\?\*\"\'
escaping \?*"'
		</screen>
	</section>
	<section><title>Displaying shell expansion</title>
		<para>You can display the shell expansion with <command>set -x</command><indexterm><primary>set -x</primary></indexterm>, and stop displaying it with <command>set +x</command><indexterm><primary>set +x</primary></indexterm>. You might want to use this further on in this course, or when in doubt about what exactly the shell is doing with your command.</para>
		<screen>
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo \$USER
$USER
[paul@RHELv4u3 ~]$ 
		</screen>
	</section>
</section>
