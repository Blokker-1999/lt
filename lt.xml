<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
<bookinfo>
	<title>Linux Fun: Complete.</title>
	<author>
		<firstname>Paul</firstname>
		<surname>Cobbaut</surname>

	</author>
	<copyright>
		<year>2007</year>
		<holder>Paul Cobbaut (paul@cobbaut.be). When I think the book is ready for publishing, I for one will welcome the GNU FDL Overlords.</holder>
	</copyright>
	<pubdate>2007/09/10 12:01:42</pubdate>
	<releaseinfo>v0.920</releaseinfo>
	<abstract>
		<para>This book is meant to be used in an instructor-led training. For self-study, the idea is to read this book next to a working Linux computer so you can immediately do every subject, even every command.</para>
		<para>This book is aimed towards novice linux system administrators (and might be interesting and useful for home users that want to know a bit more about their linux system). However, this book is not meant as an introduction to linux desktop applications like text editors, browsers, mail clients, multimedia or office applications.</para>
		<para>More information and free .pdf available at http://cobbaut.be/lt/</para>
	</abstract>
</bookinfo>
<chapter><title>Introduction to Unix and Linux</title>
	<section><title>Operating Systems History</title>
		<section><title>AT &#038; T Bell Labs</title>
			<para>In 1969 <command>Dennis Ritchie</command> and <command>Ken Thompson</command> wrote <command>UNICS</command> (Uniplexed Information and Computing System) at Bell Labs. Together with <command>Douglas McIlroy</command> they are seen as the creators of Unix. The name Unix is a play on the Multics Operating System for large mainframe computers. Unics (later renamed to Unix) was written for mini computers like the DEC PDP-series. In 1973 they decided to write Unix in C (instead of assembler), to make it portable to other computers. Unix was made available to universities, companies and the US government, including the full source code. This meant that every C programmer could make changes. By 1978 about 600 computers were running Unix. In January 2007 an estimated seventy million websites are running on a Unix-like web server.</para>
		</section>
		<section><title>University of California, Berkeley</title>
			<para>Students of Berkeley were happy to join in the development of Bell Labs Unix, but were not so happy with the restrictive licensing. Unix was open source software, but it still required purchase of a license. So during the eighties, they rewrote all the Unix tools, until they had a complete Unix-like operating system. By 1991, the <command>BSD</command> (Berkeley Software Distribution) branch of Unix was completely separate from the Bell Labs Unix. <command>NetBSD</command>, <command>FreeBSD</command> and <command>OpenBSD</command> are three current Unix-like operating systems derived from the 1991 <command>BSD Net/2</command> codebase. Sun Solaris, Microsoft Windows and Apple MacOSX all use source code from BSD.</para>
		</section>
		<section><title>GNU's not Unix</title>
			<para>Largely because of unhappiness with the restrictive licensing on existing Unix implementations, <command>Richard Stallman</command> initiated the <command>GNU Project</command> in 1983. The GNU project aims to create free software. Development of the GNU operating system started, aiming to create a complete Unix-like branch, seperate from the two other (BSD and Bell Labs).  Today the GNU compiler <command>gcc</command> and most other GNU utilities (like <command>bash</command>) are among the most popular on many Unix-like systems. The official kernel of this project is <command>GNU/Hurd</command>, but you can hardly call that kernel a finished product.</para>
		</section>	
		<section><title>Linux</title>
			<para>Where GNU/Hurd failed, the Linux kernel succeeded! In 1991 a Finnish student named <command>Linus Torvalds</command> started writing his own operating system for his intel 80386 computer. In January 1992, Linus decided to release Linux under the GNU GPL. Thanks to this, thousands of developers are now working on the Linux kernel. Contrary to popular believe, they are not all volunteers. Today big companies like Sun, IBM, Novell, Red Hat, Sony, HP and others are actively paying developers to work on the Linux kernel. Mister Torvalds is still the only one to decide what code gets accepted into the kernel.</para>
		</section>
	</section>
	<section><title>Licensing</title>
		<section><title>Proprietary</title>
			<para>Some flavors of Unix, like HP-UX, IBM AIX and Sun Solaris 9 are delivered after purchase in binary form. You are not authorized to install or use these without paying a license to the owner. You are not authorized to distribute these copies to other people, and you are not authorized to look at or change the closed source code of the operating system. This software is usually protected by copyright, patents and extensive software licensing.</para>
		</section>
		<section><title>BSD</title>
			<para>BSD style licenses are close to the public domain. They essentially state that you can copy the software, but you have to leave the copyright notice that refers to BSD. This license gives a lot of freedom, but offers few protection to someone copying and selling your work.</para>
		</section>
		<section><title>GNU General Public License (GPL)</title>
			<para>More and more software is being released under the <command>GPL</command> (in 2006 Java was released under the GPL). The goal of the GPL is to guarantee that free software stays free. Everyone can work together on GPL software, knowing that the software will be freely available to everyone. The GPL can protect software, even in court.</para>
			<para>Free as in <command>freedom of speech</command>, not to be confused with free as in not having to pay for your free beer. In other words, or even better, in other languages free software translates to <command>vrije software</command> (Dutch) or <command>Logiciel Libre</command> (French). Whereas the free from free beer translates to gratis.</para>
			<para>Briefly explained, the GPL allows you to copy software, the GPL allows you to distribute (sell or give away) that software, and the GPL grants you the right to read and change the source code. But the person receiving or buying the software from you has the same rights. And also, should you decide to distribute modified versions of GPL software, then you are obligated to put the same license on the modifications (and provide the source code of your modifications). You can actually call the GPL a <command>viral license</command> because it spreads like a virus.</para>
		</section>
		<section><title>Others...</title>
			<para><emphasis>There are many other licenses on software. You should read and understand them before using any software.</emphasis></para>
		</section>
	</section>
	<section><title>Current Distributions</title>
		<section><title>About</title>
			<para>Unix comes in many flavors, usually called <command>distributions</command>. A distribution (or in short distro) is a collection of software packages, distributed on CD, online or pre-installed on computers. All the software in a distribution is supposedly thoroughly tested and integrates nicely into a whole. Software is maintained (patched) by the distributor, and is managed by an <command>integrated package manager</command>. Many distro's have a central <command>repository of approved software</command>. Installing software from outside the distro can sometimes be cumbersome and may void your warranty on the system.</para>
			<para><emphasis>Typical among <command>geeks</command> are all the <command>flame wars</command> over which is the best distribution. I had this very funny image copied from http://ars.userfriendly.org/cartoons/?id=19990301&#038;mode=classic here, but the copyright owners did not approve the inclusion of this image in this course.</emphasis></para>
		</section>	
		<section><title>Major Vendors of Unix</title>
			<para>We should at least mention IBM's <command>AIX</command>, Sun's <command>Solaris</command> and Hewlett-Packards <command>HP-UX</command>, all are based on the original Unix from Bell Labs (Unix System V). Sun's <command>SunOS</command>, HP's <command>Tru64</command> (originally from DEC) and Apple's <command>MacOSX</command> are more derived from the BSD branch. But most Unixes today contain source code and implementations from both original Unix-branches.</para>
		</section>	
		<section><title>Some BSD Distributions</title>
			<section><title>FreeBSD</title>
				<para>FreeBSD is a complete operating system. The kernel and all of the utilities are held in the same source code tree. FreeBSD runs on many architectures and is considered to be reliable and robust. Millions of websites are running on FreeBSD, including some big like yahoo, netcraft, php.net, freebsd.org and (until last year) ftp.cdrom.com.</para>
			</section>
			<section><title>NetBSD</title>
				<para>NetBSD development started around the same time (1993) as FreeBSD. NetBSD runs on many architectures and is often used in embedded devices.</para>
			</section>
			<section><title>OpenBSD</title>
				<para>Co-founder Theo De Raadt from NetBSD founded the OpenBSD project in 1994. OpenBSD is by far the most secure operating system in the world. The past ten years, only two vulnerabilities were found in the default install of OpenBSD. All source code is thoroughly checked. OpenBSD runs on sixteen different architectures and is commonly used for firewalls and IDS. The OpenBSD people also bring us OpenSSH.</para>
			</section>
		</section>
		<section><title>Linux Distributions</title>
			<para>There are hundreds of linux distributions, just take a look at the distrowatch.com website. For many years, Red Hat, Suse and Mandrake were considered the big three for end users. Red Hat is still the biggest commercial linux vendor. Today, the most popular linux distro is Ubuntu.</para>
			<section><title>Red Hat</title>
				<para>Redhat exists as a company since 1993. They distribute <command>Red Hat Enterprise Linux</command> (RHEL) to companies and manage the <command>Fedora</command> project. RHEL is probably the most popular Linux-based distro on servers. Fedora is a very popular and user friendly Linux-based distro, aimed towards home users. The company makes a profit of around one hundred million dollars a year, selling support contracts. Red Hat contributes a lot to the linux kernel and other free software projects.</para>
				<section><title>Red Hat Linux</title>
					<para>Red Hat Linux was distributed from 1994 until 2003. It was one of the oldest common Linux distributions. Red Hat Linux was the first distro to use the <command>rpm</command> package format. Many other distro's are originally derived from Red Hat Linux. The company <command>Red Hat, Inc.</command> decided to split Red Hat Linux into <command>Fedora Core</command> and <command>Red Hat Enterprise Linux</command>.</para>
				</section>
				<section><title>Fedora Core</title>
					<para>Fedora is sponsored by Red Hat, and is aimed toward home users. There is no official support from Red Hat. About every six months there is a new version of Fedora. Fedora usually has more recent versions of kernel and applications than RHEL. Fedora Core 7 was released May 2007.</para>
				</section>
				<section><title>Red Hat Enterprise Linux</title>
					<para>Since 2005 Red Hat distributes four different RHEL variants. <command>RHEL AS</command> is for mission-critical computer systems. <command>RHEL ES</command> is for small to mid-range servers. <command>RHEL WS</command> is for technical power user desktops and critical design. <command>Red Hat Desktop</command> is for multiple deployments of single user desktops. Red Hat does not give an explanation for the meaning of AS, ES and WS, but it might be Advanced Server, Entry-level Server and Workstation. </para>
				</section>
				<section><title>Differences 4.1 4.2 4.3 and 4.4</title>
					<para>The differences between the RHEL 4 updates are minimal, but can nevertheless be influential. In the next three screenshots, you can see some differences (kernel and parted) between RHELv4 updates 2, 3 and 4.</para>
					<screen>
paul@RHELv4u2:~$ cat /etc/redhat-release 
Red Hat Enterprise Linux ES release 4 (Nahant Update 2)
paul@RHELv4u2:~$ uname -r
2.6.9-22.EL
paul@RHELv4u2:~$ rpm -qa | grep ^parted
parted-1.6.19-1.EL
parted-devel-1.6.19-1.EL
paul@RHELv4u2:~$ 
					</screen> 
					<screen>
[paul@RHELv4u3 ~]$ cat /etc/redhat-release 
Red Hat Enterprise Linux ES release 4 (Nahant Update 3)
[paul@RHELv4u3 ~]$ uname -r
2.6.9-34.EL
[paul@RHELv4u3 ~]$ rpm -qa | grep ^parted
parted-1.6.19-1.EL
parted-devel-1.6.19-1.EL
[paul@RHELv4u3 ~]$ 
					</screen> 
					<screen>
paul@RHELv4u4:~$ cat /etc/redhat-release 
Red Hat Enterprise Linux AS release 4 (Nahant Update 4)
paul@RHELv4u4:~$ uname -r
2.6.9-42.0.3.EL
paul@RHELv4u4:~$ rpm -qa | grep ^parted
parted-1.6.19-4.EL
paul@RHELv4u4:~$ 
					</screen>
					<para>The following screenshot shows a procedure to find all application versions, and a way to compare any two installed RHEL servers. The first is done on RHELv4u2, and lists all installed applications in alphabetical order. The same is done on RHELv4u3. Both results are saved in a file, and then compared with <command>comm</command>.</para>
					<screen>
paul@RHELv4u2:~$ rpm -qa | sort > AllAppsRHELv4u2ES.txt
	
paul@RHELv4u3:~$ rpm -qa | sort > AllAppsRHELv4u3ES.txt
		
paul@laika:~$ scp RHELv4u2:~/All* .
paul@rhelv4u2's password: 
AllAppsRHELv4u2ES.txt                         100%   30KB  30.3KB/s   00:00    
paul@laika:~$ scp RHELv4u3:~/All* .
paul@rhelv4u3's password: 
AllAppsRHELv4u3ES.txt                         100%   31KB  30.9KB/s   00:00    
paul@laika:~$ comm AllAppsRHELv4u2ES.txt AllAppsRHELv4u3ES.txt -3 > diff_u2_u3.txt
paul@laika:~$ 
					</screen>
				</section>
				<section><title>Red Hat Enterprise Linux 5</title>
					<para>Red Hat Enterprise Linux version 5 is available since March 2007. One of the notable new features is the inclusion of <command>Xen</command>. Xen is a free virtual machine application that allows modified NetBSD and Linux to serve as host for a number of unmodified guest OS'ses. Beyond just virtualization, RHEL 5 will also have better SELinux support, clustering, network storage and smartcard integration.</para>
				</section>
				<section><title>CentOS and Unbreakable Linux</title>
					<para>Both <command>CentOS</command> and Oracle's <command>Unbreakable Linux</command> are directly derived from RHEL, but all references to Red Hat trademarks are removed. Companies are allowed to do this (GPL), and are hoping to make a profit selling support (without having the cost to maintain and develop their own distribution). Red Hat is not really worried about this, since they develop a lot on Linux, and thus can offer much better support. The Oracle offer however is still very recent, let's wait and see how many organizations will buy a complete solution from Oracle.</para>
				</section>
			</section>
			<section><title>Ubuntu</title>
				<para><command>Ubuntu</command> is a rather new distribution, based on <command>debian</command> and funded by South African developer and billionaire astronaut <command>Mark Shuttleworth</command>. Ubuntu is giving away free (as in beer and speech) CD's with <command>Ubuntu, Linux for Human Beings</command>. Many people consider Ubuntu to be the most user friendly Linux distribution. The company behind Ubuntu is <command>Canonical</command>, they aim to make a profit of selling support soon. Ubuntu is probably the most popular Unix-like distribution on personal desktops.</para>
			</section>
			<section><title>Novell Suse</title>
				<para>A couple of years ago, <command>Novell</command> bought the German company <command>Suse</command>. They are seen as the main competitor to Red Hat with their SLES (Suse Linux Enterprise Server) and SLED (Suse Linux Enterprise Desktop) versions of Suse Linux. Unfortunately they seem slow at getting their act together. Similar to Fedora, Novell hosts the <command>OpenSUSE</command> project as a testbed for upcoming SLED and SLES releases.</para>
				<para>Novell has signed a very controversial deal with Microsoft. Some high profile open source developers have left the company because of this agreement, and many people from the open source community are actively advocating to abandon Novell completely.</para>
			</section>
			<section><title>Debian</title>
				<para>Debian is one of the most secure linux distro's. It is known to be stable and reliable. But Debian is also known to be a linux for advanced users, not for beginners. A lot of distributions (Ubuntu, Knoppix, ...) are derived from the Debian codebase. Debian has <command>aptitude</command>, which is considered the best package management system.</para>
			</section>
			<section><title>Mandriva</title>
				<para>Mandriva is the unification of the Brazilian distro Connectiva with the French distro Mandrake. They are considered a user friendly distro, with support from the French government. </para> 
			</section>
		</section>
		<section><title>Solaris</title>
			<section><title>Solaris 8 and Solaris 9</title>
				<para>All <command>Sun Solaris</command> releases before Solaris 10 are proprietary binary only, just like IBM AIX and HP-UX.</para>
			</section>
			<section><title>Solaris 10</title>
				<para>Solaris 10 is the officialy supported Sun distribution. It is a free (as in beer) download. Sun releases binary patches and updates. Sun would like a community built around the solaris kernel, similar to the linux community. Sun released the Solaris kernel under the CDDL, a license similar to the GPL, hoping this will happen.</para>
			</section>
			<section><title>Nevada and Solaris Express</title>
				<para>Nevada is the codename for the next release of Solaris (Solaris 11). It is currently under development by Sun and is based on the OpenSolaris code. Solaris Express Community Edition is an official free binary release including open source OpenSolaris and some closed source technologies, updated twice a month without any support from Sun. Solaris Express Developer Edition is the same, but with some support, thorough testing before release, and released twice a year.</para>
				</section>
			<section><title>OpenSolaris, Belenix and Nexenta</title>
				<para>OpenSolaris is een open source development project (yes, it is only source code). Future versions of the Solaris operating system are based on this source code. The <command>Belenix</command> LiveCD is based on OpenSolaris. Another famous opensolaris based distro is <command>Nexenta</command>. Nexenta (www.gnusolaris.org) looks like <command>Ubuntu</command> and feels like <command>Debian</command>. The goal of this <command>GNU/Solaris</command> project is to have the best linux desktop (Ubuntu) including the <command>aptitude</command> package manager running on a Sun Solaris kernel. </para>
			</section>
		</section>
	</section>
	<section><title>Certification</title>
		<section><title>LPI: Linux Professional Institute</title>
			<section><title>LPIC Level 1</title>
				<para>This is the junior level certification. You need to pass exams 101 and 102 to achieve LPIC 1 certification. To pass level one, you will need linux command line, user management, backup and restore, installation, networking and basic system administration skills.</para>
			</section>
			<section><title>LPIC Level 2</title>
				<para>This is the advanced level certification. You need to be LPIC 1 certified and pass exams 201 and 202 to achieve LPIC 2 certification. To pass level two, you will need to be able to administer medium sized linux networks, including Samba, mail, news, proxy, firewall, web and ftp servers.</para>
			</section>
			<section><title>LPIC Level 3</title>
				<para>This is the senior level certification. It contains one core exam (301) which tests advanced skills including ldap, samba, pam, perl and others. To achieve this level you also need LPIC Level 2 and pass a specialty exam. More info on www.lpi.org.</para>
			</section>
			<section><title>Ubuntu</title>
				<para>When you are LPIC Level 1 certified, you can take a LPI Ubuntu exam (199) and become Ubuntu certified.</para>
			</section>
		</section>
		<section><title>Red Hat Certified Engineer</title>
			<para>The big difference with most certs is that there are no multiple choice questions for <command>RHCE</command>. Red Hat Certified Engineers have taken a live exam consisting of two parts. First they have to troubleshoot and maintain an existing but broken setup (scoring at least 80 percent), second they have to install and configure a machine (scoring at least 70 percent).</para>
		</section>
		<section><title>MySQL</title>
			<para>There are two tracks for MySQL certification; Certified MySQL 5.0 Developer (CMDEV) and Certified MySQL 5.0 DBA (CMDBA). The CMDEV is focused at database application developers, the CMDBA is for database administrators. Both tracks require two exams each. The MySQL cluster DBA certification requires CMDBA certification and passing the CMCDBA exam.</para>
		</section>
		<section><title>Novell CLP/CLE</title>
			<para>To become a Novell Certified Linux Professional, you have to take a live practicum. This is a VNC session to a set of real SLES servers. You have to perform several tasks and are free to choose your method (commandline or YaST or ...). No multiple choice involved.</para>
		</section>
		<section><title>Sun Solaris</title>
			<para>Sun uses the classical formula of multiple choice exams for certification. Passing two exams for an operating system gets you the Solaris Certified Administrator for Solaris X title.</para>
		</section>
		<section><title>Other certifications</title>
			<para>There are many other less known certs like EC council's Certified Ethical Hacker, CompTIA's linux+ and Sair's Linux GNU.</para>
		</section>
	</section>
</chapter>
<chapter><title>Technical Introduction to Unix and Linux</title>
	<section><title>How an Operating System works</title>
		<para>The tasks of an operating system include management of <command>hardware</command>, <command>memory</command>, <command>processes</command> and <command>applications</command>. An operating system consists of a software <command>kernel</command> and a number of tools, and can be considered a <command>platform</command> for applications.</para>
		<para>To manage the <command>hardware</command>, the operating system uses <command>interrupts</command> and <command>device drivers</command>. A monolithic kernel like Linux can dynamically load these in memory as <command>modules</command>.</para>
		<para>A computer's <command>memory</command> comes in different speeds and prices, the faster, the more expensive. Ordered from fastest to slowest we have: <command>registers</command> inside the CPU, <command>cache</command> on the CPU, <command>RAM modules</command> and <command>hard disks</command>. An operating system may start <command>paging</command>, using a part of the hard disk as memory storage.</para>
		<para>A <command>process</command> is compiled source code that is currently running on the computer. Only one process at a time can run on a <command>CPU</command> or processor. The operating system will provide <command>multitasking</command> features by giving every process a small amount of time (about 50ms max) to run on the CPU, before interrupting it, and giving control to the next process. For us humans, applications seem to run at the same time. When more than one CPU is present in the system, the operating system can support <command>multiprocessing</command>. This really enables applications to run simultaneously.</para>
		<para>Applications receive a vast amount of <command>virtual address space</command> from the operating system, so they don't interfere with other applications.</para>
	</section>
	<section><title>Where to find help ?</title>
		<section><title>Manual Pages</title>
			<para>Most Unix tools and commands have pretty good man pages. Type <command>man</command> followed by a command (for which you want help) and start reading. Ah, and press <command>q</command> to quit the manpage.</para>
			<screen>
paul@laika:~$ man whois
Reformatting whois(1), please wait...
paul@laika:~$ 
			</screen>
			<para>Manpages can be useful when you are switching a lot between different flavors of unix, to find those little differences in commands. Very often manpages also describe configuration files and daemons.</para>
			<screen>
paul@laika:~$ man syslog.conf
Reformatting syslog.conf(5), please wait...
paul@laika:~$ man syslogd
Reformatting syslogd(8), please wait...
			</screen>
			<para>The <command>man -k</command> command (same as <command>apropos</command>) will show you a list of manpages containing your searchstring.</para>
			<screen>
paul@laika:~$ man -k syslog
lm-syslog-setup (8)  - configure laptop mode to switch syslog.conf based on power state
logger (1)           - a shell command interface to the syslog(3) system log module
syslog-facility (8)  - Setup and remove LOCALx facility for sysklogd
syslog.conf (5)      - syslogd(8) configuration file
syslogd (8)          - Linux system logging utilities.
syslogd-listfiles (8) - list system logfiles
paul@laika:~$
			</screen>
			<para>By now you will have noticed the numbers between the round brackets. <command>man man</command> will explain to you that these are section numbers. If you want to know more, RTFM (Read The Fantastic Manual). <emphasis>Unfortunately, manual pages do not have the answer to everyhting...</emphasis></para>
			<screen>
paul@laika:~$ man woman
No manual entry for woman
			</screen>
		</section>
		<section><title>Red Hat Manuals online</title>
			<para>Red Hat has a lot of info online at http://www.redhat.com/docs/manuals/ in both pdf and html format. <emphasis>Unfortunately, the information there is not always up to date.</emphasis></para>
		</section>
		<section><title>Searching the internet with Google</title>
			<para>Google is a powerful tool to find help about Unix, or anything else. Here are some tricks.</para>
			<para>Look for phrases instead of single words.</para>
			<mediaobject><imageobject><imagedata fileref="phrase" format="EPS" align="center"></imagedata></imageobject></mediaobject>			
			<para>Search only pages from Belgium (or substitute .be for any other Top Level Domain).</para>
			<mediaobject><imageobject><imagedata fileref="sitehint" format="EPS" align="center"></imagedata></imageobject></mediaobject>
			<para>Search for pages inside one domain</para>
			<mediaobject><imageobject><imagedata fileref="sitehint2" format="EPS" align="center"></imagedata></imageobject></mediaobject>
			<para>Search for pages <command>not</command> containing some words.</para>
			<mediaobject><imageobject><imagedata fileref="negativehint" format="EPS" align="center"></imagedata></imageobject></mediaobject>
		</section>
		<section><title>Wikipedia</title>
			<para>Wikipedia is a web-based, free-content encyclopedia. Its growth the past two years has been astonishing. You have a good chance of finding a clear explanation by typing your search term behind <command>http://en.wikipedia.org/wiki/</command> like this example shows.</para>
			<mediaobject><imageobject><imagedata fileref="wikipedia.png" format="EPS" align="center"></imagedata></imageobject></mediaobject>
		</section>
		<section><title>The Linux Documentation Project</title>
			<para>On www.tldp.org you will find a lot of documentation, faqs, howtos and man pages about Linux and many other programs running on Linux.</para>
		</section>
	</section>
	<section><title>Discovering the classroom</title>
		<para>It is time now to take a look at what we have in this classroom. Students should be able to log on to one or more (virtual) Linux computers and test connectivity to each other and to the internet.</para>
	</section>
</chapter>
<chapter><title>The Linux File System Tree</title>
	<section><title>Unix is case sensitive</title>
		<para>Unix is <command>case sensitive</command>, this means that FILE1 is different from file1, and /etc/hosts is different from /etc/Hosts (the latter one does not exist on a typical Unix). </para>
	</section>
	<section><title>The linux file system tree</title>
		<para>All Unix systems have a directory structure that starts at the <command>root directory</command>. The root directory is represented by a slash, like this: <command>/</command> . Everything that exists on your linux system can be found below this root directory. Let's take a brief look at the contents of the root directory.</para>
		<screen>
[paul@RHELv4u3 ~]$ ls /
bin   dev  home    lib         media  mnt  proc  sbin     srv  tftpboot  usr
boot  etc  initrd  lost+found  misc   opt  root  selinux  sys  tmp       var
[paul@RHELv4u3 ~]$ 
		</screen>
		<section><title>Filesystem Hierarchy</title>
			<para>There are some differences between the flavors of Unix. For help about your machine, enter <command>man hier</command> to find information about the file system hierarchy. Red Hat, Novell Suse, even Sun's Solaris all aim to follow the <command>Filesystem Hierarchy Standard</command> (FHS). Maybe the FHS will make more Unix file systems unite in the future. Let's take a look at the <command>FHS</command>.</para>
		</section>
		<section><title>Filesystem Hierarchy Standard</title>
			<para>On http://www.pathname.com/fhs/ we read "The filesystem hierarchy standard has been designed to be used by Unix distribution developers, package developers, and system implementors. However, it is primarily intended to be a reference and is not a tutorial on how to manage a Unix filesystem or directory hierarchy." Below we will discuss a couple of root directories. <emphasis>For a complete reference, you'll have to check with every developer and system administrator in the world ;-)</emphasis></para>
		</section>
		<section><title>/bin binaries</title>
			<para>The <command>/bin</command> directory contains binaries for use by all users. According to the FHS /bin/date should exist, and /bin should contain /bin/cat. You will find a bin subdirectory in many other directories. Binaries are sometimes called <command>executables</command>. In the screenshot below you see a lot of common unix commands like cat, cp, cpio, date, dd, echo, grep and so on. A lot of these will be covered in this book.</para>
<screen>
paul@laika:~$ ls /bin
arch           debconf-get       loadkeys        pidof              sysfs
archdetect     df                login           ping               tar
autopartition  dir               log-output      ping6              tempfile
bash           dmesg             ls              ps                 touch
bunzip2        dnsdomainname     lsmod           pwd                true
bzcat          echo              lspci           rbash              umount
bzcmp          ed                mapdevfs        readlink           uname
bzdiff         egrep             mkdir           register-module    uncompress
bzegrep        false             mknod           rm                 update-dev
bzexe          fgconsole         mktemp          rmdir              user-params
bzfgrep        fgrep             more            rnano              vdir
bzgrep         fuser             mount           run-parts          which
bzip2          get_mountoptions  mountpoint      search-path        xbrlapi
bzip2recover   grep              mt              sed                zcat
bzless         gunzip            mt-gnu          select_mountopt    zcmp
bzmore         gzexe             mv              select_mountpoint  zdiff
cat            gzip              nano            setpci             zegrep
chgrp          hostname          nc              setupcon           zfgrep
chmod          hw-detect         netcat          sh                 zforce
chown          ip                netstat         sh.distrib         zgrep
cp             kbd_mode          parted_devices  sleep              zless
cpio           kill              parted_server   stralign           zmore
dash           ld_static         partman         stty               znew
date           list-devices      partman-commit  su
dd             ln                perform_recipe  sync
</screen>
		</section>
		<section><title>/boot static files to boot the system</title>
			<para>The <command>/boot</command> directory contains all files needed to boot the computer. These files don't change very often. On Linux systems you typically find the <command>/boot/grub</command> directory here. This /boot/grub contains <command>/boot/grub/menu.lst</command> (the grub configuration file), which defines the bootmenu that is being displayed before the kernel starts.</para>
		</section>
		<section><title>/dev device files</title>
			<para>Device files in <command>/dev</command> appear to be ordinary files, but are not located on the harddisk. Instead they are an interface for a device driver toward a (physical or special) device.</para>
			<section><title>Common physical devices</title>
				<para>Common hardware such as hard disk devices are represented by device files in <command>/dev</command>. Below a screenshot of SATA device files on a laptop and then IDE attached drives on a desktop. (The detailed meaning of these devices will be discussed later.)</para>
				<screen>
#
# SATA or SCSI
#
paul@laika:~$ ls /dev/sd*
/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb  /dev/sdb1  /dev/sdb2

#
# IDE or ATAPI
#
paul@barry:~$ ls /dev/hd*
/dev/hda  /dev/hda1  /dev/hda2  /dev/hdb  /dev/hdb1  /dev/hdb2  /dev/hdc
				</screen>
				<para>Besides representing physical hardware, some device files are special. These special devices can be very useful.</para>
			</section>
			<section><title>/dev/tty and /dev/pts</title>
				<para>For example <command>/dev/tty1</command> represents a terminal or console attached to the system. (Don't break your head on the exact terminology of 'terminal' or 'console', what we mean here is a commandline interface.) When typing commands in a terminal that is part of a graphical interface like Gnome or KDE, then your terminal will be represented as <command>/dev/pts/1</command> (1 can be another number).</para>
			</section>
			<section><title>/dev/null</title>
				<para>On Linux you will find special devices like <command>/dev/null</command> which can be considered a black hole, it has unlimited storage, but nothing can be retrieved from it. Technically speaking, anything given to /dev/null will be discarded. /dev/null can be useful to discard unwanted output from commands. <emphasis>/dev/null is not a good location to store all your backups ;-)</emphasis>.</para>
			</section>
			<section><title>/dev/zero</title>
				<para>Another Linux special device is <command>/dev/zero</command>, which can be considered a source of zeroes. You cannot sent something to /dev/zero, but you can read zeroes from it.</para>
			</section>
			<section><title>/dev/random</title>
				<para>This device acts as a random number generator on any Unix machine.</para>
			</section>
		</section>
		<section><title>/etc Configuration Files</title>
			<para>All of the machine-specific configuration files should be located in <command>/etc</command>. Many times the name of a configuration files is the same as the application or daemon or protocol with .conf added as an extension. But there is much more to be found in /etc.</para>
			<screen>
paul@laika:~$ ls /etc/*.conf
/etc/adduser.conf        /etc/ld.so.conf               /etc/scrollkeeper.conf
/etc/brltty.conf         /etc/lftp.conf                /etc/sysctl.conf
/etc/ccertificates.conf  /etc/libao.conf               /etc/syslog.conf
/etc/cvs-cron.conf       /etc/logrotate.conf           /etc/ucf.conf
/etc/ddclient.conf       /etc/ltrace.conf              /etc/uniconf.conf
/etc/debconf.conf        /etc/mke2fs.conf              /etc/updatedb.conf
/etc/deluser.conf        /etc/netscsid.conf            /etc/usplash.conf
/etc/fdmount.conf        /etc/nsswitch.conf            /etc/uswsusp.conf
/etc/hdparm.conf         /etc/pam.conf                 /etc/vnc.conf
/etc/host.conf           /etc/pnm2ppa.conf             /etc/wodim.conf
/etc/inetd.conf          /etc/popularity-contest.conf  /etc/wvdial.conf
/etc/kernel-img.conf     /etc/resolv.conf
paul@laika:~$ 
			</screen>
			<section><title>/etc/X11/</title>
				<para>The graphical display (aka <command>X Window System</command> or just <command>X</command>) is driven by software from the X.org foundation. The configuration file for your graphical display is <command>/etc/X11/xorg.conf</command>. </para>
			</section>
			<section><title>/etc/filesystems</title>
				<para>When mounting a file system without specifying explicitly the file system, then <command>mount</command> will first probe <command>/etc/filesystems</command>. Mount will skip lines with the <command>nodev</command> directive, and should this file end with a single * on the last line, then mount will continue probing <command>/proc/filesystems</command>.</para>
				<screen>
paul@RHELv4u4:~$ cat /etc/filesystems 
ext3
ext2
nodev proc
nodev devpts
iso9660
vfat
hfs
paul@RHELv4u4:~$
				</screen>
			</section>
			<section><title>/etc/redhat-release</title>
			<para>This file contains the Red Hat version on most of the Red Hat and Red Hat derived systems.</para>
			<screen>
paul@RHELv4u4:~$ cat /etc/redhat-release 
Red Hat Enterprise Linux AS release 4 (Nahant Update 4)
paul@RHELv4u4:~$
			</screen>
			</section>
			<section><title>/etc/skel/</title>
				<para>The <command>skeleton</command> directory <command>/etc/skel</command> is copied to the home directory of a newly created user.</para>
			</section>
			<section><title>/etc/sysconfig/</title>
				<para>This directory, which is not mentioned in the FHS, contains a lot of Red Hat Enterprise Linux configuration files. We will discuss some of them in greater detail. The screenshot below is the <command>/etc/sysconfig</command> from RHELv4u4 with everything installed.</para>
				<screen>
paul@RHELv4u4:~$ ls /etc/sysconfig/
apmd         firstboot     irda              network          saslauthd
apm-scripts  grub          irqbalance        networking       selinux
auditd       harddisks     kernel            network-scripts  sendmail
authconfig   hidd          keyboard          ntpd             spamassassin
autofs       httpd         kudzu             openib.conf      squid
bluetooth    hwconf        lm_sensors        pand             syslog
clock        i18n          mouse             pcmcia           system-config-sec
console      init          mouse.B           pgsql            system-config-users
crond        installinfo   named             prelink          system-logviewer
desktop      ipmi          netdump           rawdevices       tux
diskdump     iptables      netdump_id_dsa    rhn              vncservers
dund         iptables-cfg  netdump_id_dsa.p  samba            xinetd
paul@RHELv4u4:~$ 
				</screen>
				<para>The file <command>/etc/sysconfig/firstboot</command> tells the Red Hat Setup Agent to not run at boot time. If you want to run the Red Hat Setup Agent at the next reboot, then simply remove this file, and run <command>chkconfig --level 5 firstboot on</command>. The Red Hat Setup Agent allows you to install the latest updates, create a user account, join the Red Hat Network and more. It will then create the /etc/sysconfig/firstboot file again.</para>
				<screen>
paul@RHELv4u4:~$ cat /etc/sysconfig/firstboot 
RUN_FIRSTBOOT=NO
				</screen>
				<para>The file <command>/etc/sysconfig/harddisks</command> contains some parameters to tune the hard disks. The file explains itself.</para>
				<para>You can see hardware detected by <command>kudzu</command> in <command>/etc/sysconfig/hwconf</command>. Kudzu is software from Red Hat for automatic discovery and configuration of hardware.</para>
				<para>The keyboard type and table are set in the <command>/etc/sysconfig/keyboard</command> file. For more console keyboard information, check the manual pages of <command>keymaps(5)</command>, <command>dumpkeys(1)</command>, <command>loadkeys(1)</command> and the directory <command>/lib/kbd/keymaps/</command>.</para>
				<screen>
root@RHELv4u4:/etc/sysconfig# cat keyboard 
KEYBOARDTYPE="pc"
KEYTABLE="us"
				</screen>
				<para>We will discuss the networking files in this directory in the networking chapter.</para>
			</section>
		</section>
		<section><title>/home sweet home</title>
			<para>You will find a lot of locations with an extensive hierarchy of personal or project data under <command>/home</command>. It is common practice (but not mandatory) to name the users home directory after their username in the format /home/$USERNAME. Like in this example:</para>
			<screen>
paul@pasha:~$ ls /home 
geert  guillaume  maria  paul  tom
			</screen>
			<para>Besides giving every user (or every project or group) a location to store personal files, the home directory of a user also serves as a location to store the user profile. A typical Unix user profile contains a bunch of hidden files (files who's filename starts with a dot). The hidden files of the Unix user profile contain settings specific for that user.</para>
			<screen>
paul@pasha:~$ ls -d /home/paul/.*
/home/paul/.              /home/paul/.bash_profile  /home/paul/.ssh
/home/paul/..             /home/paul/.bashrc        /home/paul/.viminfo
/home/paul/.bash_history  /home/paul/.lesshst       /home/paul/.Xauthority
			</screen>
		</section>
		<section><title>/initrd</title>
			<para>This empty directory is used as a mount point by Red Hat Enterprise Linux during boot time. Removing it causes a kernel panic during the next boot.</para>
		</section>
		<section><title>/lib shared libraries</title>
			<para>Binaries, like those found in /bin, often use shared libraries located in <command>/lib</command>. Below a partial screenshot of the contents of /lib.</para>
			<screen>
paul@laika:~$ ls /lib/libc*
/lib/libc-2.5.so     /lib/libcfont.so.0.0.0  /lib/libcom_err.so.2.1    
/lib/libcap.so.1     /lib/libcidn-2.5.so     /lib/libconsole.so.0      
/lib/libcap.so.1.10  /lib/libcidn.so.1       /lib/libconsole.so.0.0.0  
/lib/libcfont.so.0   /lib/libcom_err.so.2    /lib/libcrypt-2.5.so      
			</screen>
			<section><title>/lib/modules</title>
				<para>Typically, the kernel loads kernel modules from <command>/lib/modules</command>. </para>
			</section>
			<section><title>/lib32 and /lib64</title>
				<para>We are now (the year 2007) in a transition between 32-bit and 64-bit systems. So you might encounter directories named <command>/lib32</command> and <command>/lib64</command>, to clarify the register size used at compilation time of the libraries. My current 64-bit laptop has some older 32-bit binaries and libraries for compatibility with legacy applications. The screenshot uses the <command>file</command> utility to point out the difference.</para>
				<screen>
paul@laika:~$ file /lib32/libc-2.5.so 
/lib32/libc-2.5.so: ELF 32-bit LSB shared object, Intel 80386, \
version 1 (SYSV), for GNU/Linux 2.6.0, stripped
paul@laika:~$ file /lib64/libcap.so.1.10 
/lib64/libcap.so.1.10: ELF 64-bit LSB shared object, AMD x86-64, \
version 1 (SYSV), stripped
				</screen>
				<para>The ELF <command>Executable and Linkable Format</command> is used in almost every Unix-like operating system since System V.</para>
			</section>
		</section>
		<section><title>/media for Removable Media</title>
			<para>The <command>/media</command> directory serves as a mount point for removable media, meaning devices such as CD-ROM's, digital cameras and various usb-attached devices. Since <command>/media</command> is rather new in the Unix world, you could very well encounter systems running without this directory. Solaris 9 does not have it, Solaris 10 does.</para>
			<screen>
paul@laika:~$ ls /media/
cdrom  cdrom0  usbdisk
			</screen>
		</section>
		<section><title>/mnt standard mount point</title>
			<para>Older Unixes (and Linuxes) used to mount all kind of stuff under /mnt/something/. According to the FHS, <command>/mnt</command> should only be used to temporarily mount something. But you will most likely witness a lot of systems with more than one directory underneath /mnt used as a mountpoint for various local and remote filesystems.</para>
		</section>
		<section><title>/opt Optional software</title>
			<para>Most of my systems today have an empty <command>/opt</command> directory. It is considered outdated, but you might find some systems with add-on software installed in /opt. If that is the case, the package should install all its files in the typical bin, lib, etc subdirectories in /opt/$packagename/. If for example the package is called wp, then it installs in /opt/wp, putting binaries in /opt/wp/bin and manpages in /opt/wp/man. Most of the default software which comes along with the distribution, will not be installed in /opt.</para>
		</section>
		<section><title>/proc conversation with the kernel</title>
		<para><command>/proc</command> is another special directory, appearing to be ordinary files, but not taking up diskspace. It is actually a view on the kernel, or better on what the kernel sees, and a means to talk to the kernel directly. <command>/proc</command> is a proc filesystem.</para>
			<screen>
paul@RHELv4u4:~$ mount -t proc
none on /proc type proc (rw)
			</screen>
			<para>When listing the /proc directory, you will see a lot of numbers (on any Unix), and some interesting files (on Linux)</para>
			<screen>
paul@laika:~$ ls /proc
1      2086  4548  5124  5692  6049  6128  8199         fs          self
10     2096  4550  5142  5727  6051  6198  8286         ide         slabinfo
11     2097  4553  5143  5741  6054  6208  8747         interrupts  stat
13830  2123  4554  5159  5808  6056  6243  8753         iomem       swaps
13844  2260  4555  5172  5822  6063  6247  8848         ioports     sys
13845  2261  4853  5173  5827  6064  6251  9            irq         sysrq-trigger
13870  2546  4954  5231  5852  6068  6359  acpi         kallsyms    sysvipc
13891  2746  5     5232  5945  6071  6362  asound       kcore       tty
153    3     5008  5237  5946  6077  6363  buddyinfo    key-users   uptime
17178  35    5010  5242  5947  6080  6476  bus          kmsg        version
17361  36    5035  5356  5948  6082  7     cmdline      loadavg     version_sig
183    37    5051  5386  5949  6085  7068  cpuinfo      locks       vmcore
184    3754  5052  5442  5982  6086  7148  crypto       meminfo     vmnet
185    3757  5058  5484  5984  6090  7151  devices      misc        vmstat
186    38    5059  5485  6     6092  7156  diskstats    modules     zoneinfo
187    3990  5066  5571  6003  6093  7159  dma          mounts
2      4     5079  5599  6004  6094  7161  driver       mtrr
2061   4025  5084  5600  6005  6111  7168  execdomains  net
2084   4325  5091  5621  6045  6118  8     fb           partitions
2085   4547  5109  5665  6048  6125  818   filesystems  scsi

			</screen>
			<para>Let's investigate the file properties inside /proc. Looking at the date and time will display the current date and time, meaning the files are constantly updated (A view on the kernel).</para>
			<screen>
paul@RHELv4u4:~$ date
Mon Jan 29 18:06:32 EST 2007
paul@RHELv4u4:~$ ls -al /proc/cpuinfo 
-r--r--r--  1 root root 0 Jan 29 18:06 /proc/cpuinfo
paul@RHELv4u4:~$ 
paul@RHELv4u4:~$  ...time passes...
paul@RHELv4u4:~$ 
paul@RHELv4u4:~$ date
Mon Jan 29 18:10:00 EST 2007
paul@RHELv4u4:~$ ls -al /proc/cpuinfo 
-r--r--r--  1 root root 0 Jan 29 18:10 /proc/cpuinfo
			</screen>
			<para>Most files in /proc are 0 bytes, yet they contain data, sometimes a lot of data. You can see this by executing cat on files like <command>/proc/cpuinfo</command>, which contains information on the CPU. </para>
			<screen>
paul@RHELv4u4:~$ file /proc/cpuinfo 
/proc/cpuinfo: empty
paul@RHELv4u4:~$ cat /proc/cpuinfo 
processor       : 0
vendor_id       : AuthenticAMD
cpu family      : 15
model           : 43
model name      : AMD Athlon(tm) 64 X2 Dual Core Processor 4600+
stepping        : 1
cpu MHz         : 2398.628
cache size      : 512 KB
fdiv_bug        : no
hlt_bug         : no
f00f_bug        : no
coma_bug        : no
fpu             : yes
fpu_exception   : yes
cpuid level     : 1
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat
bogomips        : 4803.54
			</screen>
			<para><emphasis>Just for fun, here is /proc/cpuinfo on a Sun Sunblade 1000...</emphasis></para>
			<screen>
paul@pasha:~$ cat /proc/cpuinfo
cpu : TI UltraSparc III (Cheetah)
fpu : UltraSparc III integrated FPU
promlib : Version 3 Revision 2
prom : 4.2.2
type : sun4u
ncpus probed : 2
ncpus active : 2
Cpu0Bogo : 498.68
Cpu0ClkTck : 000000002cb41780
Cpu1Bogo : 498.68
Cpu1ClkTck : 000000002cb41780
MMU Type : Cheetah
State:
CPU0: online
CPU1: online 
			</screen>
			<para><emphasis>... and on a Sony Playstation 3.</emphasis></para>
			<screen>
[root@ps3 tmp]# uname -a
Linux ps3 2.6.20-rc5-dirty #58 SMP Thu Jan 18 13:35:01 CET 2007 ppc64 ppc64
ppc64 GNU/Linux
[root@ps3 tmp]# cat /proc/cpuinfo
processor       : 0
cpu             : Cell Broadband Engine, altivec supported
clock           : 3192.000000MHz
revision        : 5.1 (pvr 0070 0501)

processor       : 1
cpu             : Cell Broadband Engine, altivec supported
clock           : 3192.000000MHz
revision        : 5.1 (pvr 0070 0501)

timebase        : 79800000
platform        : PS3
machine         : PS3 
			</screen>
			<para>Most of the files in /proc are read only, some require root privileges. But some files are writable, a lot of files in <command>/proc/sys</command> are writable. Let's discuss some of the files in /proc.</para>
			<section><title>/proc/cmdline</title>
				<para>The parameters that were passed to the kernel at boot time are in <command>/proc/cmdline</command>.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/cmdline 
ro root=/dev/VolGroup00/LogVol00 rhgb quiet
				</screen>
			</section>
			<section><title>/proc/filesystems</title>
				<para>The <command>/proc/filesystems</command> file displays a list of supported file systems. When you mount a file system without explicitly defining one, then mount will first try to probe <command>/etc/filesystems</command> and then probe <command>/proc/filesystems</command> for all the filesystems in there without the <command>nodev</command> label. If /etc/filesystems ends with a line containing nothing but a *, then both files are probed.</para> 
				<screen>
paul@RHELv4u4:~$ cat /proc/filesystems 
nodev   sysfs
nodev   rootfs
nodev   bdev
nodev   proc
nodev   sockfs
nodev   binfmt_misc
nodev   usbfs
nodev   usbdevfs
nodev   futexfs
nodev   tmpfs
nodev   pipefs
nodev   eventpollfs
nodev   devpts
        ext2
nodev   ramfs
nodev   hugetlbfs
        iso9660
nodev   relayfs
nodev   mqueue
nodev   selinuxfs
        ext3
nodev   rpc_pipefs
nodev   vmware-hgfs
nodev   autofs
paul@RHELv4u4:~$
				</screen>
			</section>
			<section><title>/proc/interrupts</title>
				<para>On the x86 architecture, this file displays the interrupts.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/interrupts 
           CPU0       
  0:   13876877    IO-APIC-edge  timer
  1:         15    IO-APIC-edge  i8042
  8:          1    IO-APIC-edge  rtc
  9:          0   IO-APIC-level  acpi
 12:         67    IO-APIC-edge  i8042
 14:        128    IO-APIC-edge  ide0
 15:     124320    IO-APIC-edge  ide1
169:     111993   IO-APIC-level  ioc0
177:       2428   IO-APIC-level  eth0
NMI:          0 
LOC:   13878037 
ERR:          0
MIS:          0
paul@RHELv4u4:~$ 
				</screen>
				<para>On a machine with two CPU's, the file looks like this.</para>
				<screen>
paul@laika:~$ cat /proc/interrupts 
           CPU0       CPU1       
  0:     860013          0   IO-APIC-edge      timer
  1:       4533          0   IO-APIC-edge      i8042
  7:          0          0   IO-APIC-edge      parport0
  8:    6588227          0   IO-APIC-edge      rtc
 10:       2314          0   IO-APIC-fasteoi   acpi
 12:        133          0   IO-APIC-edge      i8042
 14:          0          0   IO-APIC-edge      libata
 15:      72269          0   IO-APIC-edge      libata
 18:          1          0   IO-APIC-fasteoi   yenta
 19:     115036          0   IO-APIC-fasteoi   eth0
 20:     126871          0   IO-APIC-fasteoi   libata, ohci1394
 21:      30204          0   IO-APIC-fasteoi   ehci_hcd:usb1, uhci_hcd:usb2
 22:       1334          0   IO-APIC-fasteoi   saa7133[0], saa7133[0]
 24:     234739          0   IO-APIC-fasteoi   nvidia
NMI:         72         42 
LOC:     860000     859994 
ERR:          0
paul@laika:~$
				</screen>
			</section>
			<section><title>/proc/kcore</title>
				<para>The physical memory is represented in <command>/proc/kcore</command>. Do not try to cat this file, instead use a debugger. The size of /proc/kcore is the same as your physical memory, plus four bytes.</para>
				<screen>
paul@laika:~$ ls -lh /proc/kcore 
-r-------- 1 root root 2.0G 2007-01-30 08:57 /proc/kcore
paul@laika:~$ 
				</screen>
			</section>
			<section><title>/proc/mdstat</title>
				<para>You can obtain RAID information from the kernel by displaying <command>/proc/mdstat</command>. With a RAID configured, it looks like this.</para>
				<screen>
paul@RHELv4u2:~$ cat /proc/mdstat 
Personalities : [raid5] 
md0 : active raid5 sdd1[2] sdc1[1] sdb1[0]
      2088192 blocks level 5, 64k chunk, algorithm 2 [3/3] [UUU]
      
unused devices: &#060;none&#062;
paul@RHELv4u2:~$ 
				</screen>
				<para>When there is no RAID present, the following is displayed.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/mdstat 
Personalities : 
unused devices: &#060;none&#062;
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/meminfo</title>
				<para>You will rarely want to look at <command>/proc/meminfo</command>...</para>
			<screen>
paul@RHELv4u4:~$ cat /proc/meminfo 
MemTotal:       255864 kB
MemFree:          5336 kB
Buffers:         42396 kB
Cached:         159912 kB
SwapCached:          0 kB
Active:         104184 kB
Inactive:       119724 kB
HighTotal:           0 kB
HighFree:            0 kB
LowTotal:       255864 kB
LowFree:          5336 kB
SwapTotal:     1048568 kB
SwapFree:      1048568 kB
Dirty:              40 kB
Writeback:           0 kB
Mapped:          33644 kB
Slab:            21956 kB
CommitLimit:   1176500 kB
Committed_AS:    82984 kB
PageTables:        960 kB
VmallocTotal:   761848 kB
VmallocUsed:      2588 kB
VmallocChunk:   759096 kB
HugePages_Total:     0
HugePages_Free:      0
Hugepagesize:     4096 kB
				</screen>
				<para> ...since the <command>free</command> command displays the same information in a more user friendly output.</para>
				<screen>
paul@RHELv4u4:~$ free -om
             total       used       free     shared    buffers     cached
Mem:           249        244          5          0         41        156
Swap:         1023          0       1023
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/modules</title>
				<para><command>/proc/modules</command> lists all modules loaded by the kernel. The output would be too long to display here, so lets <command>grep</command> for a few. First vm (from Vmware), which tells us that vmmon and vmnet are both loaded. You can display the same information with <command>lsmod</command>. </para>
				<screen>
paul@laika:~$ cat /proc/modules | grep vm
vmnet 36896 13 - Live 0xffffffff88b21000 (P)
vmmon 194540 0 - Live 0xffffffff88af0000 (P)
paul@laika:~$ lsmod | grep vm
vmnet                  36896  13 
vmmon                 194540  0 
paul@laika:~$ 
				</screen>
				<para>Some modules depend on others. In the following example, you can see that the nfsd module is used by exportfs, lockd and sunrpc. </para>
				<screen>
paul@laika:~$ cat /proc/modules | grep nfsd
nfsd 267432 17 - Live 0xffffffff88a40000
exportfs 7808 1 nfsd, Live 0xffffffff88a3d000
lockd 73520 3 nfs,nfsd, Live 0xffffffff88a2a000
sunrpc 185032 12 nfs,nfsd,lockd, Live 0xffffffff889fb000
paul@laika:~$ lsmod | grep nfsd
nfsd                  267432  17 
exportfs                7808  1 nfsd
lockd                  73520  3 nfs,nfsd
sunrpc                185032  12 nfs,nfsd,lockd
paul@laika:~$ 
				</screen>
			</section>
			<section><title>/proc/mounts</title>
				<para>Like the <command>mount</command> command and the <command>/etc/mtab</command> file, <command>/proc/mounts</command> lists all the mounted file systems. But /proc/mounts displays what the kernel sees, so it is always up to date and correct. You see the device, mount point, file system, read-only or read-write and two zero's.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/mounts 
rootfs / rootfs rw 0 0
/proc /proc proc rw,nodiratime 0 0
none /dev tmpfs rw 0 0
/dev/root / ext3 rw 0 0
none /dev tmpfs rw 0 0
none /selinux selinuxfs rw 0 0
/proc /proc proc rw,nodiratime 0 0
/proc/bus/usb /proc/bus/usb usbfs rw 0 0
/sys /sys sysfs rw 0 0
none /dev/pts devpts rw 0 0
/dev/sda1 /boot ext3 rw 0 0
none /dev/shm tmpfs rw 0 0
none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0
sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw 0 0
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/partitions</title>
				<para>The <command>/proc/partitions</command> file contains a table with major and minor number of partitioned devices, their number of blocks and the device name in <command>/dev</command>. Verify with <command>/proc/devices</command> to link the major number to the proper device.</para>
				<screen>
paul@RHELv4u4:~$ cat /proc/partitions 
major minor  #blocks  name

   3     0     524288 hda
   3    64     734003 hdb
   8     0    8388608 sda
   8     1     104391 sda1
   8     2    8281507 sda2
   8    16    1048576 sdb
   8    32    1048576 sdc
   8    48    1048576 sdd
 253     0    7176192 dm-0
 253     1    1048576 dm-1
paul@RHELv4u4:~$ 
				</screen>
			</section>
			<section><title>/proc/swaps</title>
				<para>You can find information about <command>swap partition(s)</command> in <command>/proc/swaps</command>.</para>
				<screen>paul@RHELv4u4:~$ cat /proc/swaps 
Filename                                Type            Size    Used    Priority
/dev/mapper/VolGroup00-LogVol01         partition       1048568 0       -1
paul@RHELv4u4:~$ 
				</screen>
			</section>
		</section>
		<section><title>/root the superuser's home</title>
			<para>On many systems, <command>/root</command> is the default location for the root user's personal data and profile. If it does not exist by default, then some administrators create it. </para>
		</section>
		<section><title>/sbin system binaries</title>
			<para>Similar to /bin, but mainly for booting and for tools to configure the system. A lot of the system binaries will require root privileges for certain tasks. You will also find a <command>/sbin</command> subdirectory in other directories.</para>
		</section>
		<section><title>/srv served by your system</title>
			<para>You may find <command>/srv</command> to be empty on many systems, but not for long. The FHS suggests locating cvs, rsync, ftp and www data to this location. The FHS also approves administrative naming in /srv, like /srv/project55/ftp and /srv/sales/www. Red Hat plans to move some data that is currently located in /var to /srv. </para>
		</section>
		<section><title>/sys Linux 2.6 hot plugging</title>
			<para>The <command>/sys</command> directory is created for the Linux 2.6 kernel. Since 2.6, Linux uses <command>sysfs</command> to support <command>usb</command> and <command>IEEE 1394</command> (aka <command>FireWire</command>) hot plug devices. See the manual pages of udev(8) (the successor of <command>devfs</command>) and hotplug(8) for more info (Or visit http://linux-hotplug.sourceforge.net/ ).</para>
		<screen>
paul@RHELv4u4:~$ ls /sys/*
/sys/block:
dm-0  fd0  hdb  md0   ram1   ram11  ram13  ram15  ram3  ram5  ram7  ram9  sdb  
dm-1  hda  hdc  ram0  ram10  ram12  ram14  ram2   ram4  ram6  ram8  sda   sdc

/sys/bus:
i2c  ide  pci  platform  pnp  scsi  serio  usb

/sys/class:
firmware  i2c-adapter  input  misc  netlink  printer  scsi_device  tty  usb_host
graphics  i2c-dev      mem    net   pci_bus  raw      scsi_host    usb  vc

/sys/devices:
pci0000:00  platform  system

/sys/firmware:
acpi

/sys/module:
ac       dm_mirror    ext3      ip_conntrack    ipt_state  md5      mptsas    
autofs4  dm_mod       floppy    iptable_filter  ipv6       mii      mptscsi   
battery  dm_snapshot  i2c_core  ip_tables       jbd        mptbase  mptscsih  
button   dm_zero      i2c_dev   ipt_REJECT      lp         mptfc    mptspi    

/sys/power:
state
paul@RHELv4u4:~$
		</screen>
		</section>
		<section><title>/tmp for temporary files</title>
			<para>When applications (or Users) need to store temporary data, they should use <command>/tmp</command>. /tmp might take up diskspace, then again, it might also not (as in being mounted inside RAM memory). In any case, files in /tmp can be cleared by the operating system. Never use /tmp to store data that you want to archive.</para>
		</section>
		<section><title>/usr Unix System Resources</title>
			<para>Although <command>/usr</command> is pronounced like user, never forget that it stands for Unix System Resources. The /usr hierarchy should contain <command>sharable, read only</command> data. Some people even choose to mount /usr as read only. This can be done from its own partition, or from a read only NFS share.</para>
		</section>
		<section><title>/var variable data</title>
			<para>Data that is unpredictable in size, such as log files (<command>/var/log</command>), print spool directories (<command>/var/spool</command>) and various caches (<command>/var/cache</command>) should be located in <command>/var</command>. But /var is much more than that, it contains Process ID files in <command>/var/run</command> and temporary files that survive a reboot in <command>/var/tmp</command>. There will be more examples of /var usage further in this book.</para>
			<section><title>/var/lib/rpm</title>
				<para>Red Hat Enterprise Linux keeps files pertaining to <command>RPM</command> in <command>/var/lib/rpm/</command>.</para>
			</section>
			<section><title>/var/spool/up2date</title>
				<para>The <command>Red Hat Update Agent</command> uses files in <command>/var/spool/up2date</command>. This location is also used when files are downloaded from the <command>Red Hat Network</command>.</para>
			</section>
		</section>
	</section>
	<section><title>Working with directories</title>
		<para>It is one thing to know the structure of the Unix filetree, it is another to walk around in it. To explore the filesystem, you will need some tools. Here's a small overview of the most common commands, available on any Unix or Linux system. </para>
		<section><title>pwd</title>
			<para>The <command>you are here</command> sign can be displayed with the <command>pwd</command> command (Print Working Directory). Go ahead, try it: open a commandline interface (like gnome-terminal or an xterm) and type <command>pwd</command>. The tool displays your <command>current directory</command>.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
			</screen>
		</section>
		<section><title>cd</title>
			<para>You can change your current directory with the <command>cd</command> command (Change Directory). </para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd /bin
paul@laika$ pwd
/bin
paul@laika$ cd /boot/grub
paul@laika$ pwd
/boot/grub
paul@laika$ cd /home/paul/
paul@laika$ pwd
/home/paul
			</screen>
			<para>You can pull off a trick with cd. Just typing <command>cd</command> without a target directory, will put you in your home directory. Typing <command>cd ~</command> has the same effect.</para>
			<screen>
paul@laika$ cd /etc
paul@laika$ pwd
/etc
paul@laika$ cd
paul@laika$ pwd
/home/paul
paul@laika$ cd ~
paul@laika$ pwd
/home/paul
			</screen>
			<para>To go to the <command>parent directory</command> (the one just above your current directory in the directory tree), type <command>cd ..</command> . <emphasis>To stay in the current directory, type <command>cd .</command> ;-)</emphasis></para>
			<screen>
paul@laika:/usr/share/games/wesnoth$ pwd
/usr/share/games/wesnoth
paul@laika:/usr/share/games/wesnoth$ cd ..
paul@laika:/usr/share/games$ pwd
/usr/share/games
paul@laika:/usr/share/games$ cd ..
paul@laika:/usr/share$ cd ..
paul@laika:/usr$ cd ..
paul@laika:/$ pwd
/
paul@laika:/$ 
			</screen>
			<para>Another useful shortcut with cd is to just type <command>cd -</command> to go to the previous directory.</para>
			<screen>
paul@laika:~$ pwd
/home/paul
paul@laika:~$ cd /etc
paul@laika:/etc$ pwd
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ cd -
/etc
paul@laika:/etc$ cd -
/home/paul
paul@laika:~$ 			</screen>
			<para>You should be aware of <command>absolute and relative paths</command> in the filetree. When you type a path starting with a slash, then the root of the filetree is assumed. If you don't start your path with a slash, then the current directory is the assumed starting point. The screenshot below first shows the current directory (/home/paul). From within this directory, you have to type <command>cd /home</command> instead of <command>cd home</command> to go to the /home directory. When inside /home, you have to type <command>cd paul</command> instead of <command>cd /paul</command> to enter the subdirectory paul of the current directory /home.</para>
			<screen>
paul@laika$ pwd
/home/paul
paul@laika$ cd home
bash: cd: home: No such file or directory
paul@laika$ cd /home
paul@laika$ pwd
/home
paul@laika$ cd /paul
bash: cd: /paul: No such file or directory
paul@laika$ cd paul
paul@laika$ pwd
/home/paul
paul@laika$ 
			</screen>
			<para>In case your current directory is the root directory, then both <command>cd /home</command> and <command>cd home</command> will get you in the /home directory.</para>
			<screen>
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd home
paul@laika$ pwd
/home
paul@laika$ cd /
paul@laika$ pwd
/
paul@laika$ cd /home 
paul@laika$ pwd
/home
			</screen>
			<para>This was the last screenshot with pwd statements. From now on, the current directory will always be displayed in the prompt. We will explain later in this book, how the shell variable $PS1 can be configured to do this.</para>
		</section>

		<section><title>ls</title>
			<para>You can list the contents of a directory with <command>ls</command>. Many times you will be using options with ls to display the contents of the directory in different formats, or to display different parts of the directory. Just typing ls gives you a list of files in the directory.Typing <command>ls -l</command> (that is a letter L, not the number 1) gives you a long listing (more information on the contents).</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -l
total 23992
-rw-r--r-- 1 paul paul 24506857 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul    14744 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul     8189 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul     4096 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul        0 2006-03-30 22:45 summer.txt
			</screen>
			<para>A frequently used option with ls is <command>-a</command> to show all files. All files means including the <command>hidden files</command>. When a filename on a Unix file system starts with a dot, it is considered a hidden file, and it doesn't show up in regular file listings.</para>
			<screen>
paul@pasha:~$ ls
allfiles.txt  dmesg.txt  httpd.conf  stuff  summer.txt
paul@pasha:~$ ls -a
.   allfiles.txt   .bash_profile  dmesg.txt   .lesshst  stuff       .viminfo
..  .bash_history  .bashrc        httpd.conf  .ssh      summer.txt  .Xauthority
paul@pasha:~$ 
			</screen>
			<para>Another frequently used ls option is <command>-h</command>. It shows the numbers (file sizes) in a more human readable format. Also shown below is some variation in the way you can give the options to ls. We will explain the details of the output later in this book!</para>
			<screen>
paul@pasha:~$ ls -l -h
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -lh
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -hl
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
paul@pasha:~$ ls -h -l
total 24M
-rw-r--r-- 1 paul paul  24M 2006-03-30 22:53 allfiles.txt
-rw-r--r-- 1 paul paul  15K 2006-09-27 11:45 dmesg.txt
-rw-r--r-- 1 paul paul 8.0K 2006-03-31 14:01 httpd.conf
drwxr-xr-x 2 paul paul 4.0K 2007-01-08 12:22 stuff
-rw-r--r-- 1 paul paul    0 2006-03-30 22:45 summer.txt
			</screen>
		</section>
		<section><title>mkdir</title>
			<para>Walking around the Unix filetree is fun, but it is even more fun to create your own directories with <command>mkdir</command>. You have to give at least one parameter to <command>mkdir</command>, the name of the new directory to be created. Think before you type a leading / . </para>
			<screen>
paul@laika:~$ mkdir MyDir
paul@laika:~$ cd MyDir
paul@laika:~/MyDir$ ls -al
total 8
drwxr-xr-x  2 paul paul 4096 2007-01-10 21:13 .
drwxr-xr-x 39 paul paul 4096 2007-01-10 21:13 ..
paul@laika:~/MyDir$ mkdir stuff
paul@laika:~/MyDir$ mkdir otherstuff
paul@laika:~/MyDir$ ls -l
total 8
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 otherstuff
drwxr-xr-x 2 paul paul 4096 2007-01-10 21:14 stuff
paul@laika:~/MyDir$ 
			</screen>
			<para>When given the option <command>-p</command>, then mkdir will create parent directories as needed.</para>
			<screen>
paul@laika:~$ mkdir -p MyDir2/MySubdir2/ThreeDeep
paul@laika:~$ ls MyDir2
MySubdir2
paul@laika:~$ ls MyDir2/MySubdir2
ThreeDeep
paul@laika:~$ ls MyDir2/MySubdir2/ThreeDeep/
			</screen>
		</section>
		<section><title>rmdir</title>
			<para>When a directory is empty, you can use <command>rmdir</command> to remove the directory.</para>
			<screen>
paul@laika:~/MyDir$ rmdir otherstuff
paul@laika:~/MyDir$ ls
stuff
paul@laika:~/MyDir$ cd ..
paul@laika:~$ rmdir MyDir
rmdir: MyDir/: Directory not empty
paul@laika:~$ rmdir MyDir/stuff
paul@laika:~$ rmdir MyDir
			</screen>
			<para>And similar to the mkdir -p option, you can also use rmdir to recursively remove directories.</para>
			<screen>
paul@laika:~$ mkdir -p dir/subdir/subdir2
paul@laika:~$ rmdir -p dir/subdir/subdir2
paul@laika:~$ 	
			</screen>
		</section>
		<section><title>pushd and popd</title>
			<para><emphasis>These two commands are not essential, if you think there are too many commands to remember, then you are allowed to forget about these two.</emphasis></para>
			<para>Some administrators find it useful to work with <command>pushd</command> and <command>popd</command>. Both commands work with a common stack of previous directories. Pushd adds a directory to the stack and changes to a new current directory, popd removes a directory from the stack and sets the current directory.</para>
			<screen>
paul@laika:/etc$ cd /bin
paul@laika:/bin$ pushd /lib
/lib /bin
paul@laika:/lib$ pushd /proc
/proc /lib /bin
paul@laika:/proc$ 
paul@laika:/proc$ popd 
/lib /bin
paul@laika:/lib$ 
paul@laika:/lib$ 
paul@laika:/lib$ popd
/bin
paul@laika:/bin$ 
			</screen>
		</section>
		<section><title>Practice: Working with directories</title>
			<para>1. Display your current directory.</para>
			<para>2. Change to the /etc directory.</para>
			<para>3. Now change to your home directory using only three key presses.</para>
			<para>4. Change to the /boot/grub directory using only eleven key presses.</para>
			<para>5. Go to the parent directory of the current directory.</para>
			<para>6. Go to the root directory.</para>
			<para>7. List the contents of the root directory.</para>
			<para>8. List a long listing of the root directory.</para>
			<para>9. Stay where you are, and list the contents of /etc.</para>
			<para>10. Stay where you are, and list the contents of /bin and /sbin.</para>
			<para>11. Stay where you are, and list the contents of &#126;.</para>
			<para>12. List all the files (including hidden files) in your homedirectory.</para>
			<para>13. List the files in /boot in a human readable format.</para>
			<para>14. Create a directory testdir in your homedirectory.</para>
			<para>15. Change to the /etc directory, stay here and create a directory newdir in your homedirectory.</para>
			<para>16. Create in one command the directories ~/dir1/dir2/dir3 (dir3 is a subdirectory from dir2, and dir2 is a subdirectory from dir1 ).</para>
			<para>17. Remove the directory testdir.</para>
			<para>18. If time permits (or if you are waiting for other students to finish this practice), use and understand pushd and popd. Use the man page of bash to find information about pushd, popd and dirs.</para>
			<para></para>
			<para></para>	
		</section>
	</section>
	<section><title>Working with files</title>
		<section><title>file</title>
			<para>The <command>file</command> utility determines the file type. Unlike some other desktop operating system, Unix does not use extensions to determine the file type. Your editor does not care whether a file ends in .TXT or .DOC. As a system administrator, you should use the <command>file</command> command to determine the file type. First some examples on a typical Linux system.</para>
			<screen>
paul@laika:~$ file Desktop/Screenshot.png 
Desktop/Screenshot.png: PNG image data, 3840 x 1200, 8-bit/color RGBA, non-inter\
laced
paul@laika:~$ file /bin/cat
/bin/cat: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux\
2.6.0, dynamically linked (uses shared libs), for GNU/Linux 2.6.0, stripped
paul@laika:~$ file /etc/passwd
/etc/passwd: ASCII text
paul@laika:~$ file HelloWorld.c 
HelloWorld.c: ASCII C program text
			</screen>
			<para>Here's another example of the file utility. It shows the different type of binaries on different architectures.</para>
			<screen>
# Solaris 9 on Intel
bash-2.05$ file /bin/date
/bin/date:      ELF 32-bit LSB executable 80386 Version 1, dynamically linked, s\
tripped

# Ubuntu Linux on AMD64
paul@laika:~$ file /bin/date 
/bin/date: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linu\
x 2.6.0, dynamically linked (uses shared libs), for GNU/Linux 2.6.0, stripped

# Debian Sarge on SPARC
paul@pasha:~$ file /bin/date 
/bin/date: ELF 32-bit MSB executable, SPARC, version 1 (SYSV), for GNU/Linux 2.4\
.1, dynamically linked (uses shared libs), for GNU/Linux 2.4.1, stripped
			</screen>
		</section>
		<section><title>touch</title>
			<para>One easy way to create a file is with <command>touch</command>. (We will see many other creative avenues for spawning files later in this book.)</para>
			<screen>
paul@laika:~/test$ touch file1
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
paul@laika:~/test$ touch file2
paul@laika:~/test$ touch file555
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file1
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file2
-rw-r--r-- 1 paul paul 0 2007-01-10 21:40 file555
			</screen>
			<para>Of course, touch can do more than just create files. Can you find out what by looking at the next screenshot ? If not, check the manual of touch.</para>
			<screen>
paul@laika:~/test$ touch -t 200505050000 SinkoDeMayo
paul@laika:~/test$ touch -t 130207111630 BigBattle
paul@laika:~/test$ ls -l
total 0
-rw-r--r-- 1 paul paul 0 1302-07-11 16:30 BigBattle
-rw-r--r-- 1 paul paul 0 2005-05-05 00:00 SinkoDeMayo
			</screen>
		</section>
		<section><title>rm</title>
			<para>When you no longer need a file, use <command>rm</command> to remove it. Unlike some graphical user interfaces, the command line in general does not have a <emphasis>waste bin</emphasis> or <emphasis>trashcan</emphasis> to recover files. When you use rm to remove a file, the file is gone. So be careful before removing files! </para>
			<screen>
paul@laika:~/test$ ls
BigBattle  SinkoDeMayo
paul@laika:~/test$ rm BigBattle 
paul@laika:~/test$ ls
SinkoDeMayo
			</screen>
			<para>By default, rm will not remove non-empty directories. However rm accepts several options that will allow you to remove any directory. The <command>rm -rf</command> statement is famous because it will erase anything (providing that you have the permissions to do so). When you are logged on as root, be very careful with <command>rm -rf</command>, because being root implies that permissions don't apply to you, so you can literally erase your entire system by accident.</para>
			<screen>
paul@laika:~$ ls test
SinkoDeMayo
paul@laika:~$ rm test
rm: cannot remove `test': Is a directory
paul@laika:~$ rm -rf test
paul@laika:~$ ls test
ls: test: No such file or directory
			</screen>
		</section>
		<section><title>cp</title>
			<para>To copy a file, use <command>cp</command> with a source and a target argument. If the target is a directory, then the sourcefiles are copied in that target directory.</para>
			<screen>
paul@laika:~/test$ touch FileA
paul@laika:~/test$ ls
FileA
paul@laika:~/test$ cp FileA FileB
paul@laika:~/test$ ls
FileA  FileB
paul@laika:~/test$ mkdir MyDir
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ cp FileA MyDir/
paul@laika:~/test$ ls MyDir/
FileA
			</screen>
			<para>To copy complete directories, use <command>cp -r</command>.</para>
			<screen>
paul@laika:~/test$ ls
FileA  FileB  MyDir
paul@laika:~/test$ ls MyDir/
FileA
paul@laika:~/test$ cp -r MyDir MyDirB
paul@laika:~/test$ ls
FileA  FileB  MyDir  MyDirB
paul@laika:~/test$ ls MyDirB
FileA
			</screen>
			<para>You can also use cp to copy multiple file into a directory. In that case, the last argument (aka the target) must be a directory.</para>
			<screen>
paul@laika:~/test$ cp fire water
paul@laika:~/test$ cp -i fire water
cp: overwrite `water'? no
paul@laika:~/test$
			</screen>
			<screen>cp file1 file2 dir1/file3 dir1/file55 dir2</screen>
			<para>To prevent cp from overwriting existing files, use the -i (for interacgtive) option.</para>
		</section>
		<section><title>mv</title>
			<para>Use <command>mv</command> to rename a file, or to move the file to another directory.</para>
			<screen>
paul@laika:~/test$ touch file100
paul@laika:~/test$ ls
file100
paul@laika:~/test$ mv file100 ABC.txt
paul@laika:~/test$ ls
ABC.txt
paul@laika:~/test$
			</screen>
			<para>The <command>rename</command> command can also be used, but it has a more complex syntax to enable renaming of many files at once. Below two examples, the first switches all occurrences of txt in png for all filenames ending in .txt. The second example switches all occurrences of uppercase ABC in lowercase abc for all filenames ending in .png . The following syntax will work on debian and ubuntu.</para>
			<screen>
paul@laika:~/test$ ls
123.txt  ABC.txt
paul@laika:~/test$ rename 's/txt/png/' *.txt
paul@laika:~/test$ ls
123.png  ABC.png
paul@laika:~/test$ rename 's/ABC/abc/' *.png
paul@laika:~/test$ ls
123.png  abc.png
paul@laika:~/test$ 
			</screen>
			<para>On Red Hat Enterprise Linux, the syntax of rename is a bit different. The first example below renames all *.conf files, replace any occurrence of conf with bak. The second example renames all(*) files, replacing one with ONE.</para>
			<screen>
[paul@RHEL4a test]$ ls
one.conf  two.conf
[paul@RHEL4a test]$ rename conf bak *.conf
[paul@RHEL4a test]$ ls
one.bak  two.bak
[paul@RHEL4a test]$ rename one ONE *
[paul@RHEL4a test]$ ls
ONE.bak  two.bak
[paul@RHEL4a test]$ 
			</screen>
		</section>
		<section><title>Practice: Working with files</title>
			<para>1. List the files in the /bin directory</para>
			<para>2. Display the type of file of /bin/cat, /etc/passwd and /usr/bin/passwd.</para>
			<para>3a. Download wolf.jpg from http://cobbaut.be (wget http://cobbaut.be/wolf.jpg)</para>
			<para>3b. Display the type of file of wolf.jpg</para>
			<para>3c. Rename the file to wolf.pdf</para>
			<para>3d. Display the type of file of wolf.pdf</para>
			<para>4. Create a directory &#126;/touched and enter it.</para>
			<para>5. Create the files today.txt and yesterday.txt in touched.</para>
			<para>6. Change the date on yesterday.txt to match yesterday's date.</para>
			<para>7. Copy yesterday.txt to copy.yesterday.txt</para>
			<para>8. Rename copy.yesterday.txt to kim</para>
			<para>9. Create a directory called &#126;/testbackup and copy all files from &#126;/touched in it.</para>
			<para>10. Use one command to remove the directory &#126;/testbackup and all files in it.</para>
			<para>11. Create a directory &#126;/etcbackup and copy all *.conf files from /etc in it. Did you include all subdirectories of /etc ?</para>
			<para>12. Use rename to rename all *.BAK files to *.BACKUP. (if you have a debian and red hat derived distro available, try it on both!)</para>
			<para></para>
			<para></para>
		</section>
	</section>
	<section><title>File contents</title>
		<section><title>head</title>
			<para>You can use <command>head</command> to display the first ten lines of a file.</para>
			<screen>
paul@laika:~$ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
paul@laika:~$ 
			</screen>
			<para>The head command has some options for displaying the first n lines of a file.</para>
			<screen>
paul@laika:~$ head -4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
			</screen>
			<para>Head can also display the first n bytes.</para>
			<screen>
paul@laika:~$ head -c4 /etc/passwd
rootpaul@laika:~$
			</screen>		
		</section>
		<section><title>tail</title>
			<para>Similar to head, the <command>tail</command> command will display the last ten lines of a file.</para>
			<screen>
paul@laika:~$ tail /etc/services 
vboxd           20012/udp
binkp           24554/tcp             # binkp fidonet protocol
asp             27374/tcp             # Address Search Protocol
asp             27374/udp
csync2          30865/tcp             # cluster synchronization tool
dircproxy       57000/tcp             # Detachable IRC Proxy
tfido           60177/tcp             # fidonet EMSI over telnet
fido            60179/tcp             # fidonet EMSI over TCP

# Local services
paul@laika:~$
			</screen>
			<para>The tail command has many options, we will use some of them during this course.</para>
		</section>
		<section><title>cat</title>
			<para>The <command>cat</command> command is one of the most universal tools. All it does is copying standard input to standard output, but in combination with the shell, this can be very powerful and diverse. Some examples will give a glimpse of the possibilities. The first example is simple, you can use cat to display a file on the screen. If the file is longer than the screen, it will scroll by until the end.</para>
			<screen>
paul@laika:~$ cat /etc/resolv.conf
nameserver 194.7.1.4
paul@laika:~$
			</screen>
			<para>You can use cat to create files with one or more lines of text. Just type the command as is shown in the screenshot below. Then type one or more lines, finish each line with the enter key. After the last line, type and hold the Control (Ctrl) key and press d. The <command>Ctrl d</command> key combination will send an EOF (End of File) to the running process, this will end the cat command.</para>
			<screen>
paul@laika:~/test$ cat > winter.txt
It is very cold today!
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$
			</screen>
			<para>You can actually choose this end marker for cat with <command>&#060;&#060;</command> as is shown in this screenshot.</para>
			<screen>
paul@laika:~/test$ cat &#062; hot.txt &#060;&#060;stop
&#062; It is hot today!
&#062; Yes it is summer.
&#062; stop
paul@laika:~/test$ cat hot.txt 
It is hot today!
Yes it is summer.
paul@laika:~/test$ 
			</screen>
			<para>In the third example you will see that cat can be used to copy files. We will explain in detail what happens here in the bash shell chapter.</para>
			<screen>
paul@laika:~/test$ cat winter.txt 
It is very cold today!
paul@laika:~/test$ cat winter.txt > cold.txt
paul@laika:~/test$ cat cold.txt 
It is very cold today!
paul@laika:~/test$
			</screen>		
		</section>
		<section><title>tac</title>
			<para>Just one example will show you the purpose of tac (as the opposite of cat).</para>
			<screen>
paul@laika:~/test$ cat count 
one
two
three
four
paul@laika:~/test$ tac count 
four
three
two
one
paul@laika:~/test$
			</screen>
		</section>
		<section><title>more and less</title>
			<para>The <command>more</command> command is useful for displaying files that take up more than one screen. More will allow you to see the contents of the file page by page. You can use the spacebar to see the next page, or q to quit more. Some people prefere the <command>less</command> command instead of more.</para>
		</section>
		<section><title>strings</title>
			<para>With the <command>strings</command> command you can display readable ascii strings found in (binary) files. This example locates the ls binary, and then displays readable strings in the binary file (output is truncated).</para>
			<screen>
paul@laika:~$ which ls
/bin/ls
paul@laika:~$ strings /bin/ls
/lib/ld-linux.so.2
librt.so.1
__gmon_start__
_Jv_RegisterClasses
clock_gettime
libacl.so.1
...
			</screen>
		</section>
		<section><title>split</title>
			<para>The <command>split</command> command is useful to split files into smaller file. This can be useful to fit the file onto multiple instances of a medium too small to contain the complete file. In the example below, a file of size 5000 bytes is split into three smaller files, with maximum 2000 bytes each.</para>
			<screen>
paul@laika:~/test$ ls -l
total 8
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
paul@laika:~/test$ split -b 2000 bigfile1 splitfile.
paul@laika:~/test$ ls -l
total 20
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
			</screen>
			<para>In a similar example below the file is split into max 800 bytes parts.</para>
			<screen>
paul@laika:~/test$ split -b 800 bigfile1 size800.
paul@laika:~/test$ ls -l
total 48
-rw-r--r-- 1 paul paul 5000 2007-09-09 20:46 bigfile1
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.aa
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ab
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ac
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ad
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.ae
-rw-r--r-- 1 paul paul  800 2007-09-09 20:48 size800.af
-rw-r--r-- 1 paul paul  200 2007-09-09 20:48 size800.ag
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.aa
-rw-r--r-- 1 paul paul 2000 2007-09-09 20:47 splitfile.ab
-rw-r--r-- 1 paul paul 1000 2007-09-09 20:47 splitfile.ac
paul@laika:~/test$ 
			</screen>
		</section>
		<section><title>Practice: File contents</title>
			<para>1. Display the first 12 lines of /etc/X11/xorg.conf.</para>
			<para>2. Display the last line of /etc/passwd.</para>
			<para>3. Use cat to create a file named count.txt that looks like this:</para>
			<screen>
One
Two
Three
Four
Five
			</screen>
			<para>4. Use cp to make a backup of this file to cnt.txt.</para>
			<para>5. Use cat to make a backup of this file to catcnt.txt</para>
			<para>6. Display catcnt.txt, but with all lines in reverse order (the last line first).</para>
			<para>7. Use more to display /var/log/messages.</para>
			<para>8. Display the readable character strings from the passwd command.</para>
			<para>9. Use ls to find the biggest file in /etc. Make a testsplit directory in your home directory. Copy this biggest file to your ~/testsplit and name it biggest. Then split this file in smaller 200 bytes parts.</para>	
		</section>
		<section><title>Solution</title>
			<para>9. ls -lrS /etc</para>
			<para>mkdir ~/testsplit</para>
			<para>cp /etc/bash_completion ~/testsplit/biggest</para>
			<para>split -b 200 biggest parts</para>
		</section>
	</section>
</chapter>
<chapter><title>Bash, the default Red Hat shell</title>
	<para>The command line interface used on most Linux systems is <command>bash</command>, which stands for <command>Bourne again shell</command>. Bash incorporates features from <command>sh</command> (the original Bourne shell), <command>csh</command> (the C shell) and <command>ksh</command> (the Korn shell). The manual page of bash contains more than one hundred pages. Bash is important, because every command on your linux system is processed by bash after you type it, before it is executed.</para>
	<para>Not all commands are external to the shell, some are built-in. To find out whether a command given to the shell will be executed as an <command>external shell command</command> or as a <command>shell built-in command</command>, use the (external) <command>which</command> command. In the screenshot below, it looks like cd is built-in, and ls cp rm mv mkdir pwd file and rename are external.</para> 
	<screen>
[root@RHEL4b ~]# which ls cp rm mv cd mkdir pwd file rename which
/bin/cp
/bin/ls
/bin/mv
/bin/rm
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:...
/bin/mkdir
/bin/pwd
/usr/bin/file
/usr/bin/rename
/usr/bin/which
[root@RHEL4b ~]# 	</screen>
	<section><title>Shell Expansion</title>
		<para>One of the primary features of a shell is to perform a <command>command line scan</command>. When you enter a command on the shell's command prompt, and press the enter key, then the shell will start scanning that line. After the shell has finished scanning that line, the line will be executed. Shell expansion is influenced by the following topics (more will follow later) : control operators, white space removal, filename generation, variables, escaping, embedding and shell aliases.</para>
		<section><title>Control Operators</title>
			<para>You can put two or more commands on the same line, separated by a semicolon <command>;</command>. The scan will then go until each semicolon, and the lines will be executed sequentially, with the shell waiting for each command to end before starting the next one.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo Hello
Hello
[paul@RHELv4u3 ~]$ echo World
World
[paul@RHELv4u3 ~]$ echo Hello;echo World
Hello
World
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>When on the other hand you end a line with an ampersand <command>&#038;</command>, then the shell will not wait for the command to finish. You will get your shell prompt back, and the command is executed in background. You will get a message when it has finished executing in background.</para>
			<screen>
[paul@RHELv4u3 ~]$ sleep 20 &#038;
[1] 7925
[paul@RHELv4u3 ~]$ 
[paul@RHELv4u3 ~]$ 
[paul@RHELv4u3 ~]$ 
[1]+  Done                     sleep 20
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can control execution of commands with <command>&#038;&#038;</command> denoting a logical AND and <command>||</command> denoting a logical OR. With &#038;&#038; the second command is only executed when the first one succeeds (returns a zero exit status). </para>
			<screen>
paul@barry:~$ echo first &#038;&#038; echo second ; echo third
first
second
third
paul@barry:~$ zecho first &#038;&#038; echo second ; echo third
-bash: zecho: command not found
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>bash logical AND</command> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen &#038;&#038; ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ cd gen &#038;&#038; ls
-bash: cd: gen: No such file or directory
[paul@RHELv4u3 gen]$
			</screen>		
			<para>The reverse is true for || . Meaning the second command is only executed when the first command fails (or in other words: returns a non-zero exit status).</para>
			<screen>
paul@barry:~$ echo first || echo second ; echo third
first
third
paul@barry:~$ zecho first || echo second ; echo third
-bash: zecho: command not found
second
third
paul@barry:~$
			</screen>
			<para>Another example of the same <command>bash logical OR</command> principle.</para>
			<screen>
[paul@RHELv4u3 ~]$ cd gen || ls
[paul@RHELv4u3 gen]$ cd gen || ls
-bash: cd: gen: No such file or directory
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can use the logical AND and OR to echo whether a command worked or not.</para>
			<screen>
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
It worked!
paul@laika:~/test$ rm file1 &#038;&#038; echo It worked! || echo It failed!
rm: cannot remove `file1': No such file or directory
It failed!
paul@laika:~/test$
			</screen>
			<para>Lines ending in a backslash are continued on the next line. The shell will wait with executing the command line until a return without backslash is encountered.</para>
			<screen>
[paul@RHEL4b ~]$ echo This command line \
> is split in three \
> parts
This command line is split in three parts
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Comment</title>
			<para>Inserting <command>bash comments</command> has no influence on the command. Comments start with a # (pound sign).</para>
			<screen>
paul@barry:~$ mkdir test    # we create a directory
paul@barry:~$ cd test       #### we enter the directory
paul@barry:~/test$ ls       # is it empty ?
paul@barry:~/test$
			</screen>
		</section>
		<section><title>White space squeezing</title>
			<para>Multiple consecutive <command>white spaces</command> on the command line will be reduced to one white space. That is why the following four different command lines are the same after <command>shell expansion</command>.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo Hello World
Hello World
[paul@RHELv4u3 ~]$ echo Hello   World
Hello World
[paul@RHELv4u3 ~]$ echo   Hello   World
Hello World
[paul@RHELv4u3 ~]$    echo      Hello      World
Hello World
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can prevent the squeezing of white spaces to a single white space character by quoting the spaces.</para>
			<screen>
[paul@RHEL4b ~]$ echo "A line with      double    quotes"
A line with      double    quotes
[paul@RHEL4b ~]$ echo 'A line with      single    quotes'
A line with      single    quotes
[paul@RHEL4b ~]$
			</screen>
			<para>Quoted lines can include special escaped charachters recognized by echo (when using <command>echo -e</command>). The screenshot below shows how to use escaped n for a newline and escaped t for a tab (usually eight white spaces).</para>
			<screen>
[paul@RHEL4b ~]$ echo -e "A line with \na newline"
A line with 
a newline
[paul@RHEL4b ~]$ echo -e 'A line with \na newline'
A line with 
a newline
[paul@RHEL4b ~]$ echo -e "A line with \ta tab"
A line with     a tab
[paul@RHEL4b ~]$ echo -e 'A line with \ta tab'
A line with     a tab
[paul@RHEL4b ~]$ 
			</screen>
			<para>The echo command can generate more than white spaces, tabs and newlines ; check the man page. More information about quoting and escaping later in this chapter.</para>
		</section>
		<section><title>File globbing</title>
			<para>The shell is also responsible for <command>file globbing</command> (or dynamic filename generation). The asterisk <command>*</command> is interpreted by the shell as a sign to generate filenames, matching the asterisk to any combination of characters (even none). When no path is given, the shell will use filenames in the current directory. See the man page of glob(7) for more information. (This is part of LPI topic 1.103.3.)</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File*
File4  File55  FileA  Fileab  FileAB
[paul@RHELv4u3 gen]$ ls file*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls *ile55
File55
[paul@RHELv4u3 gen]$ ls F*ile55
File55
[paul@RHELv4u3 gen]$ ls F*55
File55
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>Similar to the asterisk, the question mark <command>?</command> is interpreted by the shell as a sign to generate filenames, matching the question mark with exactly one character.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File?
File4  FileA
[paul@RHELv4u3 gen]$ ls Fil?4
File4
[paul@RHELv4u3 gen]$ ls Fil??
File4  FileA
[paul@RHELv4u3 gen]$ ls File??
File55  Fileab  FileAB
[paul@RHELv4u3 gen]$
			</screen>
			<para>The square bracket <command>[</command> is interpreted by the shell as a sign to generate filenames, matching any of the characters between <command>[</command> and the first subsequent <command>]</command>. The order in this list between the brackets is not important. Each pair of brackets is replaced by exactly one character.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls File[5A]
FileA
[paul@RHELv4u3 gen]$ ls File[A5]
FileA
[paul@RHELv4u3 gen]$ ls File[A5][5b]
File55
[paul@RHELv4u3 gen]$ ls File[a5][5b]
File55  Fileab
[paul@RHELv4u3 gen]$ ls File[a5][5b][abcdefghijklm]
ls: File[a5][5b][abcdefghijklm]: No such file or directory
[paul@RHELv4u3 gen]$ ls file[a5][5b][abcdefghijklm]
fileabc
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can also exclude characters from a list between square brackets with the exclamation mark <command>!</command>. And you are allowed to make combinations of these <command>wild cards</command>.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls 
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
[paul@RHELv4u3 gen]$ ls file[a5][!Z]
fileab
[paul@RHELv4u3 gen]$ ls file[!5]*
file1  file2  file3  fileab  fileabc
[paul@RHELv4u3 gen]$ ls file[!5]?
fileab
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>The bash shell will also understand ranges of characters between brackets.</para>
			<screen>
[paul@RHELv4u3 gen]$ ls
file1  file3  File55  fileab  FileAB   fileabc
file2  File4  FileA   Fileab  fileab2
[paul@RHELv4u3 gen]$ ls file[a-z]*
fileab  fileab2  fileabc
[paul@RHELv4u3 gen]$ ls file[0-9]
file1  file2  file3
[paul@RHELv4u3 gen]$ ls file[a-z][a-z][0-9]*
fileab2
[paul@RHELv4u3 gen]$ 
			</screen>
			<para>But, don't forget the influence of the <command>LANG</command> variable. Some languages include lowercase letters in an uppercase range (and vice versa).</para>
			<screen>
paul@RHELv4u4:~/test$ ls [A-Z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3  File4
paul@RHELv4u4:~/test$ echo $LANG
en_US.UTF-8
paul@RHELv4u4:~/test$ LANG=C
paul@RHELv4u4:~/test$ echo $LANG
C
paul@RHELv4u4:~/test$ ls [a-z]ile?
file1  file2  file3
paul@RHELv4u4:~/test$ ls [A-Z]ile?
File4
paul@RHELv4u4:~/test$ 
			</screen>
		</section>
		<section><title>Shell variables</title>
			<para>Another important character interpreted by the shell is the dollar sign <command>$</command>. The shell will look for an <command>environment variable</command> named like the string behind the dollar sign and replace it with the value of the variable (or with nothing if the variable does not exist).</para>
			<screen>
[paul@RHELv4u3 gen]$ echo Hello $USER
Hello paul
[paul@RHELv4u3 gen]$ echo Hello $user
Hello
[paul@RHELv4u3 gen]$ echo This is the $SHELL shell
This is the /bin/bash shell
[paul@RHELv4u3 gen]$ echo This is the $SHELL shell on computer $HOSTNAME
This is the /bin/bash shell on computer RHELv4u3.localdomain
[paul@RHELv4u3 gen]$ echo the userid of $USER is $UID, his homedir is $HOME
the userid of paul is 500, his homedir is /home/paul
[paul@RHELv4u3 gen]$
			</screen>
			<para>The exit code of the previous command is stored in the shell variable $?. Actually $? is a shell parameter and not a variable, you cannot assign a value to $?.</para>
			<screen>
paul@laika:~/test$ touch file1 ; echo $?
0
paul@laika:~/test$ rm file1 ; echo $?
0
paul@laika:~/test$ rm file1 ; echo $?
rm: cannot remove `file1': No such file or directory
1
paul@laika:~/test$
			</screen>
			<para>Bash will let you create your own variables.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo $MyVar
				
[paul@RHELv4u3 gen]$ MyVar=555
[paul@RHELv4u3 gen]$ echo $MyVar
555
[paul@RHELv4u3 gen]$ 
			</screen>
		</section>
		<section><title>set, unset and env</title>			
			<para>You can use the <command>set</command> and <command>env</command> commands to display a list of environment variables. On Ubuntu and Debian systems, the set command will end the list of shell variables with a list of shell functions, use <command>set | more</command> to see the variables then.</para>
			<para>The env command can also be useful for other neat things, like starting a clean shell (a shell without any inherited environment). The <command>env -i</command> command clears the environment for the subshell. Notice that bash will set the $SHELL variable on startup.</para>
			<screen>
[paul@RHEL4b ~]$ bash -c 'echo $SHELL $HOME $USER'
/bin/bash /home/paul paul
[paul@RHEL4b ~]$ env -i bash -c 'echo $SHELL $HOME $USER'
/bin/bash
[paul@RHEL4b ~]$
			</screen>
			<para>You can also use the env tool to set the LANG variable (or any other) for an instance of bash with one command. The example below uses this to show the influence of the LANG variable on file globbing.</para>
			<screen>
[paul@RHEL4b test]$ env LANG=C bash -c 'ls File[a-z]'
Filea  Fileb
[paul@RHEL4b test]$ env LANG=en_US.UTF-8 bash -c 'ls File[a-z]'
Filea  FileA  Fileb  FileB
[paul@RHEL4b test]$
			</screen>
			<para>Use the <command>unset</command> command to remove a variable from your shell environment.</para>
			<screen>
[paul@RHEL4b ~]$ MyVar=8472
[paul@RHEL4b ~]$ echo $MyVar;unset MyVar;echo $MyVar
8472

[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Bash shell options</title>
			<para>Both <command>set</command> and <command>unset</command> are built-in shell commands. They can be used to set options of the bash shell itself. The next example will clarify this. By default, the shell will treat unset variables as a variable having no value. By setting the -u option, the shell will treat any reference to unset variables as an error. See the man page of bash for more information.</para>
			<screen>
[paul@RHEL4b ~]$ echo $var123

[paul@RHEL4b ~]$ set -u
[paul@RHEL4b ~]$ echo $var123
-bash: var123: unbound variable
[paul@RHEL4b ~]$ set +u
[paul@RHEL4b ~]$ echo $var123

[paul@RHEL4b ~]$
			</screen>
			<para>To list all the set options for your Bash shell, use <command>echo $-</command>. The noclobber option will be explained later in this book (in the I/O redirection chapter).</para>
			<screen>
[paul@RHEL4b ~]$ echo $-
himBH
[paul@RHEL4b ~]$ set -C ; set -u
[paul@RHEL4b ~]$ echo $-
himuBCH
[paul@RHEL4b ~]$ set +C ; set +u
[paul@RHEL4b ~]$ echo $-
himBH
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Exporting variables</title>
			<para>You can export shell variables to other shells with the <command>export</command> command. This will export the variable to child shells, not to the parent shell.</para>
			<screen>
[paul@RHEL4b ~]$ var3=three
[paul@RHEL4b ~]$ var4=four
[paul@RHEL4b ~]$ export var4
[paul@RHEL4b ~]$ echo $var3 $var4
three four
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $var3 $var4
four
[paul@RHEL4b ~]$ export var5=five
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
four five
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $var3 $var4 $var5
three four
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Delineate variables</title>
			<para>Until now, we have seen that bash interpretes a variable starting from a dollar sign, until the first occurence of a non-alphanumerical character that is not an underscore. In some situations, this can be a problem. This issue can be resolved with curly braces like in this example.</para>
			<screen>
[paul@RHEL4b ~]$ prefix=Super
[paul@RHEL4b ~]$ echo Hello $prefixman and $prefixgirl
Hello  and
[paul@RHEL4b ~]$ echo Hello ${prefix}man and ${prefix}girl
Hello Superman and Supergirl
[paul@RHEL4b ~]$
			</screen>
		</section>
		<section><title>Escaping</title>
			<para>When you want to use one of these characters that are automatically interpreted by the shell, you can <command>escape</command> them with a backslash <command>\</command> (or with quotes as seen earlier).</para>
			<screen>
[paul@RHELv4u3 ~]$ echo hello   world
hello world
[paul@RHELv4u3 ~]$ echo hello\ \ \ world
hello   world
[paul@RHELv4u3 ~]$ echo escaping \\\ \?\ \*\ \"\ \'
escaping \ ? * " '
[paul@RHELv4u3 ~]$ echo escaping \\\?\*\"\'
escaping \?*"'
			</screen>
			<para>Notice however that double quotes still allow the parsing of variables, whereas single quotes prevent this.</para>
			<screen>
[paul@RHELv4u3 ~]$ MyVar=555
[paul@RHELv4u3 ~]$ echo $MyVar
555
[paul@RHELv4u3 ~]$ echo "$MyVar"
555
[paul@RHELv4u3 ~]$ echo '$MyVar'
$MyVar
			</screen>
			<para>The bash shell will replace variables with their value in double quoted lines, but not in single quoted lines.</para>
			<screen>
[[paul@RHEL4b ~]$ echo "$var3  $SHELL"
three  /bin/bash
paul@RHEL4b ~]$ echo '$var3  $SHELL'
$var3  $SHELL
			</screen>
		</section>
		<section><title>Shell embedding</title>
			<para>Shells can be embedded on the command line, or in other words the command line scan can spawn new processes, containing a fork of the current shell. You can use variables to prove that new shells are created. In the screenshot below (which uses POSIX compliant embedding), the variable $var1 only exists in the (temporary) sub shell.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ echo $(var1=5;echo $var1)
5
[paul@RHELv4u3 gen]$ echo $var1

[paul@RHELv4u3 gen]$ 
			</screen>
			<para>You can embed a shell in an embedded shell, this is called nested embedding of bash.</para>
			<screen>
[paul@RHEL4b ~]$ P=Parent;
[paul@RHEL4b ~]$ echo $P$C$G - $(C=Child;echo $P$C$G - ;echo $(G=Grand;echo $P$C$G)) 
Parent - ParentChild - ParentChildGrand
			</screen>
			<para>Single embedding can be useful to avoid changing your current directory. The screenshot below uses back ticks instead of dollar-bracket to embed.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo `cd /etc; ls -d * | grep pass`
passwd passwd- passwd.OLD
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>Placing the embedding between <command>back ticks</command> has the same meaning. But be careful, back ticks are often confused with single quotes. The technical difference between <command>'</command> and <command>`</command> is significant! You can not use back ticks to nest embedded shells.</para>
			<screen>
[paul@RHELv4u3 gen]$ echo `var1=5;echo $var1`
5
[paul@RHELv4u3 gen]$ echo 'var1=5;echo $var1'
var1=5;echo $var1
[paul@RHELv4u3 gen]$
			</screen>
		</section>
		<section><title>Shell alias</title>
			<para>The shell will allow you to create aliases. This can be useful to abbreviate commands.</para>
			<screen>
[paul@RHELv4u3 ~]$ cat count.txt 
one
two
three
[paul@RHELv4u3 ~]$ tac count.txt 
three
two
one
[paul@RHELv4u3 ~]$ dog count.txt 
-bash: dog: command not found
[paul@RHELv4u3 ~]$ alias dog=tac
[paul@RHELv4u3 ~]$ dog count.txt 
three
two
one
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>Aliases can be used to supply some commands with default options.</para>
			<screen>
[paul@RHELv4u3 ~]$ rm -i winter.txt 
rm: remove regular file `winter.txt'? no
[paul@RHELv4u3 ~]$ rm winter.txt 
[paul@RHELv4u3 ~]$ ls winter.txt
ls: winter.txt: No such file or directory
[paul@RHELv4u3 ~]$ touch winter.txt
[paul@RHELv4u3 ~]$ alias rm='rm -i'
[paul@RHELv4u3 ~]$ rm winter.txt 
rm: remove regular empty file `winter.txt'? no
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>You can undo an alias with the <command>unalias</command> command.</para>
			<screen>
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$ alias rm='rm -i'
[paul@RHEL4b ~]$ which rm
alias rm='rm -i'
        /bin/rm
[paul@RHEL4b ~]$ unalias rm
[paul@RHEL4b ~]$ which rm
/bin/rm
[paul@RHEL4b ~]$</screen>
		</section>
		<section><title>Displaying shell expansion</title>
			<para>You can display the shell expansion with <command>set -x</command>, and stop displaying it with <command>set +x</command>. You might want to use this further on in this course, or when in doubt about what exactly the shell is doing with your command.</para>
			<screen>
[paul@RHELv4u3 ~]$ set -x
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo $USER
+ echo paul
paul
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ echo \$USER
+ echo '$USER'
$USER
++ echo -ne '\033]0;paul@RHELv4u3:~\007'
[paul@RHELv4u3 ~]$ set +x
+ set +x
[paul@RHELv4u3 ~]$ echo \$USER
$USER
[paul@RHELv4u3 ~]$ 
			</screen>
		</section>
	</section>
	<section><title>Practice: Discover Bash</title>
		<para>0. All these questions can be answered by one command line!!</para>
		<para>1. When you type 'passwd', which file is executed ?</para>
		<para>2. What kind of file is that ?</para>
		<para>3. Execute the pwd command twice. (remember 0.)</para>
		<para>4. Execute ls after cd /etc, but only if cd /etc did not error.</para>
		<para>5. Execute cd /etc after cd etc, but only if cd etc fails.</para>
		<para>6. Execute sleep 10, what is this command doing ?</para>
		<para>7. Execute sleep 200 in background (do not wait for it to finish).</para>
		<para>8. Use echo to display Hello followed by your username. (use a bash variable!)</para>
		<para>9. Use echo to display "Hello World with strange' characters \ * [ }  ~ \\ ." (including all quotes)</para>
		<para>10. Use one echo command to display three words on three lines.</para>
		<para>11. Create a testdir and enter it.</para>
		<para>12. Create files file1 file10 file11 file2 File2 File3 file33 fileAB filea fileA fileAAA file( file 2 (the last one has 6 characters including a space)</para>
		<para>13. List (with ls) all files starting with file.</para>
		<para>14. List (with ls) all files starting with File.</para>
		<para>15. List (with ls) all files starting with file and ending in a number.</para>
		<para>16. List (with ls) all files starting with file and ending with a letter</para>
		<para>17. List (with ls) all files starting with File and having a digit as fifth character.</para>
		<para>18. List (with ls) all files starting with File and having a digit as fifth character and nothing else.</para>
		<para>19. List (with ls) all files starting with a letter and ending in a number.</para>
		<para>20. List (with ls) all files that have exactly five characters.</para>
		<para>21. List (with ls) all files that start with f or F and end with 3 or A.</para>
		<para>22. List (with ls) all files that start with f have i or R as second character and end in a number.</para>
		<para>23. List all files that do not start with the letter F.</para>
		<para>24. Copy the value of $LANG to $MyLANG.</para>
		<para>25. Show the influence of $LANG in listing A-Z or a-z ranges.</para>
		<para>26. List all current shell variables.</para>
		<para>27. Write a command line that executes 'rm file55'. Your command line should print 'success' if file55 is removed, and print 'failed' if there was a problem.</para>
		<para>28. Create a variable MyVar with a value of 1201.</para>
		<para>29. Do the env and set commands display your variable ?</para>
		<para>30. Destroy your variable.</para>
		<para>31. Find the list of shell options in the man page of bash. What is the difference between "set -u" and "set -o nounset" ?</para>
		<para>32a. Create two variables, and export one of them.</para>
		<para>32b. Display the exported variable in an interactive child shell.</para>
		<para>32c. Display the exported variable in an embedded child shell.</para>
		<para>33. Create a variable, give it the value 'Dumb', create another variable with value 'do'. Use echo and the two variables to echo Dumbledore.</para>
		<para>34. Use echo to display the following exactly: ""\\`;     "_+</para>
		<para>35. List all current aliases.</para>
		<para>36. Create an alias for echo.</para>
		<para>37. Use your alias to echo echo.</para>
		<para>38. Remove your alias for echo.</para>
		<para>39. Read the man page of rm, make sure you understand the -i option of rm. Test yourself that you understand it!</para>
		<para>40. Execute: alias rm='rm - i' . Does this work as expected ?</para>
		<para>41. Explain what "set -x" does. Can this be useful ?</para>
		<para>42. Given the following screenshot, add exactly four characters to that command line so that the total output is FirstMiddleLast.</para>
		<screen>
[paul@RHEL4b ~]$ echo  First; echo  Middle; echo  Last
First
Middle
Last
[paul@RHEL4b ~]$
		</screen>
		<para>43. You receive information that one of your servers was cracked, the cracker probably replaced the ls commnand. You know that the echo command is safe to use. Can echo replace ls ? How can you list the files in the current directory with echo ?</para>
		<para>44. The cd command is also compromised, can echo be used to list files in other directories ? Explain how this works (list the contents of /etc and /bin without ls). </para>
		<para>45. Is there another command besides cd to change directories ?</para>
		<para>46. Read and understand the next section about bash history. Then come back to finish this lab.</para>
		<para>47. Make sure bash remembers the last 5000 commands you typed.</para>
		<para>48. Open more than one console (press Ctrl-shift-t in gnome terminal) with the same user account. When is command history written to the history file ?</para>
		<para>49. Issue the date command. Now display the date in YYYY/MM/DD format.</para>
		<para>50. Issue the cal command. Display a calendar of 1582 and 1752. Notice anything special ?</para>
		<para></para>
		<para></para>	
	</section>
	<section><title>bash shell history</title>
		<para>The bash shell will remember the commands you type, so you can easily repeat previous commands. Some variables are defining this process: <command>$HISTFILE</command> points to the location of the history file, <command>$HISTSIZE</command> will tell you how many commands will be remembered in your current shell session, <command>$HISTFILESIZE</command> is the truncate limit for the number of commands in the history file. Your shell session history is written to the file when exiting the shell.</para>
		<screen>
			[paul@RHELv4u3 ~]$ echo $HISTFILE
			/home/paul/.bash_history
			[paul@RHELv4u3 ~]$ echo $HISTFILESIZE
			1000
			[paul@RHELv4u3 ~]$ echo $HISTSIZE
			1000
			[paul@RHELv4u3 ~]$ 
		</screen>
		<para>To repeat the last command, type <command>!!</command>. This is pronounced as <command>bash bash</command>. To repeat older commands, use <command>history</command> to display your history and type <command>!</command> followed by a number. The shell will echo the command and execute it.</para>
		<screen>
			[paul@RHELv4u3 ~]$ history
			2  cat /etc/redhat-release 
			3  uname -r
			4  rpm -qa | grep ^parted
			...
			[paul@RHELv4u3 ~]$ !3
			uname -r
			2.6.9-34.EL
			[paul@RHELv4u3 ~]$ 
		</screen>
		<para>You can also use the bash with one or more characters, the shell will then repeat the last command that started with those characters. But this can be very very dangerous, you have to be sure about the last command in your current shell history that starts with those characters! You can also use a colon followed by a regular expression to manipulate the previous command.</para>
		<screen>
[paul@RHEL4b ~]$ ls file4
file4
[paul@RHEL4b ~]$ !ls
ls file4
file4
[paul@RHEL4b ~]$ !ls:s/4/5
ls file5
file5
[paul@RHEL4b ~]$ history 4
  422  ls file4
  423  ls file4
  424  ls file5
  425  history 4
[paul@RHEL4b ~]$ </screen>
	</section>	
</chapter>
<chapter><title>vim (vi improved)</title>
	<para>The editor <command>vi</command> is installed on almost every Unix system in the world. Linux will very often install <command>vim</command> which is very similar, but improved. Every Linux system administrator should know vi (or rather vim), because it is often an easy tool to solve problems.</para>
	<para>Many unixes and linuxes will also have <command>emacs</command>, <command>nano</command>, <command>pico</command>, <command>joe</command> or other editors installed. The choice of favorite editor is often a cause for <command>flame wars</command> or polls. Feel free to use any of the alternatives to vi(m).</para>
	<para>The vi editor is not intuitive to novices, but once you get to know it, vi becomes a very powerful application. Some basic commands are a A i I o O r x G 'n G' b w dw dd d0 d$ yw yy y0 y$ 3dd p P u U :w :q :w! :q! :wq ZZ :r :!cmd ':r !cmd' ddp yyp /pattern. Most Linux distributions will include the <command>vimtutor</command> which is a 45 minute lesson in vi.</para>
	<section><title>command mode and insert mode</title>
		<para>The vi editor starts in <command>command mode</command>. In command mode, you can type commands. The commands a A i I o O will bring you into <command>insert mode</command>. In insert mode, you can type text. The escape key will bring you back to command mode. When in insert mode, vi will display <command>-- INSERT --</command> in the bottom left corner.</para>
	</section>
	<section><title>Start typing (a A i I o O)</title>
		<para>The difference between a A i I o and O is the location where you can start typing. a will append after the current character and A will append at the end of the line. i will insert before the current character and I will insert at the beginning of the line. o will put you in a new line after the current line and O will put you in a new line before the current line.</para>
	</section>
	<section><title>Replace and delete a character (r x)</title>
		<para>When in command mode (it doensn't hurt to hit the escape key more than once) you can use the x key to delete the current character. Big X key (or shift x) will delete the character left of the cursor. Also when in command mode, you can use the r key to replace one single character. The r key will bring you in insert mode for just one key press, and will return you immediately to command mode.</para>
	</section>
	<section><title>Undo and repeat(u .)</title>
		<para>When in command mode, you can undo your mistakes with u. You can do your mistakes twice with . (in other words the . will repeat your last command).</para>
	</section>
	<section><title>Cut, copy and paste a line (dd yy p P)</title>
		<para>When in command mode, dd will cut the current line. yy will copy the current line. You can paste the last copied or cut line after (p) or before (P) the current line.</para>
	</section>
	<section><title>Cut, copy and paste lines (3dd 2yy)</title>
		<para>When in command mode, before typing dd or yy, you can type a number to repeat the command a number of times. Thus, 5dd will cut 5 lines and 4yy will copy (yank) 4 lines. That last one will be noted by vi in the bottom left corner as "4 line yanked".</para>
	</section>
	<section><title>Start and end of a line (0 or &#094; and $)</title>
		<para>When in command mode, the 0 and the caret &#094; will bring you to the start of the current line, whereas the $ will put the cursor at the end of the current line. You can add 0 and $ to the d command, d0 will delete every character between the current character and the start of the line. Likewise d$ will delete everything from the current character till the end of the line. Similarly y0 and y$ will yank till start and end of the current line.</para>
	</section>
	<section><title>Join two lines (J)</title>
		<para>When in command mode, pressing J will append the next line to the current line.</para>
	</section>
	<section><title>Words (w b)</title>
		<para>When in command mode, w will jump you to the next word, and b will get you to the previous word. w and b can also be combined with d and y to copy and cut words (dw db yw yb).</para>
	</section>
	<section><title>Save (or not) and exit (:w :q :q! )</title>
		<para>Pressing the colon : will allow you to give instructions to vi. :w will write (save) the file, :q will quit un unchanged file without saving, :q! will quit vi discarding changes. :wq will save and quit and is the same as typing ZZ in command mode.</para>
	</section>
	<section><title>Searching (/ ?)</title>
		<para>When in command mode typing / will allow you to search in vi for strings (can be a regular expression). Typing /foo will do a forward search for the string foo, typing ?bar will do a backward search for bar.</para>
	</section>
	<section><title>Replace all ( &#058;1,$ s&#047;foo&#047;bar&#047;g )</title>
		<para>To replace all occurences of the string foo in bar, first switch to ex mode with &#058; . Then tell vi which lines to use, for example 1,&#036; will do the replace all from the first to the last line. You can write 1,5 to only process the first five lines. The s&#047;foo&#047;bar&#047;g will replace all occurences of foo with bar.</para>
	</section>
	<section><title>Reading files (:r :r !cmd)</title>
		<para>When in command mode, :r foo will read the file named foo, :r !foo will execute the command foo. The result will be put at the current location. Thus :r !ls will put a listing of the current directory in your textfile.</para>
	</section>
	<section><title>Setting options</title>
		<para>Some options that you can set in vim.</para>
		<screen>
:set number  ( also try :se nu )
:set nonumber
:syntax on
:syntax off
:set all  (list all options)
:set tabstop=8
:set tx   (CR/LF style endings)
:set notx
		</screen>
		<para>You can set these options (and much more) in ~/.vimrc</para>
		<screen>
paul@barry:~$ cat ~/.vimrc
set number
paul@barry:~$
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Start the vimtutor and do some or all of the exercises.</para>
		<para>2. What 3 key combination in command mode will duplicate the current line.</para>
		<para>3. What 3 key combination in command mode will switch two lines' place (line five becomes line six and line six becomes line five).</para>
		<para>4. What 2 key combination in command mode will switch a character's place with the next one.</para>
		<para>5. vi can understand macro's. A macro can be recorded with q followed by the name of the macro. So qa will record the macro named a. Pressing q again will end the recording. You can recall the macro with @ followed by the name of the macro. Try this example: i 1 'Escape Key' qa yyp 'Ctrl a' q 5@a (Ctrl a will increase the number with one).</para>
		<para>6. Copy /etc/passwd to your ~/passwd. Open the last one in vi and press Ctrl v. Use the arrow keys to select a Visual Block, you can copy this with y or delete it with d. Try pasting it.</para>
		<para>7. What does dwwP do when you are at the beginning of a word in a sentence ?</para>
		<para></para>
		<para></para>	
	</section>
	<section><title>Solutions to the Practice</title>
		<para>2. yyp</para>
		<para>3. ddp</para>
		<para>4. xp</para>
		<para>7. dwwP can switch the current word with the next word.</para>
		<para></para>
		<para></para>	
	</section>
</chapter>
<chapter><title>Users and groups</title>
	<para>In general, if you are a novice linux user and you need to manage users and groups on your home system, then use the graphical tool that is provided by your linux distro. This will make sure that you do not run into problems. Server administrators will use command line tools like useradd, userdel, groupadd and so on, whereas really advanced administrators will use vi (or vipw) to edit the proper files directly. Do not attempt the latter as a novice on production systems.</para>
	<section><title>Users</title>
		<section><title>/etc/passwd</title>
			<para>All users on a linux system are listed in <command>/etc/passwd</command>. </para>
			<screen>
[paul@RHEL4b ~]$ tail /etc/passwd
paul:x:500:500:Paul Cobbaut:/home/paul:/bin/bash
Jef:x:501:501::/home/Jef:/bin/bash
Martina:x:505:505:Martina Hingis:/home/Martina:/bin/bash
Venus:x:507:511:Venus Williams:/home/Venus:/bin/bash
Serena:x:508:512:Serena Williams:/home/Serena:/bin/bash
Kim:x:509:513:Kim Clijsters:/home/Kim:/bin/bash
Figo:x:510:514::/home/Figo:/bin/bash
Pfaff:x:511:515::/home/Pfaff:/bin/bash
Harry:x:516:520:Potter Harry:/home/Harry:/bin/bash
Hermione:x:517:521:Hermione Granger:/home/Hermione:/bin/bash
[paul@RHEL4b ~]$ 
			</screen>
		</section>
		<section><title>useradd</title>	
			<para>You can add users with the <command>useradd</command> command as shown in this example. </para>
			<screen>
[root@RHEL4b ~]# useradd -m Harry
[root@RHEL4b ~]# tail -1 /etc/passwd
Harry:x:516:520::/home/Harry:/bin/bash
[root@RHEL4b ~]# ls -ld /home/Harry/
drwx------  4 Harry Harry 4096 Jul 23 12:35 /home/Harry/
[root@RHEL4b ~]# 
			</screen>
			<para>The user named Harry has userid 516 and <command>primary group</command> id 520. He does not have a description, his home directory is /home/Harry and it is created by default (because of the -m option). His default shell is /bin/bash. You can see the default options with <command>useradd -D</command>.</para>
			<screen>
[root@RHEL4b ~]# useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
[root@RHEL4b ~]#
			</screen>
			<para>You can also explicitly supply these options with the useradd command.First we will delete the user Harry with <command>userdel</command>, then recreate him with proper options. The -r option of userdel will also remove the home directory. Harry's password will be set later with the passwd command.</para>
			<screen>
[root@RHEL4b ~]# userdel -r Harry
[root@RHEL4b ~]# useradd -m -s /bin/bash -c 'Harry Potter' Harry
[root@RHEL4b ~]# tail -1 /etc/passwd
Harry:x:516:520:Harry Potter:/home/Harry:/bin/bash
[root@RHEL4b ~]# 
			</screen>
		</section>
		<section><title>usermod</title>
			<para>You can modify a user with the <command>usermod</command> command.</para>
			<screen>
[root@RHEL4b ~]# tail -1 /etc/passwd
Harry:x:516:520:Harry Potter:/home/Harry:/bin/bash
[root@RHEL4b ~]# usermod -c 'Potter Harry' Harry
[root@RHEL4b ~]# tail -1 /etc/passwd
Harry:x:516:520:Potter Harry:/home/Harry:/bin/bash
[root@RHEL4b ~]# 
			</screen>
		</section>
	</section>
	<section><title>Passwords</title>
		<section><title>/usr/bin/passwd</title>
			<para>Passwords of users can be set with the <command>/usr/bin/passwd</command> command. User passwords are encrypted and kept in <command>/etc/shadow</command>. The /etc/shadow file is read only, and can only be read by root. We will see in the file permissions section how it is possible for users to change their password. For now, you will have to know that users can change their password with the <command>passwd</command> command. Users will have to provide their old password before entering the new one twice.</para>
			<screen>
[Harry@RHEL4b ~]$ passwd
Changing password for user Harry.
Changing password for Harry
(current) UNIX password: 
New UNIX password: 
BAD PASSWORD: it's WAY too short
New UNIX password: 
Retype new UNIX password: 
passwd: all authentication tokens updated successfully.
[Harry@RHEL4b ~]$ 
			</screen>
			<para>As you can see, the passwd tool will do some basic verification to prevent users from using too simple passwords. The root user does not have to follow these rules (there will be a warning though). The root user also does not need to provide the old password before entering the new password twice.</para>
		</section>
		<section><title>usermod</title>
			<para>You can also lock (or suspend) and unlock a user account with usermod. The first line in the next screenshot will disable the user Harry by adding a ! in front of his password, making it impossible for Harry to authenticate. The root user (and users with sudo rights on su) will still be able to su to Harry (because the password is not needed here). You can unlock the account again with <command>usermod -U</command>.</para>
			<screen>
[root@RHEL4b ~]# usermod -L Harry
[root@RHEL4b ~]# tail -1 /etc/shadow
Harry:!$1$143TO9IZ$RLm/FpQkpDrV4/Tkhku5e1:13717:0:99999:7:::
[root@RHEL4b ~]# su - Harry
[Harry@RHEL4b ~]$
			</screen>
		</section>
	</section>
	<section><title>password encryption</title>
		<section><title>encryption with passwd</title>
			<para>Passwords are stored in an encrypted format. This encryption is done by the <command>crypt</command> function. The easiest (and recommended) way to add a user with a password to the system is to add the user with the <command>useradd -m user</command> command, and then set the user's password with <command>passwd user</command>.</para>
			<screen>
[root@RHEL4b ~]# useradd -m xavier
[root@RHEL4b ~]# passwd xavier
Changing password for user xavier.
New UNIX password: 
Retype new UNIX password: 
passwd: all authentication tokens updated successfully.
[root@RHEL4b ~]#
			</screen>
		</section>
		<section><title>encryption with openssl</title>
			<para>Another way to create users with a password is to use the -p option of useradd, but that option requires an encrypted password. You can generate this encrypted password with the <command>openssl passwd</command> command.</para>
			<screen>
[root@RHEL4b ~]# openssl passwd stargate
ZZNX16QZVgUQg
[root@RHEL4b ~]# useradd -m -p ZZNX16QZVgUQg mohamed 
[root@RHEL4b ~]# 
			</screen>
		</section>
		<section><title>encryption with crypt</title>
			<para>A third option is to create your own c program using the crypt function, and compile this into a command.</para>
			<screen>
[root@RHEL4b ~]# cat MyCrypt.c 
#include &#060;stdio.h&#062;
#include &#060;unistd.h&#062;

int main(int argc, char** argv)
{
  printf("%s\n", crypt(argv[1], "01"));
  return 0;
}

[root@RHEL4b ~]# g++ MyCrypt.c -o MyCrypt -lcrypt
[root@RHEL4b ~]# ./MyCrypt stargate
01Y.yPnlQ6R.Y
			</screen>
		</section>
	</section>
	<section><title>who and whoami</title>
		<para>The <command>who</command> command will give you information about who is logged on to the system. With <command>who am i</command> you can see which of the who list is yourself. The <command>whoami</command> command exists to tell you your username.</para>
		<screen>
[paul@RHEL4b ~]$ whoami
paul
[paul@RHEL4b ~]$ who am i
paul     pts/0        Jul 24 05:02 (laika)
[paul@RHEL4b ~]$ who
paul     pts/0        Jul 24 05:02 (laika)
Harry    pts/1        Jul 24 05:04 (laika)
[paul@RHEL4b ~]$
		</screen>
	</section>
	<section><title>Groups</title>
		<para>Users can be a member of several groups. Group membership is contained in the <command>/etc/group</command> file. Groups can be created with the <command>groupadd</command> command. Group membership can be modified with the useradd or <command>usermod</command> command. You can change the group name with the <command>groupmod</command> command.</para>
		<screen>
[root@RHEL4b ~]# groupadd tennis
[root@RHEL4b ~]# tail -1 /etc/group
tennis:x:522:
[root@RHEL4b ~]# usermod -G tennis Serena
[root@RHEL4b ~]# usermod -G tennis Venus
[root@RHEL4b ~]# tail -1 /etc/group
tennis:x:522:Serena,Venus
[root@RHEL4b ~]# groupmod -n sports tennis
[root@RHEL4b ~]# tail -1 /etc/group
sports:x:522:Serena,Venus
[root@RHEL4b ~]# 
		</screen>
		<para>A user can type the <command>groups</command> command to see a list of groups where the user belongs to.</para>
		<screen>
[Harry@RHEL4b ~]$ groups
Harry sports
[Harry@RHEL4b ~]$ 		</screen>
	</section>
	<section><title>id</title>
		<para>using the <command>id</command> command, you can display <command>uid</command>, <command>gid</command> and group information about yourself.</para>
		<screen>
[Serena@RHEL4b ~]$ id
uid=508(Serena) gid=512(Serena) groups=512(Serena),522(sports)
[Serena@RHEL4b ~]$
		</screen>
	</section>
	<section><title>/etc/login.defs</title>
		<para>The <command>/etc/login.defs</command> file contains some default settings for users. You will find password aging and length settings, the numerical limits of user id's and group id's and whether or not a home directory should be created by default.</para>
		<screen>
[root@RHEL4b ~]# grep -i pass /etc/login.defs 
# Password aging controls:
#       PASS_MAX_DAYS   Maximum number of days a password may be used.
#       PASS_MIN_DAYS   Minimum number of days allowed between password changes.
#       PASS_MIN_LEN    Minimum acceptable password length.
#       PASS_WARN_AGE   Number of days warning given before a password expires.
PASS_MAX_DAYS   99999
PASS_MIN_DAYS   0
PASS_MIN_LEN    5
PASS_WARN_AGE   7
[root@RHEL4b ~]# 
		</screen>
	</section>
	<section><title>su</title>
		<para>The <command>su</command> command allows a user to run a shell as another user. Running a shell as another user requires that you know the password of the other user, unless you are root. The root user can become any other user without knowing the user's password.</para>
		<screen>
[paul@RHEL4b ~]$ su Harry
Password: 
[Harry@RHEL4b paul]$ su root
Password: 
[root@RHEL4b paul]# su Serena
[Serena@RHEL4b paul]$
		</screen>
		<para>By default, the su command keeps the same shell environment. To become another user and also get the target user's environment, issue the <command>su -</command> command followed by the target username. When no username is provided to su or su - then the command will assume root is the target.</para>
		<screen>
[paul@RHEL4b ~]$ su - Harry
Password: 
[Harry@RHEL4b ~]$ su -
Password: 
[root@RHEL4b ~]#
		</screen>
	</section>
	<section><title>sudo</title>
		<para>On linux systems like Ubuntu, the root user does not have a password set. This means that it is impossible to logon as root (extra security). To perform tasks as root, users can be given <command>sudo rights</command> via the <command>/etc/sudoers</command> file to run a command as another user. On Ubuntu the first user created will get sudo rights to run the su command as root. The end result of this is that the user can type <command>sudo su -</command> and become root without having to entering the root password. The sudo command does require you to enter your own password. Thus the password prompt in the screenshot below is for sudo, not for su. Check the man page of <command>visudo</command> before playing with the /etc/sudoers file.</para>
		<screen>
paul@laika:~$ sudo su -
Password:
root@laika:~#
		</screen>
	</section>
	<section><title>chage</title>
		<para>The <command>chage</command> command can be used to set an expiration date for a user account (-E), set a mimimum (-m) and maximum (-M) password age, a password expiration date, and set the number of warning days before the password expiration date. A lot of this functionality is also available via the passwd command. The -l option of chage will list these settings for a user.</para>
		<screen>
[root@RHEL4b ~]# chage -l Harry
Minimum:        0
Maximum:        99999
Warning:        7
Inactive:       -1
Last Change:            Jul 23, 2007
Password Expires:       Never
Password Inactive:      Never
Account Expires:        Never
[root@RHEL4b ~]#
		</screen>
	</section>
	<section><title>chsh</title>
		<para>Users can change their own login shell with the <command>chsh</command> command. Harry here is first obtaining a list of available shells ( the user could have done a cat <command>/etc/shells</command> ) and then changes his login shell to the <command>Korn shell</command> (/bin/ksh). At the next login, Harry will default into ksh instead of bash. </para>
		<screen>
[Harry@RHEL4b ~]$ chsh -l
/bin/sh
/bin/bash
/sbin/nologin
/bin/ash
/bin/bsh
/bin/ksh
/usr/bin/ksh
/usr/bin/pdksh
/bin/tcsh
/bin/csh
/bin/zsh
[Harry@RHEL4b ~]$ chsh -s /bin/ksh
Changing shell for Harry.
Password: 
Shell changed.
[Harry@RHEL4b ~]$
		</screen>
	</section>
	<section><title>gpasswd</title>
		<para>You can delegate control of group membership to another user with the <command>gpasswd</command> command. In the example below we delegate permissions to add and remove group members to the sports group to Serena. Then we su to Serena and add Harry to the sports group.</para>
		<screen>
[root@RHEL4b ~]# gpasswd -A Serena sports
[root@RHEL4b ~]# su - Serena
[Serena@RHEL4b ~]$ id Harry
uid=516(Harry) gid=520(Harry) groups=520(Harry)
[Serena@RHEL4b ~]$ gpasswd -a Harry sports
Adding user Harry to group sports
[Serena@RHEL4b ~]$ id Harry
uid=516(Harry) gid=520(Harry) groups=520(Harry),522(sports)
[Serena@RHEL4b ~]$ tail -1 /etc/group
sports:x:522:Serena,Venus,Harry
[Serena@RHEL4b ~]$
		</screen>
		<para>Group administrators do not need to be a member of the group. They can even remove themselves from the group, this does not influence their ability to add or remove members.</para>
		<screen>
[Serena@RHEL4b ~]$ gpasswd -d Serena sports
Removing user Serena from group sports
[Serena@RHEL4b ~]$ exit
		</screen>
		<para>Information about group administrators is kept in the <command>/etc/gshadow</command> file.</para>
		<screen>
[root@RHEL4b ~]# tail -1 /etc/gshadow
sports:!:Serena:Venus,Harry
[root@RHEL4b ~]#
		</screen>
	</section>
	<section><title>/etc/skel/</title>
		<para>The <command>/etc/skel/</command> directory is copied to a newly created user's home directory. The /etc/skel/ directory contains some (usually hidden) files that contain profile settings and default values for applications. In this way /etc/skel/ serves as a default home directory and as a default user profile.</para>
	</section>
	<section><title>vipw</title>
		<para>If after knowing all these commands for user and group management you still want to edit the /etc/passwd, /etc/group, /etc/shadow and /etc/gshadow manually, then use <command>vipw</command> instead of vim directly. The vipw tool will do proper locking of the file.</para>
	</section>
	<section><title>Practice: Users and groups</title>
		<para>1. Create the users Serena Williams, Venus Williams and Justine Henin. all of them with password set to stargate, with username as their first name, and their full name in the comment. Verify that the users and their home directory are properly created.</para>
		<para>2. Create a user called kornuser, give him the Korn shell (/bin/ksh) as his default shell. Log on with this user (on a command line or in a tty).</para>
		<para>3. Create a user named Einstime without home directory, give him /bin/date as his default logon shell. What happens when you log on with this user ? Can you think of a useful real world example for changing a user's login shell to an application ?</para>
		<para>4. Try the commands who, whoami, who am i, w, id, echo $USER $UID .</para>
		<para>5a. Lock the Venus user account with usermod.</para>
		<para>5b. Use passwd -d to disable the Serena password.</para>
		<para>5c. What is the difference between locking a user account and disabling a user account's password ?</para>
		<para>6. As root change the password of Einstime to stargate.</para>
		<para>7. Now try changing the password of Serena to Serena as Serena.</para>
		<para>8. Create the groups tennis, football and sports.</para>
		<para>9. In one command, make Venus a member of tennis and sports.</para>
		<para>10. Rename the football group to foot.</para>
		<para>11. Use vi to add Serena to the tennis group.</para>
		<para>12. Use the id command to verify that Serena is a member of tennis.</para>
		<para>13. Make sure every new user needs to change his password every 10 days.</para>
		<para>14. Set the warning number of days to four for the kornuser.</para>
		<para>15. Make someone responsible for managing group membership of foot and sports. Test that it works.</para>
		<para>16a. Set the password of two seperate users to stargate. Look at the encrypted stargate's in /etc/shadow and explain.</para>
		<para>16b. Take a backup as root of /etc/shadow. Use vi to copy an encrypted stargate to another user. Can this other user now log on with stargate as a password ?</para>
		<para>17. Put a file in the skeleton directory and check whether it is copied to user's home directory. When is the skeleton directory copied ?</para>
		<para>18. Why use vipw instead of vi ? What could be the problem when using vi or vim ?</para>
		<para>19. Use chsh to list all shells, and compare to cat /etc/shells. Change your login shell to the Korn shell, log out and back in. Now change back to bash.</para>
		<para>20. Which useradd option allows you to name a home directory ?</para>
		<para>20. If time permits (or if you are waiting for other students to finish this practice), read the man page of /etc/sudoers and give Serena the sudo right to su. Test that it works (and make sure Serena and root have different passwords).</para>
		<para></para>
		<para></para>	
	</section>
</chapter>
<chapter><title>File Permissions</title>
	<section><title>Reading permissions</title>
		<para>The <command>users</command> and <command>groups</command> of a system can be locally managed in <command>/etc/passwd</command> and <command>/etc/group</command>, or they can be in a NIS, LDAP or Samba domain. These users and groups can <command>own</command> files. Actually, every file has a <command>user owner</command> and a <command>group owner</command>, as can be seen in the following screenshot.</para>
		<screen>
paul@RHELv4u4:~/test$ ls -l
total 24
-rw-rw-r--  1 paul paul  17 Feb  7 11:53 file1
-rw-rw-r--  1 paul paul 106 Feb  5 17:04 file2
-rw-rw-r--  1 paul proj 984 Feb  5 15:38 data.odt
-rw-r--r--  1 root root   0 Feb  7 16:07 stuff.txt
paul@RHELv4u4:~/test$ 
		</screen>
		<para>User paul owns three files, two of those are also owned by the group paul, data.odt is owned by the group proj. The root user owns the file stuff.txt, as does the group root. Before the user and group owner, you can see ten characters. The first character tells us the type of file. Regular files get a <command>-</command>, directories get a <command>d</command>, symbolic links are shown with an <command>l</command>, pipes get a <command>p</command>, character devices a <command>c</command>, block devices a <command>b</command> and sockets an <command>s</command>. After that, you get the permissions in three triplets, containing <command>r</command> for read access, <command>w</command> for write access and <command>x</command> for execute permissions. You need the r permission to list (ls) the contents of a directory and x permission to enter (cd) a directory, and you need the w permission to create files in or remove files from a directory. Some examples below.</para>
		<screen>
paul@laika:~/perms$ ll
total 12K
drwxr-xr-x 2 paul paul 4.0K 2007-02-07 22:26 AllEnter_UserCreateDelete
-rw-r--r-- 1 paul paul    0 2007-02-07 22:22 DefaultPermissions.txt
-rwxrwxrwx 1 paul paul    0 2007-02-07 22:21 EveryoneFullControl.txt
-r--r----- 1 paul paul    0 2007-02-07 22:21 OnlyOwnerRead.txt
-rwxrwx--- 1 paul paul    0 2007-02-07 22:21 OwnerAll_Restnothing.txt
drwxrwx--- 2 paul paul 4.0K 2007-02-07 22:25 UserAndGroupEnter
drwx------ 2 paul paul 4.0K 2007-02-07 22:25 UserEnterOnly
paul@laika:~/perms$ 
		</screen>
		<para>It is important to know that the first triplet represents the <command>user owner</command>, the second is the <command>group owner</command>, and the third triplet is all the <command>other</command> users that are not the user owner and are not a member of the group owner.</para>
	</section>
	<section><title>Setting permissions</title>
		<para>Permissions can be changed with <command>chmod</command>, owners can be changed with <command>chown</command> and <command>chgrp</command>. The first example gives the user owner execute permissions.</para>
		<screen>
paul@laika:~/perms$ ls -l permissions.txt 
-rw-r--r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
paul@laika:~/perms$ chmod u+x permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwxr--r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>This example removes the group owners read permission.</para>
		<screen>
paul@laika:~/perms$ chmod g-r permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwx---r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>This example removes the others read permission.</para>
		<screen>
paul@laika:~/perms$ chmod o-r permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwx------ 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>This example gives all of them the write permission.</para>
		<screen>
paul@laika:~/perms$ chmod a+w permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwx-w--w- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>You don't even have to type the a.</para>
		<screen>
paul@laika:~/perms$ chmod +x permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwx-wx-wx 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>You can also set explicit permissions.</para>
		<screen>
paul@laika:~/perms$ chmod u=rw permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rw--wx-wx 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>Feel free to make any kind of combinations.</para>
		<screen>
paul@laika:~/perms$ chmod u=rw,g=rw,o=r permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rw-rw-r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
		<para>Even the fishy combinations are accepted by chmod.</para>
		<screen>
paul@laika:~/perms$ chmod u=rwx,ug+rw,o=r permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwxrw-r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
	</section>
	<section><title>Setting octal permissions</title>
		<para>Most Unix administrators will use the <command>old school</command> octal system to talk about and set permissions. Look at the triplet bitwise, equaling r to 4, w to 2 and x to 1. This makes <command>777</command> equal to rwxrwxrwx and by the same logic has 654 mean rw-r-xr-- . The <command>chmod</command> command will accept these numbers.</para>
		<screen>
paul@laika:~/perms$ chmod 777 permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwxrwxrwx 1 paul paul 0 2007-02-07 22:34 permissions.txt
paul@laika:~/perms$ chmod 664 permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rw-rw-r-- 1 paul paul 0 2007-02-07 22:34 permissions.txt
paul@laika:~/perms$ chmod 750 permissions.txt 
paul@laika:~/perms$ ls -l permissions.txt 
-rwxr-x--- 1 paul paul 0 2007-02-07 22:34 permissions.txt
		</screen>
	</section>
	<section><title>umask</title>
		<para>When creating a file or directory, a set of default permissions are applied. These default permissions are determined by the <command>umask</command>. The umask specifies permissions that you do not want set by default. You can display the umask with the umask command.</para>
		<screen>
[Harry@RHEL4b ~]$ umask
0002
[Harry@RHEL4b ~]$ touch test
[Harry@RHEL4b ~]$ ls -l test
-rw-rw-r--  1 Harry Harry 0 Jul 24 06:03 test
[Harry@RHEL4b ~]$
		</screen>
		<para>As you can see, the file is also not executable by default. This is a general security feature among Unixes, newly created files are never executable by default. You have to explicitely do a <command>chmod +x</command> to make a file executable. This also means that the 1 bit in the umask has no meaning, a umask of 0022 is the same as 0033.</para>
	</section>
	<section><title>Practice: File Permissions</title>
		<para>1. As normal user, create a directory ~/permissions. Create a file owned by yourself in there.</para>
		<para>2. Copy a file owned by root from /etc/ to your permissions dir, who owns this file now ?</para>
		<para>3. As root, create a file in the users ~/permissions directory.</para>
		<para>4. As normal user, look at who owns this file created by root.</para>
		<para>5. Change the ownership of all files in ~/permissions to yourself.</para>
		<para>6. Make sure you have all rights to these files, and others can only read.</para>
		<para>7. With chmod, is 770 the same as rwxrwx--- ?</para>
		<para>8. With chmod, is 664 the same as r-xr-xr-- ?</para>
		<para>9. With chmod, is 400 the same as r-------- ?</para>
		<para>10. With chmod, is 734 the same as rwxr-xr-- ?</para>
		<para>11a. Display the umask in octal and in symbolic form.</para>
		<para>11b. Set the umask to 077, but use the symbolic format to set it. Verify that this works.</para>
		<para>12. Create a file as root, give only read to others. Can a normal user read this file ? Test writing to this file with vi.</para>
		<para>13a. Create a file as normal user, give only read to others. Can another normal user read this file ? Test writing to this file with vi.</para>
		<para>13b. Can root read this file ? Can root write to this file with vi ?</para>
		<para>14. Create a directory that belongs to a group, where every member of that group can read and write to files, and create files. Make sure that people can only delete their own files.</para>
		<para></para>
		<para></para>	
	</section>
	<section><title>The sticky bit</title>
		<para>You can set the <command>sticky bit</command> on a directory to prevent users from removing files that they do not own as a user owner. The sticky bit is displayed at the same location as the x permission for others. The sticky bit is represented by a <command>t</command> (meaning x is also there) or a <command>T</command> (when there is no x for others).</para>
		<screen>
root@RHELv4u4:~# mkdir /project55
root@RHELv4u4:~# ls -ld /project55
drwxr-xr-x  2 root root 4096 Feb  7 17:38 /project55
root@RHELv4u4:~# chmod +t /project55/
root@RHELv4u4:~# ls -ld /project55
drwxr-xr-t  2 root root 4096 Feb  7 17:38 /project55
root@RHELv4u4:~# 
		</screen>
		<para>The sticky bit can also be set with octal permissions, it is binary 1 in the first of four triplets.</para>
		<screen>
root@RHELv4u4:~# chmod 1775 /project55/
root@RHELv4u4:~# ls -ld /project55
drwxrwxr-t  2 root root 4096 Feb  7 17:38 /project55
root@RHELv4u4:~# 
		</screen>
	</section>	
	<section><title>SetGID on directories</title>
		<para>The <command>SetGID</command> can be used on directories to make sure that all files inside the directory are group owned by the group owner of the directory. The SetGID bit is displayed at the same location as the x permission for group owner. The SetGID bit is represented by an <command>s</command> (meaning x is also there) or a <command>S</command> (when there is no x for the group owner). Like this example shows, even though root does not belong to the group proj55, the files created by root in /project55 will belong to proj55 when the SetGID is set.</para>
		<screen>
root@RHELv4u4:~# groupadd proj55
root@RHELv4u4:~# chown root:proj55 /project55/
root@RHELv4u4:~# chmod 3775 /project55/
root@RHELv4u4:~# touch /project55/fromroot.txt
root@RHELv4u4:~# ls -ld /project55/
drwxrwsr-t  2 root proj55 4096 Feb  7 17:45 /project55/
root@RHELv4u4:~# ls -l /project55/
total 4
-rw-r--r--  1 root proj55 0 Feb  7 17:45 fromroot.txt
root@RHELv4u4:~# 
		</screen>
	</section>
	<section><title>SetGID and SetUID on regular files</title>
		<para>These two permissions make for the executable file to be executed with the permissions of the file owner(s) instead of the executing owner. This means that if any user starts a program that belongs to the root user, and the <command>setuid</command> bit is set on that program, then the program runs as root. Can be dangerous, but sometimes this is good for security.</para>
		<para>Take the example of passwords, they are stored in <command>/etc/shadow</command> which is only readable by root. (The root user never needs permissions anyway.)</para>
		<screen>
root@RHELv4u4:~# ls -l /etc/shadow
-r--------  1 root root 1260 Jan 21 07:49 /etc/shadow
		</screen>
		<para>Changing your password requires an update of this file, so how can normal non-root users do this ? Let's take a look at the permissions on the <command>/usr/bin/passwd</command>.</para>
		<screen>
root@RHELv4u4:~# ls -l /usr/bin/passwd 
-r-s--x--x  1 root root 21200 Jun 17  2005 /usr/bin/passwd
		</screen>
		<para>So essentially, when starting the <command>passwd</command> program, you are running that program with root credentials.</para>
	</section>
	<section><title>Practice: Advanced File Permissions</title>
		<para>1. Set up a directory, owned by the group sports.</para>
		<para>2. Members of the sports group should be able to create files in this directory.</para>
		<para>3. All files created in this directory should be group-owned by the sports group.</para>
		<para>4. Users should be able to delete only their own user-owned files.</para>
		<para>5. Test that this works!</para>
		<para>6. If time permits (or if you are waiting for other students to finish this practice), read about file attributes in the man page of chattr and lsattr. Try setting the i attribute on a file and test that it works.</para>
		<para></para>
		<para></para>	
	</section>
</chapter>
<chapter><title>Introduction to scripting</title>
	<para>Bash has support for programming constructs that can be saved as scripts. These scripts in turn then become more bash commands. In fact, a lot of linux commands are scripts. This means that system administrators also need a basic knowledge of scripting to understand how their servers and their applications are started, updated, upgraded, patched, maintained, configured and removed.</para>
	<section><title>Hello World</title>
		<para>Just like in every programming course, we start with a simple Hello World script. The following script will output Hello World.</para>
		<screen>
#!/bin/bash
# Hello World Script
echo Hello World
		</screen>
		<para>After creating this simple script in vi, you'll have to <command>chmod +x</command> the script to make it executable. And unless you add the scripts directory to your path, you'll have to type the path to the script for the shell to be able to find it.</para>
		<screen>
[paul@RHEL4a ~]$ chmod +x hello_world 
[paul@RHEL4a ~]$ ./hello_world 
Hello World
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>Variables</title>
		<screen>
#!/bin/bash
var1=4
echo var1 = $var1
		</screen>
		<para>Scripts can contain variables, but since scripts are run in their own shell, the variables do not survive the end of the script.</para>
		<screen>
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$ ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1

[paul@RHEL4a ~]$
		</screen>
		<para>Luckily you can force a script to run in the same shell, this is called sourcing a script.</para>
		<screen>
[paul@RHEL4a ~]$ source ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
		<para>The above is identical to the below.</para>
		<screen>
[paul@RHEL4a ~]$ . ./vars
var1 = 4
[paul@RHEL4a ~]$ echo $var1
4
[paul@RHEL4a ~]$ 
		</screen>
	</section>
	<section><title>Shell</title>
		<para>You can never be sure which shell a user is running. A script that works flawlessly in bash, might not work in ksh or csh or dash. To instruct a shell to run your script in a certain shell, you can start your script with a shebang <command>#!</command> followed by the shell it is supposed to run in. This script will run in a bash shell.</para>
		<screen>
#!/bin/bash
echo -n hello
echo A bash subshell `echo -n hello`
		</screen>
		<para>This script will run in a Korn shell (unless /bin/ksh is a link to /bin/bash). The <command>/etc/shells</command> file contains a list of shells on your system.</para>
		<screen>
#!/bin/ksh
echo -n hello
echo a Korn subshell `echo -n hello`
		</screen>
	</section>
	<section><title>for loop</title>
		<para>The example below shows the syntax of a classical <command>for loop</command> in bash.</para>
		<screen>
for i in 1 2 4
do
   echo $i
done
		</screen>
		<para>An example of a for loop combined with an embedded shell to generate the list.</para>
		<screen>
for file in `ls *.txt`
do
   cp $file $file.bak
   echo Backup of $file put in $file.bak
done
		</screen>
	</section>
	<section><title>while loop</title>
		<para>Below a simple example of a <command>while loop</command>.</para>
		<screen>
let i=100;
while [ $i -ge 0 ] ;
do
   echo Counting down, from 100 to 0, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>until loop</title>
		<para>Below a simple example of an <command>until loop</command>.</para>
		<screen>
let i=100;
until [ $i -le 0 ] ;
do
   echo Counting down, from 100 to 1, now at $i;
   let i--;
done
		</screen>
	</section>
	<section><title>parameters</title>
		<para>A bash shell script can have parameters. The numbering you see in the script below continues if you have more parameters. You also have special parameters for the number of parameters, a string of all of them, and also the process id and the last error code. The man page of bash has a full list.</para>
		<screen>
#!/bin/bash
echo The first argument is $1
echo The second argument is $2
echo The third argument is $3

echo \$ $$  PID of the script
echo \# $#  count arguments
echo \? $?  last error code
echo \* $*  all the arguments
		</screen>
		<para>Below is the output of the script above in action.</para>
		<screen>
[paul@RHEL4a scripts]$ ./pars one two three
The first argument is one
The second argument is two
The third argument is three
$ 5610 PID of the script
# 3 count arguments
? 0 last error code
* one two three all the arguments
[paul@RHEL4a scripts]$ ./pars a b c
The first argument is a
The second argument is b
The third argument is c
$ 5611 PID of the script
# 3 count arguments
? 0 last error code
* a b c all the arguments
[paul@RHEL4a scripts]$ ./pars 1 2
The first argument is 1
The second argument is 2
The third argument is
$ 5612 PID of the script
# 2 count arguments
? 0 last error code
* 1 2 all the arguments
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>test [ ]</title>
		<para>The <command>test</command> command can test whether something is true or false. Let's start by testing whether 10 is greater than 55.</para>
		<screen>
[paul@RHEL4b ~]$ test 10 -gt 55 ; echo $?
1
[paul@RHEL4b ~]$ 
		</screen>
		<para>The test command returns 1 if the test fails. And as you see in the next screenshot, test returns 0 when a test succeeds.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 ; echo $?
0
[paul@RHEL4b ~]$
		</screen>
		<para>If you prefer true and false, then write the test like this.</para>
		<screen>
[paul@RHEL4b ~]$ test 56 -gt 55 &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ test 6 -gt 55 &#038;&#038; echo true || echo false
false
		</screen>
		<para>The test command can also be written as square brackets, the screenshot below is identical to the one above.</para>
		<screen>
[paul@RHEL4b ~]$ [ 56 -gt 55 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 6 -gt 55 ] &#038;&#038; echo true || echo false
false
		</screen>
		<para>Below are some example tests. Take a look at <command>man test</command> to see more options for tests.</para>
		<screen>
[ -d foo ]             Does the directory foo exist ?
[ '/etc' = $PWD ]      Is the string /etc equal to the variable $PWD ?
[ $1 != 'secret' ]     Is the first parameter different from the string secret ?
[ 55 -lt $bar ]        Is 55 less than the value of $bar ?
[ $foo -ge 1000 ]      Is the value of $foo greater than or equal to 1000 ?
[ "abc" &#060; $bar ]       Does the string abc sort before the value of $bar ?
[ -f foo ]             Is foo a regular file ?
[ -r bar ]             Is bar a readable file ?
[ foo -nt bar ]        Is file foo newer than file bar ?
[ -o nounset ]         Is the shell option nounset set ?
		</screen>
		<para>Tests can be combined with logical AND and OR.</para>
		<screen>
[paul@RHEL4b ~]$ [ 66 -gt 55 -a 66 -lt 500 ] &#038;&#038; echo true || echo false
true
[paul@RHEL4b ~]$ [ 66 -gt 55 -a 660 -lt 500 ] &#038;&#038; echo true || echo false
false
[paul@RHEL4b ~]$ [ 66 -gt 55 -o 660 -lt 500 ] &#038;&#038; echo true || echo false
true
		</screen>
	</section>
	<section><title>if if, then then, or else</title>
		<para>The <command>if then else</command> construction is about choice. If a certain condition is met, then execute something, else execute something else. The example below tests whether a file exists, if the file exists then a proper message is echoed.</para>
		<screen>
#!/bin/bash

if [ -f isit.txt ]
then echo isit.txt exists!
else echo isit.txt not found!
fi
		</screen>
		<para>If we name the above script 'choice', then it executes like this.</para>
		<screen>
[paul@RHEL4a scripts]$ ./choice 
isit.txt not found!
[paul@RHEL4a scripts]$ touch isit.txt
[paul@RHEL4a scripts]$ ./choice 
isit.txt exists!
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>let</title>
		<para>The <command>let</command> command allows for evalutation of arithmetic expressions.</para>
		<screen>
[paul@RHEL4b ~]$ let x="3 + 4" ; echo $x
7
[paul@RHEL4b ~]$ let x="10 + 100/10" ; echo $x
20
[paul@RHEL4b ~]$ let x="10-2+100/10" ; echo $x
18
[paul@RHEL4b ~]$ let x="10*2+100/10" ; echo $x
30
		</screen>
		<para>The let command can also convert between different bases.</para>
		<screen>
[paul@RHEL4b ~]$ let x="0xFF" ; echo $x
255
[paul@RHEL4b ~]$ let x="0xC0" ; echo $x
192
[paul@RHEL4b ~]$ let x="0xA8" ; echo $x
168
[paul@RHEL4b ~]$ let x="8#70" ; echo $x
56
[paul@RHEL4b ~]$ let x="8#77" ; echo $x
63
[paul@RHEL4b ~]$ let x="16#c0" ; echo $x
192
		</screen>
	</section>
	<section><title>runtime input</title>
		<para>You can ask the user for input with the <command>read</command> command in a script.</para>
		<screen>
#!/bin/bash
echo -n Enter a number:
read number
		</screen>
	</section>
	<section><title>sourcing a config file</title>
		<screen>
[paul@RHEL4a scripts]$ cat myApp.conf 
# The config file of myApp

# Enter the path here
myAppPath=/var/myApp

# Enter the number of quines here
quines=5

[paul@RHEL4a scripts]$ cat myApp.bash 
#!/bin/bash
#
# Welcome to the myApp application
# 

. ./myApp.conf

echo There are $quines quines

[paul@RHEL4a scripts]$ ./myApp.bash 
There are 5 quines
[paul@RHEL4a scripts]$ 
		</screen>
	</section>
	<section><title>case</title>
		<para>You can sometimes simplify nested if statements with a case construct.</para>
		<screen>
[paul@RHEL4b ~]$ ./help
What animal did you see ? lion
You better start running fast!
[paul@RHEL4b ~]$ ./help
What animal did you see ? dog
Don't worry, give it a cookie.
[paul@RHEL4b ~]$ cat help
#!/bin/bash
#
# Wild Animals Helpdesk Advice
#
echo -n "What animal did you see ? "
read animal
case $animal in
        "lion" | "tiger")
                echo "You better start running fast!"
        ;;
        "cat")
                echo "Let that mouse go..."
        ;;
        "dog")
                echo "Don't worry, give it a cookie."
        ;;
        "chicken" | "goose" | "duck" )
                echo "Eggs for breakfast!"
        ;;
        "liger")
                echo "Approach and say 'Ah you big fluffy kitty...'."
        ;;
        "babelfish")
                echo "Did it fall out your ear ?"
        ;;
        *)
                echo "You discovered an unknown animal, name it!"
        ;;
esac
[paul@RHEL4b ~]$ 			
		</screen>
	</section>
	<section><title>shopt</title>
		<para>You can toggle the values of variables controlling optional shell behavior with the <command>shopt</command> built-in shell command. The example below first verifies whether the cdspell option is set, it is not. The next shopt command sets the value, and the third shopt command verifies that the option really is set. You can now use minor spelling mistakes in the cd command. The man page of bash has a complete list of options.</para>
		<screen>
paul@laika:~$ shopt -q cdspell ; echo $?
1
paul@laika:~$ shopt -s cdspell
paul@laika:~$ shopt -q cdspell ; echo $?
0
paul@laika:~$ cd /Etc
/etc
paul@laika:/etc$
		</screen>
	</section>
	<section><title>Practice : scripts</title>
		<para>0. Give each script a different name, keep them for later!</para>
		<para>1. Write a script that receives four parameters, and outputs them in reverse order.</para>
		<para>2. Write a script that receives two parameters (two filenames) and outputs whether those files exist.</para>
		<para>3. Write a script that counts the number of files ending in .txt in the current directory.</para>
		<para>4. Write a script that asks for two numbers, and outputs the sum and product (as shown here).</para>
		<screen>
Enter a number: 5
Enter another number: 2

Sum:       5 + 2 = 7
Product:   5 x 2 = 10
		</screen>
		<para>5. Improve the previous script to test that the numbers are between 1 and 100, exit with an error if necessary.</para>
		<para>6. Improve the previous script to congratulate the user if the sum equals the product.</para>
		<para>7. Improve the script from question 2. to complain if it does not receive exactly two parameters.</para>
		<para>8. Write a script that counts from 3 to 7 and then from 7 to 3, and all this three times, once with a for loop, once with a while loop and once with a until loop. Show the teacher that it works!</para>
		<para>9. Write a script that asks for a filename. Verify existance of the file, then verify that you own the file, and whether it is writable. If not, then make it writable.</para>
		<para>10. Make a configuration file for the previous script. Put a logging switch in the config file, logging means writing detailed output of everything the script does to a log file in /tmp.</para>
		<para>11. Make the case statement in "Wild Animals Helpdesk Advice" case insensitive. Use shopt (with the correct toggled option) for this, but reset the value back to it's original after the end of the case statement. (A solution is available in appendix 1, but try to find it yourself.)</para>
		<para>12. If time permits (or if you are waiting for other students to finish this practice), take a look at linux system scripts in /etc/init.d and /etc/rc.d and try to understand them. Where does execution of a script start in /etc/init.d/samba ? There are also some hidden scripts in ~, we will discuss them later.</para>
		<para></para>
		<para></para>	
	</section>
	<section><title>Solutions</title>
		<para>11. A script with a case insensitive case statement, using the shopt nocasematch option. The nocasematch option is reset to the value it had before the scripts started.</para>
		<screen>
#!/bin/bash
#
# Wild Animals Case Insensitive Helpdesk Advice
#

if shopt -q nocasematch; then
  nocase=yes;
else
  nocase=no;
  shopt -s nocasematch;
fi

echo -n "What animal did you see ? "
read animal

case $animal in
		"lion" | "tiger")
				echo "You better start running fast!"
		;;
		"cat")
				echo "Let that mouse go..."
		;;
		"dog")
				echo "Don't worry, give it a cookie."
		;;
		"chicken" | "goose" | "duck" )
				echo "Eggs for breakfast!"
		;;
		"liger")
				echo "Approach and say 'Ah you big fluffy kitty.'"
		;;
		"babelfish")
				echo "Did it fall out your ear ?"
		;;
		*)
				echo "You discovered an unknown animal, name it!"
		;;
esac

if [ nocase = yes ] ; then
        shopt -s nocasematch;
else
        shopt -u nocasematch;
fi
		</screen>
	</section>
</chapter>
<chapter><title>Process Management</title>
	<section><title>About processes</title>
		<para>A <command>process</command> is compiled source code that is currently running on the system. All processes have a <command>process ID</command> or <command>PID</command>, and a parent process (with a <command>PPID</command>). The <command>child</command> process is often started by the <command>parent</command> process. The <command>init</command> process always has process ID 1, and does not have a parent. But init serves as a <command>foster parent</command> for <command>orphaned</command> processes. When a process stops running, the process dies, when you want a process to die, you <command>kill</command> it. Processes that start at system startup and keep running forever are called <command>daemon</command> processes. Daemons never die. When a process is killed, but it still shows up on the system, then the process is referred to as <command>zombie</command>. You cannot kill zombies, because they are already dead.</para>
		<para>Some shell environment variables contain information about processes. The $$ variable will hold your current process ID (PID), and $PPID contains the parent PID. Actually $$ is a shell parameter and not a variable, you cannot assign a value to $$.</para>
		<screen>
[paul@RHEL4b ~]$ echo $$ $PPID
4224 4223
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $$ $PPID
4812 4224
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $$ $PPID
4830 4812
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $$ $PPID
4812 4224
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $$ $PPID
4224 4223
[paul@RHEL4b ~]$
		</screen>
		<para>A process starts another process in two fases. First the process creates a <command>fork</command> of itself, an identical copy. Then the forked process executes an <command>exec</command> to replace the forked process with the target child process.</para>
		<screen>
[paul@RHEL4b ~]$ echo $$
4224
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $$ $PPID
5310 4224
[paul@RHEL4b ~]$ </screen>
		<para>With the <command>exec</command> command, you can execute a process without forking a new process. In the following screenshot i start a Korn shell (ksh) and replace it with a bash shell using the exec command. The PID of the bash shell is the same as the PID of the Korn shell. Exiting the child bash shell will get me back to the parent bash, not to the Korn (which does not exist anymore).</para>
		<screen>
[paul@RHEL4b ~]$ echo $$
4224
[paul@RHEL4b ~]$ ksh
$ echo $$ $PPID
5343 4224
$ exec bash
[paul@RHEL4b ~]$ echo $$ $PPID
5343 4224
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ echo $$
4224
		</screen>
	</section>
	<section><title>ps</title>
		<para>One of the most common tools on Unix to look at processes is <command>ps</command>. The following screenshot shows the parent child relationship between three bash processes.</para>
		<screen>
[paul@RHEL4b ~]$ echo $$ $PPID
4224 4223
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $$ $PPID
4866 4224
[paul@RHEL4b ~]$ bash
[paul@RHEL4b ~]$ echo $$ $PPID
4884 4866
[paul@RHEL4b ~]$ ps fx
  PID TTY      STAT   TIME COMMAND
 4223 ?        S      0:01 sshd: paul@pts/0 
 4224 pts/0    Ss     0:00  \_ -bash
 4866 pts/0    S      0:00      \_ bash
 4884 pts/0    S      0:00          \_ bash
 4902 pts/0    R+     0:00              \_ ps fx
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ ps fx
  PID TTY      STAT   TIME COMMAND
 4223 ?        S      0:01 sshd: paul@pts/0 
 4224 pts/0    Ss     0:00  \_ -bash
 4866 pts/0    S      0:00      \_ bash
 4903 pts/0    R+     0:00          \_ ps fx
[paul@RHEL4b ~]$ exit
exit
[paul@RHEL4b ~]$ ps fx
  PID TTY      STAT   TIME COMMAND
 4223 ?        S      0:01 sshd: paul@pts/0 
 4224 pts/0    Ss     0:00  \_ -bash
 4904 pts/0    R+     0:00      \_ ps fx
[paul@RHEL4b ~]$ 		</screen>
		<para>On Linux, <command>ps fax</command> is often used. On Solaris <command>ps -ef</command> is common. Here is a partial output from ps fax.</para>
		<screen>
[paul@RHEL4a ~]$ ps fax
PID TTY      STAT   TIME COMMAND
1 ?        S      0:00 init [5]                                             

...

3713 ?        Ss     0:00 /usr/sbin/sshd
5042 ?        Ss     0:00  \_ sshd: paul [priv]
5044 ?        S      0:00      \_ sshd: paul@pts/1 
5045 pts/1    Ss     0:00          \_ -bash
5077 pts/1    R+     0:00              \_ ps fax
		</screen>
	</section>
	<section><title>top</title>
		<para>Another popular tool on Linux is <command>top</command>. The <command>top</command> tool can order processes according to CPU usage or other properties. You can also kill processes from within top. In case of trouble, top is often the first tool to fire up, since it also provides you memory and swap space information.</para>
	</section>
	<section><title>priority and nice values</title>
		<para>All processes have a certain <command>priority</command> and a <command>nice</command> value. Higher priority processes will get more CPU time than low priority processes. You can influence this with the <command>nice</command> and <command>renice</command> commands.</para>
		<para>The <command>top</command> screenshot below shows four processes, all of then using approximately 25 percent of the CPU. PID 5087 and 5088 are catting the letter x to each other, PID 5090 and 5091 do the same with the letter z.</para>
		<screen>
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND            
5088 paul      25   0  4128  404  348 R 25.6  0.2   0:13.99 cat                
5091 paul      25   0  3628  400  348 R 25.6  0.2   0:07.99 cat                
5090 paul      15   0  4484  404  348 S 24.6  0.2   0:07.78 cat                
5087 paul      15   0  3932  400  348 S 24.3  0.2   0:14.16 cat 
		</screen>
		<para>Since the processes are already running, we need to use the <command>renice</command> command to change their nice value. The <command>nice</command> command can only be used when starting a process. The screenshot below shows how to make two running processes nice.</para>
		<screen>
[paul@RHEL4a ~]$ renice +5 5090
5090: old priority 0, new priority 5
[paul@RHEL4a ~]$ renice +5 5091
5091: old priority 0, new priority 5
		</screen>
		<para>Two processes (5090 and 5091) are playing nice now, they allow other processes to use more CPU time.</para>
		<screen>
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND            
5087 paul      15   0  3932  400  348 S 37.3  0.2   1:19.97 cat                
5088 paul      25   0  4128  404  348 R 36.6  0.2   1:19.20 cat                
5090 paul      21   5  4484  404  348 S 13.7  0.2   1:10.64 cat                
5091 paul      29   5  3628  400  348 R 12.7  0.2   1:10.64 cat   
		</screen>
		<para>Be careful when playing with negative nice values (the range is from -20 to 19), the responsiveness of your system can be affected. Luckily only root can issue negative nice values, in other words, you can only lower the priority of your running processes.</para>
	</section>
	<section><title>signals</title>
		<para>Running processes can receive signals from each other, or from the users. You can have a list of signals by typing <command>kill -l</command>, that is a letter l, not the number 1.</para>
		<screen>
[paul@RHEL4a ~]$ kill -l
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD
18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN
22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO
30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1
36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5
40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9
44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13
52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9
56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5
60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1
64) SIGRTMAX
[paul@RHEL4a ~]$ 
		</screen>
		<para>It is common on Linux to use the first signal SIGHUP (or HUP or 1) to tell a process that it should re-read its configuration file. Thus, the <command>kill -1 1</command> command forces the init process to re-read its configuration file. It is up to the developer of the process to decide whether the process can do this running, or whether it needs to stop and start. The <command>killall</command> command will also default to sending a signal 15 to the processes.</para>
		<para>The SIGTERM (15) is used to ask a process to stop running, normally the process should die. If it refuses to die, then you can issue the <command>kill -9</command> command (aka the <command>sure kill</command>). The SIGKILL (9) signal is the only one that a developer cannot intercept. The signal goes directly to the kernel, which will stop the running process (without giving it a chance to save data). When using the kill command without specifying a signal, it defaults to SIGTERM (15). </para>
		<screen>
[paul@RHEL4a ~]$ ps fax | grep cat
5087 pts/1    S     10:04              \_ cat - pipe1
5088 pts/1    R     10:06              \_ cat
5090 pts/1    SN     4:26              \_ cat - pipe3
5091 pts/1    RN     4:28              \_ cat
5220 pts/1    S+     0:00              \_ grep cat
[paul@RHEL4a ~]$ kill 5087
[1]   Terminated              echo -n x | cat - pipe1 >pipe2
[paul@RHEL4a ~]$
		</screen>
	</section>
	<section><title>jobs</title>
		<para>Some processes can be frozen with the <command>Ctrl-Z</command> key combination. This sends a SIGSTOP to the process. When doing this in vi, the vi goes to the background, and can be seen with the <command>jobs</command> command. Processes started with an ampersand (&#038;) at the end of the command line can also be seen with <command>jobs</command>.</para>
		<screen>
[paul@RHEL4a ~]$ vi procdemo.txt

[5]+  Stopped                 vim procdemo.txt
[paul@RHEL4a ~]$ jobs
[5]+  Stopped                 vim procdemo.txt
[paul@RHEL4a ~]$ find / &#062; allfiles.txt 2&#062; /dev/null &#038;
[6] 5230
[paul@RHEL4a ~]$ jobs
[5]+  Stopped                 vim procdemo.txt
[6]-  Running                 find / &#062;allfiles.txt 2&#062;/dev/null &#038;
[paul@RHEL4a ~]$
		</screen>
		<para>Running the <command>fg 5</command> command would bring the background job with number 5 to the foreground.</para>
		<para>An interesting option is <command>jobs -p</command> to see the PID of background jobs.</para>
		<screen>
[paul@RHEL4b ~]$ sleep 500 &#038;
[1] 4902
[paul@RHEL4b ~]$ sleep 400 &#038;
[2] 4903
[paul@RHEL4b ~]$ jobs -p
4902
4903
[paul@RHEL4b ~]$ ps `jobs -p`
  PID TTY      STAT   TIME COMMAND
 4902 pts/0    S      0:00 sleep 500
 4903 pts/0    S      0:00 sleep 400
[paul@RHEL4b ~]$
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Explain in detail where the numbers come from in the next screenshot. When are the variables replaced by their value ? By which shell ?</para>
		<screen>
[paul@RHEL4b ~]$ echo $$ $PPID
4224 4223
[paul@RHEL4b ~]$ bash -c "echo $$ $PPID"
4224 4223
[paul@RHEL4b ~]$ bash -c 'echo $$ $PPID'
5059 4224
		</screen>
		<para>2. Write a script that echoes its process ID and then sleeps for an hour. Find your script with ps.</para>
		<para>3. Read the man page of ps and find your script by name with ps.</para>
		<para>4. Kill your script with the kill command.</para>
		<para>5. Run your script again, now use top to display only your script and the init process.</para>
		<para>6. Use top to kill your script.</para>
		<para>7. Use top, organise all processes by memory usage.</para>
		<para>8. Write a script with a 'while true' loop that does some calculation. Copy this script.</para>
		<para>9. Start the while script. Start the copy of it in a nice way. Do you see the difference with top ? with ps ?</para>
		<para>10. Kill all your running scripts.</para>
		<para>11. Start editing the while script, put it in background. Same for the copy script. List your background jobs.</para>
		<para>12. Start the sleep script in background. List the background jobs. Activate the copy script to foreground.</para>
		<para></para>
		<para></para>	
	</section>
	<section><title>Solutions to the Practice</title>
		<para>1. The current bash shell will replace the $$ and $PPID while scanning the line, and before executing the echo command.</para>
		<screen>
			[paul@RHEL4b ~]$ echo $$ $PPID
			4224 4223
		</screen>
		<para>The variables are now double quoted, but the current bash shell will replace $$ and $PPID while scanning the line, and before executing the bach -c command.</para>
		<screen>
			[paul@RHEL4b ~]$ bash -c "echo $$ $PPID"
			4224 4223
		</screen>
		<para>The variables are now single quoted. The current bash shell will not replace the $$ and the $PPID. The bash -c command will be executed before the variables replaced with their value. This latter bash is the one replacing the $$ and $PPID with their value.</para>
		<screen>
			[paul@RHEL4b ~]$ bash -c 'echo $$ $PPID'
			5059 4224
		</screen>
		<para></para>
		<para></para>	
	</section>
</chapter>
<chapter><title>More Bash</title>
	<section><title>bash shell environment</title>
		<para>It is nice to have all these preset and custom aliases and variables, but where do they all come from ? Bash has a number of startup files that are checked (and executed) whenever bash is invoked. Bash first reads and executes <command>/etc/profile</command>. Then bash searches for <command>.bash_profile</command>, <command>.bash_login</command> and <command>.profile</command> in the home directory. Bash will execute the first of these three that it finds. Typically these files will expand your $PATH environment variable.</para>
		<screen>
[paul@RHELv4u3 ~]$ cat .bash_profile | grep PATH
PATH=$PATH:$HOME/bin
export PATH
[paul@RHELv4u3 ~]$
		</screen>
		<para>If this is an interactive shell, then bash will also execute <command>.bashrc</command>. In the case of Red Hat, the .bashrc file will source <command>/etc/bashrc</command>.</para>
		<screen>
[paul@RHELv4u3 ~]$ cat .bashrc 
# .bashrc

# User specific aliases and functions

# Source global definitions
if [ -f /etc/bashrc ]; then
. /etc/bashrc
fi
[paul@RHELv4u3 ~]$ 
		</screen>
		<para>When you exit the shell, then <command>~/.bash_logout</command> is executed.</para>
		<para>A similar system exists for the Korn shell with .kshrc and other files. Actually a similar system exists for almost all shells.</para>
	</section>
	<section><title>path</title>
		<para>The <command>$PATH</command> variable is very important, it determines where the shell is looking for commands to execute (unless the command is built-in). The shell will not look in the current directory for commands to execute! (Looking for executables in the current directory provided an easy way to crack DOS computers). If you want the shell to look in the current directory, then add a . to your path.</para>
		<screen>
[[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/paul/bin
[paul@RHEL4b ~]$ PATH=$PATH:.
[paul@RHEL4b ~]$ echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/paul/bin:.
[paul@RHEL4b ~]$ 
		</screen>
		<para>Your path might be different when using su instead of <command>su -</command> because the latter will take on the environment of the target user. The root user will have some sbin directories added to the PATH variable.</para>
		<screen>
[paul@RHEL3 ~]$ su
Password: 
[root@RHEL3 paul]# echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin
[root@RHEL3 paul]# exit
[paul@RHEL3 ~]$ su -
Password: 
[root@RHEL3 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin
[root@RHEL3 ~]#
		</screen>
	</section>
	<section><title>Shell I/O redirection</title>
		<para>The shell (and almost every other Linux command) takes input from <command>stdin</command> and sends output to <command>stdout</command> and error messages to <command>stderr</command>. Stdin is usually the keyboard, stdout and stderr are the screen. The shell allows you to redirect these streams.</para>
		<section><title>output redirection</title>
			<para>Stdout can be redirected with a <command>greater than</command> sign. While scanning the line, the shell will see the <command>&#062;</command> sign and will clear the file.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo It is cold today!
It is cold today!
[paul@RHELv4u3 ~]$ echo It is cold today! &#062; winter.txt
[paul@RHELv4u3 ~]$ cat winter.txt 
It is cold today!
[paul@RHELv4u3 ~]$
			</screen>
			<para>Let me repeat myself here: While scanning the line, the shell will see the &#062; sign and will clear the file! This means that even when the command fails, the file will be cleared!</para>
			<screen>
[paul@RHELv4u3 ~]$ cat winter.txt 
It is cold today!
[paul@RHELv4u3 ~]$ zcho It is cold today! &#062; winter.txt
-bash: zcho: command not found
[paul@RHELv4u3 ~]$ cat winter.txt 
[paul@RHELv4u3 ~]$ 
			</screen>
		</section>
		<section><title>noclobber</title>
			<para>This can be prevented by setting the <command>noclobber</command> option.</para>
			<screen>
[paul@RHELv4u3 ~]$ cat winter.txt 
It is cold today!
[paul@RHELv4u3 ~]$ set -o noclobber
[paul@RHELv4u3 ~]$ echo It is cold today! &#062; winter.txt
-bash: winter.txt: cannot overwrite existing file
[paul@RHELv4u3 ~]$ set +o noclobber
[paul@RHELv4u3 ~]$
			</screen>
			<para>The noclobber can be overruled with <command>&#062;|</command>.</para>
			<screen>
[paul@RHELv4u3 ~]$ set -o noclobber
[paul@RHELv4u3 ~]$ echo It is cold today! &#062; winter.txt
-bash: winter.txt: cannot overwrite existing file
[paul@RHELv4u3 ~]$ echo It is very cold today! &#062;| winter.txt
[paul@RHELv4u3 ~]$ cat winter.txt 
It is very cold today!
[paul@RHELv4u3 ~]$ 
			</screen>
		</section>
		<section><title>append</title>
			<para>You can always use <command>&#062;&#062;</command> to append output to a file.</para>
			<screen>
[paul@RHELv4u3 ~]$ echo It is cold today! &#062; winter.txt
[paul@RHELv4u3 ~]$ cat winter.txt 
It is cold today!
[paul@RHELv4u3 ~]$ echo Where is the summer ? &#062;&#062; winter.txt
[paul@RHELv4u3 ~]$ cat winter.txt 
It is cold today!
Where is the summer ?
[paul@RHELv4u3 ~]$ 
			</screen>
		</section>
		<section><title>error redirection</title>
			<para>Redirecting stderr is done with <command>2&#062;</command>. This can be very useful to prevent error messages from cluttering your screen. The screenshot below shows redirection of stdout to a file, and stderr to /dev/null. Writing <command>1&#062;</command> is the same as &#062;.</para>
			<screen>
[paul@RHELv4u3 ~]$ find / > allfiles.txt 2&#062; /dev/null
[paul@RHELv4u3 ~]$ 
			</screen>
			<para>To redirect both stdout and stderr to the same file, use <command>2>&#038;1</command>.</para>
			<screen>
[paul@RHELv4u3 ~]$ find / &#062; allfiles_and_errors.txt 2&#062;&#038;1
[paul@RHELv4u3 ~]$
			</screen>
		</section>
		<section><title>input redirection</title>
			<para>Redirecting stdin is done with &#060; .</para>
			<screen>
[paul@RHEL4b ~]$ cat &#060; text.txt
one
two
[paul@RHEL4b ~]$ tr 'onetw' 'ONEZZ' &#060; text.txt
ONE
ZZO
[paul@RHEL4b ~]$ 			
			</screen>
		</section>
		<section><title>here document</title>
			<para>The here document (sometimes called here-is-document) is a way to append input until a certain sequence (usually EOF) is encountered. The <command>EOF</command> marker can be typed literally or can be called with Ctrl-D.</para>
			<screen>
[paul@RHEL4b ~]$ cat &#060;&#060;EOF &#062; text.txt
> one
> two
> EOF
[paul@RHEL4b ~]$ cat text.txt 
one
two
[paul@RHEL4b ~]$ cat &#060;&#060;brol &#062; text.txt
> brel
> brol
[paul@RHEL4b ~]$ cat text.txt 
brel
[paul@RHEL4b ~]$
			</screen>
		</section>
	</section>
	<section><title>Confusing I/O redirection</title>
		<para>The shell will scan the whole line before applying redirection. The following command line is very readable and is correct.</para>
		<screen>cat winter.txt &#062; snow.txt 2&#062; errors.txt</screen>
		<para>But this one is also correct, but less readable.</para>
		<screen>2&#062; errors.txt cat winter.txt &#062; snow.txt</screen>
		<para>Even this will be understood perfectly by the shell.</para>
		<screen>&#060; winter.txt &#062; snow.txt 2&#062; errors.txt cat</screen>
		<para>So what is the quickest way to clear a file ?</para>
		<screen>>foo</screen>
	</section>
	<section><title>Practice: more bash</title>
		<para>1. Take a backup copy of /etc/bashrc /etc/profile ~/.profile ~/.bashrc ~/.bash_profile (put them in ~/profilebackups).</para>
		<para>2. Set and export a variable named profwinner in all these scripts, the value is the name of the script (profwinner=etc_bashrc in /etc/bashrc, profwinner=dot_profile in ~/.profile, and so on) </para>
		<para>3. Set a unique variable in all these scripts (etc_bashrun=yes in /etc/bashrc, dot_profilerun=yes in ~/.profile, and so on)</para>
		<para>4. Log on to a tty and to a gnome-terminal, and verify the values of the variables you set in questions 2 and 3. Which of the scripts were executed ? Which not ? Which was executed last ?</para>
		<para>5. Does it matter on which line we set our variables in .bash_profile and .bashrc ?</para>
		<para>6. Where is the command history stored ? And what about command history for Korn users ?</para>
		<para>7. Define an alias 'dog' for the tac command in one of your profile scripts. Which script did you choose and why ?</para>
		<para></para>
		<para></para>
	</section>
</chapter>
<chapter><title>Pipes and filters</title>
	<section><title>pipes</title>
		<para>One of the most powerful advantages of unix is the use of <command>pipes</command>, and the ability of almost any program to be used in a pipe. A pipe takes <command>stdout</command> from the previous command and sends it as <command>stdin</command> to the next command in the pipe. Pipes can have many commands, and all commands in a pipe can be running simultaneously.</para>
		<para> What follows after the introduction to pipes is a number of small unix tools that do one specific task very well. These can be used as building blocks for more complex applications and solutions.</para>
		<para>You still remember cat and tac right ?</para>
		<screen>
[paul@RHEL4b pipes]$ cat count.txt 
one
two
three
four
five
[paul@RHEL4b pipes]$ tac count.txt 
five
four
three
two
one
[paul@RHEL4b pipes]$
		</screen>
		<para>A pipe is represented by a vertical bar <command>&#124;</command> in between two commands. Below a very simple pipe.</para>
		<screen>
[paul@RHEL4b pipes]$ cat count.txt | tac
five
four
three
two
one
[paul@RHEL4b pipes]$ 
		</screen>
		<para>But pipes can be longer, as in this example.</para>
		<screen>
[paul@RHEL4b pipes]$ cat count.txt | tac | tac
one
two
three
four
five
[paul@RHEL4b pipes]$ 
		</screen>
		<para>Remember that I told you in the beginning of this book that the cat command is actually doing nothing ?</para>
		<screen>
[paul@RHEL4b pipes]$ tac count.txt | cat | cat | cat | cat | cat
five
four
three
two
one
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>tee</title>
		<para>Writing long pipes in unix is fun, but sometimes you might want intermediate results. This is were <command>tee</command> comes in handy, tee outputs both to a file and to stdout. So tee is almost the same as cat, except that it has two identical outputs.</para>
		<screen>
[paul@RHEL4b pipes]$ tac count.txt | tee temp.txt | tac
one
two
three
four
five
[paul@RHEL4b pipes]$ cat temp.txt 
five
four
three
two
one
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>grep</title>
		<para>Time for the real tools now. With all the uses of <command>grep</command> you can probably fill a book. The most common use of grep is to filter results on keywords.</para>
		<screen>
[paul@RHEL4b pipes]$ cat tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | grep Williams
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
		</screen>
		<para>You can write this without the cat.</para>
		<screen>
[paul@RHEL4b pipes]$ grep Williams tennis.txt 
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
		</screen>
		<para>One of the most useful options of grep is <command>grep -i</command> which filters in a case insensitive way.</para>
		<screen>
[paul@RHEL4b pipes]$ grep Bel tennis.txt 
Justine Henin, Bel
[paul@RHEL4b pipes]$ grep -i Bel tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$ 
		</screen>
		<para>Another very useful option is <command>grep -v</command> which outputs lines not matching the string.</para>
		<screen>
[paul@RHEL4b pipes]$ grep -v Fra tennis.txt 
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
		</screen>
		<para>And of course, both options can be combined.</para>
		<screen>
[paul@RHEL4b pipes]$ grep -vi usa tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>cut</title>
		<para>With <command>cut</command> you can select columns from files, depending on a delimiter or a count of bytes. The screenshot below uses cut to filter for the username and userid in the /etc/passwd file. It uses the colon as a delimiter, and select fields 1 and 3.</para>
		<screen>
[[paul@RHEL4b pipes]$ cut -d: -f1,3 /etc/passwd | tail -4 
Figo:510
Pfaff:511
Harry:516
Hermione:517
[paul@RHEL4b pipes]$ 
		</screen>
		<para>When using a space as the delimiter for cut, you have to quote the space.</para>
		<screen>
[paul@RHEL4b pipes]$ cut -d" " -f1 tennis.txt 
Amelie
Kim
Justine
Serena
Venus
[paul@RHEL4b pipes]$
		</screen>
		<para>One last example, cutting the second to the seventh character of /etc/passwd.</para>
		<screen>
[paul@RHEL4b pipes]$ cut -c2-7 /etc/passwd | tail -4
igo:x:
faff:x
arry:x
ermion
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>tr</title>
		<para>You can translate characters with <command>tr</command>. The screenshot translates all occurences of e to E.</para>
		<screen>
[paul@RHEL4b pipes]$ cat tennis.txt 
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'e' 'E'
AmEliE MaurEsmo, Fra
Kim ClijstErs, BEL
JustinE HEnin, BEl
SErEna Williams, usa
VEnus Williams, USA
[paul@RHEL4b pipes]$
		</screen>
		<para>Here we set all letters to uppercase by defining two ranges.</para>
		<screen>
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'a-z' 'A-Z'
AMELIE MAURESMO, FRA
KIM CLIJSTERS, BEL
JUSTINE HENIN, BEL
SERENA WILLIAMS, USA
VENUS WILLIAMS, USA
[paul@RHEL4b pipes]$
		</screen>
		<para>Here we translate all newlines to spaces.</para>
		<screen>
[paul@RHEL4b pipes]$ cat count.txt 
one
two
three
four
five
[paul@RHEL4b pipes]$ cat count.txt | tr '\n' ' '
one two three four five [paul@RHEL4b pipes]$
		</screen>
		<para>The tr filter can also be used to squeeze multiple occurences of a character to one.</para>
		<screen>
[paul@RHEL4b pipes]$ cat spaces.txt 
one    two        three
     four   five  six
[paul@RHEL4b pipes]$ cat spaces.txt | tr -s ' '
one two three
 four five six
[paul@RHEL4b pipes]$
		</screen>
		<para>You can also use tr to 'encrypt' texts with rot13.</para>
		<screen>
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'nopqrstuvwxyzabcdefghijklm'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'n-za-m'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ 
		</screen>
	</section>
	<section><title>wc</title>
		<para>Counting words, lines and characters is easy with <command>wc</command>. </para>
		<screen>
[paul@RHEL4b pipes]$ wc tennis.txt 
  5  15 100 tennis.txt
[paul@RHEL4b pipes]$ wc -l tennis.txt 
5 tennis.txt
[paul@RHEL4b pipes]$ wc -w tennis.txt 
15 tennis.txt
[paul@RHEL4b pipes]$ wc -c tennis.txt 
100 tennis.txt
[paul@RHEL4b pipes]$
		</screen>
		<para>How many users are logged on to this system ?</para>
		<screen>
[paul@RHEL4b pipes]$ who
root     tty1         Jul 25 10:50
paul     pts/0        Jul 25 09:29 (laika)
Harry    pts/1        Jul 25 12:26 (barry)
paul     pts/2        Jul 25 12:26 (pasha)
[paul@RHEL4b pipes]$ who | wc -l
4
[paul@RHEL4b pipes]$ 
		</screen>
	</section>
	<section><title>sort</title>
		<para>Sorting is always useful. The <command>sort</command> filter has a lot of options. How about a sorted list of logged on users.</para>
		<screen>
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root
[paul@RHEL4b pipes]$
		</screen>
		<para>Sorting on column 1 or column 2.</para>
		<screen>
[paul@RHEL4b pipes]$ sort -k1 country.txt 
Belgium, Brussels, 10
France, Paris, 60
Germany, Berlin, 100
Iran, Teheran, 70
Italy, Rome, 50
[paul@RHEL4b pipes]$ sort -k2 country.txt 
Germany, Berlin, 100
Belgium, Brussels, 10
France, Paris, 60
Italy, Rome, 50
Iran, Teheran, 70
[paul@RHEL4b pipes]$ 
		</screen>
		<para>The screenshot below shows the difference between an alfabetical sort and a numerical sort (both on the third column).</para>
		<screen>
[paul@RHEL4b pipes]$ sort -k3 country.txt 
Belgium, Brussels, 10
Germany, Berlin, 100
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
[paul@RHEL4b pipes]$ sort -n -k3 country.txt 
Belgium, Brussels, 10
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
Germany, Berlin, 100
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>uniq</title>
		<para>With <command>uniq</command> you can remove duplicates from a sorted list. Here's a sorted list of logged on users, first with and then without duplicates.</para>
		<screen>
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort | uniq
Harry
paul
root
[paul@RHEL4b pipes]$
		</screen>
	</section>
	<section><title>find</title>
		<para>The <command></command>find tool is used very often in linux. Find is useful at the start of a pipe, to search for files. Here are some examples. In real life, you will want to add 2&#062;/dev/null to the command lines to avoid cluttering your screen with error messages.</para>
		<para>Find all files in /etc and put the list in etcfiles.txt</para>
		<screen>find /etc &#062; etcfiles.txt</screen>
		<para>Find all files of the entire system and put the list in allfiles.txt</para>
		<screen>find / &#062; allfiles.txt</screen>
		<para>Find files that end in .conf in the current directory (and all subdirs).</para>
		<screen>find . -name "*.conf"</screen>
		<para>Find files of type file (so not directory or pipe...) that end in .conf.</para>
		<screen>find . -type f -name "*.conf"</screen>
		<para>Find files of type directory that end in .bak.</para>
		<screen>find /data -type d -name "*.bak"</screen>
		<para>Find files that are newer than file44.txt</para>
		<screen>find . -newer fil44.txt</screen>
		<para>Find can also execute another command on every file found. This example will look for *.odf files and copy them to /backup/.</para>
		<screen>find "/data/*.odf" -exec cp {} /backup/ \;</screen>
		<para>Find can also execute, after your confirmation, another command on every file found. This example will remove *.odf files if you approve of it for every file found.</para>
		<screen>find "/data/*.odf" -ok rm {} \;</screen>
		<para>The find tool can do much more, see the man page.</para>
	</section>
	<section><title>locate</title>
		<para>The locate tool is very different from <command>find</command> in that it uses an index to locate files. This is a lot faster than traversing all the directories, but it also means that it is always outdated. If the index does not exist yet, then you have to create it (as root on Red Hat Enterprise Linux) with the <command>updatedb</command> command.</para>
		<screen>
[paul@RHEL4b ~]$ locate Samba
warning: locate: could not open database: /var/lib/slocate/slocate.db: No such file or directory
warning: You need to run the 'updatedb' command (as root) to create the database.
Please have a look at /etc/updatedb.conf to enable the daily cron job.
[paul@RHEL4b ~]$ updatedb 
fatal error: updatedb: You are not authorized to create a default slocate database!
[paul@RHEL4b ~]$ su -
Password: 
[root@RHEL4b ~]# updatedb
[root@RHEL4b ~]# 
		</screen>
	</section>
	<section><title>diff</title>
		<para>To compare two files line by line, you can use <command>diff</command>. To ignore blanks, use <command>diff -b</command>, and to ignore case, use <command>diff -i</command>.</para>
		<para>In this examples diff tells you 2c2 the second line in file one was changed with the second line in file two.</para>
		<screen>
[paul@RHEL4b test]$ cat &#062; count.txt
one
two
three
four
[paul@RHEL4b test]$ cat &#062; count2.txt
one
Two
three
four
[paul@RHEL4b test]$ diff count.txt count2.txt 
2c2
< two
---
> Two
[paul@RHEL4b test]$
		</screen>
		<para>Another example of diff. The second file now has one more line than the first file. After line 2, a line was added as line 3 (2a3) to the second file.</para>
		<screen>
[paul@RHEL4b test]$ cat &#062; count.txt 
one
two
four
[paul@RHEL4b test]$ cat &#062; count2.txt 
one
two
three
four
[paul@RHEL4b test]$ diff count.txt count2.txt 
2a3
> three
[paul@RHEL4b test]$
		</screen>
	</section>
	<section><title>comm</title>
		<para>You can use <command>comm</command> to quickly compare two sorted files. By default comm will output three columns. In this example, Abba, Cure and Queen are in both lists, Bowie and Sweet are only in the first file, Turner is only in the second.</para>
		<screen>
[paul@RHEL4b test]$ cat &#062; list1.txt
Abba
Bowie
Cure
Queen
Sweet
[paul@RHEL4b test]$ cat &#062; list2.txt
Abba
Cure
Queen
Turner
[paul@RHEL4b test]$ comm list1.txt list2.txt 
                Abba
Bowie
                Cure
                Queen
Sweet
        Turner
[paul@RHEL4b test]$ 			
	       </screen>
	</section>
	<section><title>compress</title>
		<para>Users never have enough space, so compression comes in handy. The <command>compress</command> command can make files take up less space. You can get the original back with <command>uncompress</command>. In the backup chapter we will also discuss gzip, gunzip, bzip2 and bunzip2.</para>
		<screen>
[paul@RHEL4b test]$ ls -lh
total 19M
-rw-rw-r--  1 paul paul 19M Jul 26 04:21 allfiles.txt
[paul@RHEL4b test]$ compress allfiles.txt 
[paul@RHEL4b test]$ ls -lh
total 3.2M
-rw-rw-r--  1 paul paul 3.2M Jul 26 04:21 allfiles.txt.Z
[paul@RHEL4b test]$ uncompress allfiles.txt 
[paul@RHEL4b test]$ ls -lh
total 19M
-rw-rw-r--  1 paul paul 19M Jul 26 04:21 allfiles.txt
[paul@RHEL4b test]$ 
		</screen>
	</section>
	<section><title>od</title>
		<para>European humans like to work with ascii characters, but computers store files in bytes. The example below creates a simple file, and then uses <command>od</command> to show the contents of the file in hexadecimal bytes, in octal bytes and in ascii (or backslashed) characters.</para>
		<screen>
paul@laika:~/test$ cat > text.txt
abcdefg
1234567
paul@laika:~/test$ od -t x1 text.txt 
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020
paul@laika:~/test$ od -b text.txt 
0000000 141 142 143 144 145 146 147 012 061 062 063 064 065 066 067 012
0000020
paul@laika:~/test$ od -c text.txt 
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
paul@laika:~/test$
		</screen>
	</section>
	<section><title>other tools and filters</title>
		<para>You might want to look at expand, unexpand, pr, nl, fmt, paste, join, sed, awk, ...</para>
	</section>
	<section><title>Practice tools and filters</title>
	<para>1. Explain the difference between these two commands. This question is very important. If you don't know the answer, then look back at the bash chapters.</para>
	<screen>find . -name "*.txt"</screen>
	<screen>find . -name *.txt</screen>
	<para>2. Explain the difference between these two statements. Will they both work when there are 200 .odf files in /data/ ? How about when there are 2 million .odf files ?</para>
	<screen>find /data -name "*.odf" > data_odf.txt</screen>
	<screen>find /data/*.odf > data_odf.txt</screen>
	<para>3. Write a find command that finds all files created after january 30th this year.</para>	
	<para>4. Write a find command that finds all *.odf files created in september last year.</para>
	<para>5. Put a sorted list of all bash users in bashusers.txt.</para>
	<para>6. Put a sorted list of all bash users, with their username, userid and home directory in bashusers.info.</para>
	<para>7. Make a list of all non-bash and non-korn users.</para>
	<para>8. Make a list of all files (not directories) in /etc/ that contain the string smb, nmb or samba.</para>
	<para>9. Look at the output of /sbin/ifconfig. Make an ipconfig command that shows only the nic name (eth0), the ip address and the subnet mask.</para>
	<para>10. Make a command abc that removes all non-letters from a file (and replaces them with spaces).</para>
	<para>11. Count the number of *.conf files in /etc and all its subdirs.</para>	
	<para>12. Two commands that do the same thing: copy *.odf files to /backup/ . What would be a reason to replace the first command with the second ? Again, this is an important question.</para>
	<screen>cp -r /data/*.odf /backup/</screen>
	<screen>find /data -name "*.odf" -exec cp {} /backup/ \;</screen>
	<para>13. Create a file called loctest.txt. Can you find this file with locate ? Why not ? How do you make locate find this file ?</para>
	<para>14. Create a file named text.txt that contains this sentence: The zun is shining today. Create a file DICT that contains the words "is shining sun the today", one word on each line. The first file is a text, the second file is a dictionary. Now create a spell checker that uses those two files and outputs the misspelled words (in this case that would be 'zun').</para>
	<para>15. Use find and -exec to rename all .htm files to .html.</para>	
	<para>16. Find the hexadecimal byte value for ascii characters : " 'space' 'tab' A and a .</para>	
	<para>17. List all files in the current directory of size between 10 and 20 bytes.</para>
	<para></para>	
	<para></para>	
	</section>
	<section><title>Solutions: tools and filters</title>
		<para>1. The shell will not touch the *.txt because it is between double quotes. The find tool will look in the current directory for all files ending in .txt.</para>
		<screen>find . -name "*.txt"</screen>
		<para>The shell will expand the *.txt to all files in the current directory that end in .txt. Then find will give you a syntax error.</para>
		<screen>find . -name *.txt</screen>
		<para>14. The one line spell checker.</para>
		<screen>
[paul@RHEL4b]$ echo "The zun is shining today" > text.txt
[paul@RHEL4b]$ cat > DICT
is
shining
sun
the
today
[paul@RHEL4b]$ cat text.txt | tr 'A-Z ' 'a-z\n' | sort | uniq | comm -2 -3 - DICT
zun
[paul@RHEL4b]$
		</screen>
	</section>
</chapter>
<chapter><title>LPI 101 stuff</title>
	<section><title>Configure Fundamental BIOS Settings (LPI 1.101.1)</title>
		<para>The <command>booting</command> or <command>bootstrapping</command> of a computer is the process of reprogramming a pile of hardware components.</para>
		<section><title>Buses</title>
			<para>Hardware components communicate with the <command>Central Processing Unit</command> or <command>CPU</command> over a <command>bus</command>. The most common buses today are <command>USB</command>, <command>PCI</command>, <command>AGP</command>,  <command>PCI-Express</command> and <command>PCMCIA</command> aka <command>PC Card</command>. To list the buses recognized by your kernel on your computer, look at the contents of the <command>/proc/bus/</command> directory (screenshot from Ubuntu 7.04 and RHEL4u4 below).</para>
			<screen>
root@laika:~# ls /proc/bus/
input  pccard  pci  usb
			</screen>
			<screen>
[root@RHEL4b ~]# ls /proc/bus/
input  pci  usb
			</screen>
			<para>To list all the usb devices connected to your system, you could read the contents of <command>/proc/bus/usb/devices</command> or you could use the more readable output of <command>lsusb</command>, which is executed here on a SPARC system with Ubuntu.</para>
			<screen>
root@shaka:~# lsusb
Bus 001 Device 002: ID 0430:0100 Sun Microsystems, Inc. 3-button Mouse
Bus 001 Device 003: ID 0430:0005 Sun Microsystems, Inc. Type 6 Keyboard
Bus 001 Device 001: ID 04b0:0136 Nikon Corp. Coolpix 7900 (storage)
root@shaka:~#
			</screen>
			<para>To get a list of all pci devices connected, you could take a look at <command>/proc/pci</command> or run <command>lspci</command> (partial output below).</para>
			<screen>
paul@laika:~$ lspci
...
00:06.0 FireWire (IEEE 1394): Texas Instruments TSB43AB22/A IEEE-1394a-2000 Cont...
00:08.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8169 Gigabit Et...
00:09.0 Multimedia controller: Philips Semiconductors SAA7133/SAA7135 Video Broa...
00:0a.0 Network controller: RaLink RT2500 802.11g Cardbus/mini-PCI (rev 01)
00:0f.0 RAID bus controller: VIA Technologies, Inc. VIA VT6420 SATA RAID Control...
00:0f.1 IDE interface: VIA Technologies, Inc. VT82C586A/B/VT82C686/A/B/VT823x/A/...
00:10.0 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller...
00:10.1 USB Controller: VIA Technologies, Inc. VT82xxxxx UHCI USB 1.1 Controller...
...			</screen>
		</section>
		<section><title>Interrupts</title>
			<para>An <command>interrupt request</command> or <command>IRQ</command> is a request from a device to the CPU. A devices raises an interrupt when it requires the attention of the CPU (could be because the device has data ready to be read by the CPU). You can see a listing of interrupts on your system in <command>/proc/interrupts</command>. Since the introduction of pci, irq's can be shared among devices.</para>
			<screen>
paul@laika:~$ cat /proc/interrupts 
CPU0       CPU1       
0:    1320048        555   IO-APIC-edge      timer
1:      10224          7   IO-APIC-edge      i8042
7:          0          0   IO-APIC-edge      parport0
8:          2          1   IO-APIC-edge      rtc
10:       3062         21   IO-APIC-fasteoi   acpi
12:        131          2   IO-APIC-edge      i8042
15:      47073          0   IO-APIC-edge      ide1
18:          0          1   IO-APIC-fasteoi   yenta
19:      31056          1   IO-APIC-fasteoi   libata, ohci1394
20:      19042          1   IO-APIC-fasteoi   eth0
21:      44052          1   IO-APIC-fasteoi   uhci_hcd:usb1, uhci_hcd:usb2, ...
22:     188352          1   IO-APIC-fasteoi   ra0
23:     632444          1   IO-APIC-fasteoi   nvidia
24:       1585          1   IO-APIC-fasteoi   VIA82XX-MODEM, VIA8237
			</screen>
		</section>
		<section><title>IO Ports</title>
			<para>Communication in the other direction, from CPU to device, happens through <command>IO ports</command>. The CPU writes data or control codes to the IO port of the device. But this is not only a one way communication, the CPU can also use a device's IO port to read status information about the device. Unlike interrupts, ports cannot be shared!</para>
			<screen>
[root@RHEL4b ~]# cat /proc/ioports 
0000-001f : dma1
0020-0021 : pic1
0040-0043 : timer0
0050-0053 : timer1
0060-006f : keyboard
0070-0077 : rtc
0080-008f : dma page reg
00a0-00a1 : pic2
00c0-00df : dma2
00f0-00ff : fpu
0170-0177 : ide1
02f8-02ff : serial
...
			</screen>
		</section>
		<section><title>DMA</title>
			<para>A device that needs a lot of data, interrupts and ports can pose a heavy load on the CPU. With <command>DMA</command> or <command>Direct Memory Access</command> a device can gain (temporary) access to a specific range of the RAM memory. Looking at <command>/proc/dma</command> might not give you the information that you want, since it only contains currently assigned DMA channels for ISA devices.</para>
			<screen>
root@laika:~# cat /proc/dma 
1: parport0
4: cascade
			</screen>
			<para>PCI devices that are using dma are not listed in /proc/dma, in this case dmesg can be useful. The screenshot below shows that during boot the parallel port received dma channel 1, and the Infrared port received dma channel 3. </para>
			<screen>
root@laika:~# dmesg | egrep -C 1 'dma 1|dma 3'
[   20.576000] parport: PnPBIOS parport detected.
[   20.580000] parport0: PC-style at 0x378 (0x778), irq 7, dma 1 [PCSPP,TRISTATE,COMPAT,EPP,ECP,DMA]
[   20.764000] irda_init()
--
[   21.204000] pnp: Device 00:0b activated.
[   21.204000] nsc_ircc_pnp_probe() : From PnP, found firbase 0x2F8 ; irq 3 ; dma 3.
[   21.204000] nsc-ircc, chip->init
root@laika:~# 			</screen>
		</section>
	</section>
</chapter>

<chapter><title>Hard disk devices</title>
	<section><title>Terminology</title>
		<para>Data is commonly stored on magnetic or optical <command>disk platters</command>. The platters are rotated (at high speeds). Data is read by <command>heads</command>, which are very close to the surface of the platter, without touching it! The heads are mounted on an arm (sometimes called a comb).</para>
		<para>Data is written in concentric circles or <command>tracks</command>. Track zero is (usually ?) on the inside. The time it takes to position the head over a certain track is called the <command>seek time</command>. Often the platters are stacked on top of each other, hence the set of tracks accessible at a certain position of the comb forms a <command>cylinder</command>. Tracks are divided into 512 byte <command>sectors</command>, with more unused space (<command>gap</command>) between the sectors on the outside of the platter. </para>
		<para>When you break down the advertised <command>access time</command> of a hard drive, you will notice that most of that time is taken by movement of the heads (about 65%) and <command>rotational latency</command> (about 30%). </para>
		<para>Random access hard disk devices have an abstraction layer called <command>block device</command> to enable formatting in fixed-size (usually 512 bytes) blocks. Blocks can be accessed independent of access to other blocks. You can recognize a block device by the letter b as first character of ls -l.</para>
		<screen>
[root@RHEL4b ~]# ls -l /dev/sda*
brw-rw----  1 root disk 8, 0 Aug  4 22:55 /dev/sda
brw-rw----  1 root disk 8, 1 Aug  4 22:55 /dev/sda1
brw-rw----  1 root disk 8, 2 Aug  4 22:55 /dev/sda2
[root@RHEL4b ~]#
		</screen>
	</section>	
	<section><title>IDE or SCSI</title>
		<para>Actually, the title should be <command>ATA</command> or <command>SCSI</command>, since IDE is an ATA-compatible device. Most desktops use ATA devices. ATA allows two devices per bus, one <command>master</command> and one <command>slave</command>. Unless your controller and devices support <command>cable select</command>, you have to set this manually with jumpers. With the introduction of <command>SATA</command> (Serial ATA), the original ATA was renamed to <command>Parallel ATA</command>. Optical drives often use <command>atapi</command>, which is an ATA interface using the SCSI communication protocol.</para>
		<para>When using the <command>Small Computer System Interface</command>, each device gets a unique <command>SCSI ID</command>. The SCSI controller also needs a SCSI ID, do not use this ID for a SCSI-attached device. Older 8-bit SCSI is now called <command>narrow</command>, whereas 16-bit is <command>wide</command>. When the bus speeds was doubled to 10Mhz, this was known as <command>fast SCSI</command>. Doubling to 20Mhz made it <command>ultra SCSI</command>. Take a look at http://en.wikipedia.org/wiki/SCSI for more SCSI-standards. </para>
	</section>
	<section><title>Device Naming</title>
		<para>All ATA drives on your system will start with <command>/dev/hd</command> followed by a unit letter. The master hdd on the first ATA controller is /dev/hda, the slave is /dev/hdb. For the second controller, the names of the devices are /dev/hdc and /dev/hdd.</para>
		<para>SCSI drives follow a similar scheme, but all start with <command>/dev/sd</command>. When you run out of letters (after /dev/sdz), you can continue with /dev/sdaa and /dev/sdab and so on. (We will see later on that LVM volumes are commonly seen as /dev/md0, /dev/md1 etc)</para>
	</section>
	<section><title>Erasing a hard disk</title>
		<para>Before selling your old hard disk on the internet, it might be a good idea to really erase it. By simply repartitioning or even after a new mkfs command, some people will still be able to read most of the data on the disk. Although technically the <command>badblocks</command> tool is meant to look for bad blocks, you can use it to erase a disk. Since this is really writing to every sector of the disk, it can take a long time!</para>
		<screen>
root@RHELv4u2:~# badblocks -ws /dev/sdb
Testing with pattern 0xaa: done                        
Reading and comparing: done                        
Testing with pattern 0x55: done                        
Reading and comparing: done                        
Testing with pattern 0xff: done                        
Reading and comparing: done                        
Testing with pattern 0x00: done                        
Reading and comparing: done                        
		</screen>
	</section>
	<section><title>fdisk</title>
		<para>You can start by using <command>fdisk</command> to find out what kind of disks are seen by the kernel. Below the result on Debian, with two <command>ATA-IDE disks</command> present.</para>
		<screen>
root@barry:~# fdisk -l | grep Disk
Disk /dev/hda: 60.0 GB, 60022480896 bytes
Disk /dev/hdb: 81.9 GB, 81964302336 bytes
		</screen>
		<para>And here an example of <command>SATA disks</command> on a laptop with Ubuntu. SATA hard disks are presented to you with the SCSI /dev/sdx notation.</para>
		<screen>
root@laika:~# fdisk -l | grep Disk
Disk /dev/sda: 100.0 GB, 100030242816 bytes
Disk /dev/sdb: 100.0 GB, 100030242816 bytes
		</screen>
		<para>And last but not least, an overview of disks on a RHEL4u3 server with two real 72GB <command>SCSI disks</command>. This server is attached to a NAS with four <command>NAS disks</command> of half a terabyte. On the NAS disks, four LVM software RAID devices are configured.</para>
		<screen>
[root@tsvtl1 ~]# fdisk -l | grep Disk
Disk /dev/sda: 73.4 GB, 73407488000 bytes
Disk /dev/sdb: 73.4 GB, 73407488000 bytes
Disk /dev/sdc: 499.0 GB, 499036192768 bytes
Disk /dev/sdd: 499.0 GB, 499036192768 bytes
Disk /dev/sde: 499.0 GB, 499036192768 bytes
Disk /dev/sdf: 499.0 GB, 499036192768 bytes
Disk /dev/md0: 271 MB, 271319040 bytes
Disk /dev/md2: 21.4 GB, 21476081664 bytes
Disk /dev/md3: 21.4 GB, 21467889664 bytes
Disk /dev/md1: 21.4 GB, 21476081664 bytes
		</screen>
		<para>You can also use fdisk to obtain information about one specific hard disk device.</para>
		<screen>
[root@rhel4 ~]# fdisk -l /dev/sda

Disk /dev/sda: 12.8 GB, 12884901888 bytes
255 heads, 63 sectors/track, 1566 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          13      104391   83  Linux
/dev/sda2              14        1566    12474472+  8e  Linux LVM
		</screen>
		<para>Later we will use fdisk to do dangerous stuff like creating and deleting partitions.</para>
	</section>
	<section><title>hdparm</title>
		<para>To obtain (or set) information and parameters about an ATA (or SATA) hard disk device, you can use <command>hdparm</command>. The -i and -I options will give you even more information about the physical properties of the device.</para>
		<screen>
root@laika:~# hdparm /dev/sdb

/dev/sdb:
 IO_support   =  0 (default 16-bit)
 readonly     =  0 (off)
 readahead    = 256 (on)
 geometry     = 12161/255/63, sectors = 195371568, start = 0
		</screen>
	</section>
	<section><title>dmesg</title>
		<para>Kernel boot messages can be seen after boot with <command>dmesg</command>. Since hard disk devices are detected by the kernel during boot, you can also use dmesg to find information.</para>
		<screen>
root@barry:~# dmesg | grep "[hs]d[a-z]"
Kernel command line: root=/dev/hda1 ro 
    ide0: BM-DMA at 0xfc00-0xfc07, BIOS settings: hda:DMA, hdb:DMA
    ide1: BM-DMA at 0xfc08-0xfc0f, BIOS settings: hdc:DMA, hdd:DMA
hda: ST360021A, ATA DISK drive
hdb: Maxtor 6Y080L0, ATA DISK drive
hdc: SONY DVD RW DRU-510A, ATAPI CD/DVD-ROM drive
hdd: SONY DVD RW DRU-810A, ATAPI CD/DVD-ROM drive
hda: max request size: 128KiB
hda: 117231408 sectors (60022 MB) w/2048KiB Cache, CHS=65535/16/63, UDMA(100)
 hda: hda1 hda2
hdb: max request size: 128KiB
hdb: 160086528 sectors (81964 MB) w/2048KiB Cache, CHS=65535/16/63, UDMA(100)
 hdb: hdb1 hdb2
hdc: ATAPI 32X DVD-ROM DVD-R CD-R/RW drive, 8192kB Cache, UDMA(33)
hdd: ATAPI 40X DVD-ROM DVD-R CD-R/RW drive, 2048kB Cache, UDMA(33)
...
		</screen>
	</section>
	<section><title>/proc/scsi/scsi</title>
		<para>You can also look at the contents of <command>/proc/scsi/scsi</command>.</para>
		<screen>
root@shaka:~# cat /proc/scsi/scsi 
Attached devices:
Host: scsi0 Channel: 00 Id: 00 Lun: 00
  Vendor: Adaptec  Model: RAID5            Rev: V1.0
  Type:   Direct-Access                    ANSI SCSI revision: 02
Host: scsi1 Channel: 00 Id: 00 Lun: 00
  Vendor: SEAGATE  Model: ST336605FSUN36G  Rev: 0438
  Type:   Direct-Access                    ANSI SCSI revision: 03
  root@shaka:~# 
		</screen>
	</section>
	<section><title>scsi_info</title>
		<para>You can also use <command>scsi_info</command>.</para> 
		<screen>
root@shaka:~# scsi_info /dev/sdb
SCSI_ID="0,0,0"
HOST="1"
MODEL="SEAGATE ST336605FSUN36G"
FW_REV="0438"
root@shaka:~#
		</screen>
	</section>
	<section><title>lsscsi</title>
		<para>And even <command>lsscsi</command> if it is installed.</para>
		<screen>
root@shaka:~# lsscsi 
[0:0:0:0]    disk    Adaptec  RAID5            V1.0  /dev/sda
[1:0:0:0]    disk    SEAGATE  ST336605FSUN36G  0438  /dev/sdb
root@shaka:~# 
		</screen>
	</section>
	<section><title>Practice hard disk devices</title>
		<para>1. Use dmesg to make a list of hard disk devices (ide,ata,sata,scsi) detected at bootup.</para>
		<para>2. Use fdisk to find the total size of all hard disk devices on your system.</para>
		<para>3. Stop a virtual machine, add a virtual 10 gigabyte SCSI hard disk and a virtual 100 megabyte SCSI hard disk.</para>
		<para>4. Use dmesg and fdisk (with grep) to display some information about the new disks.</para>
		<para>5. Use badblocks to completely erase the 100 mb hard disk.</para>
		<para>6. Look at /proc/scsi/scsi.</para>
	</section>
</chapter>
<chapter><title>Partitions</title>
	<section><title>About Partitions</title>
		<para>Linux requires you to create one or more <command>partitions</command> aka <command>slices</command>. <emphasis>Please don't break your head on the difference between a partition and a slice. Different tools have different interpretations of which is which.</emphasis> Although partitions reside on the same hard disk device, you can (almost) see them as independent of each other.</para>
		<para>A partition's <command>geometry</command> and size is usually defined by a starting and ending cylinder (sometimes by head or even sector). Partitions can be of type <command>primary</command> (maximum four), <command>extended</command> (maximum one) or <command>logical</command> (contained within the extended partition). Each partition has a <command>type field</command> that contains a code. This determines the computers operating system or the partitions file system.</para>
	</section>
	<section><title>Partition naming</title>
		<para>We saw before that hard disk devices are named /dev/hdx or /dev/sdx with x depending on the hardware configuration. Next is the partition number, starting the count at 1. Hence the four (possible) primary partitions are numbered 1 to 4. Logical partition counting always starts at 5. Thus /dev/hda2 is the second partition on the first ATA hard disk device, and /dev/hdb5 is the first logical partition on the second ATA hard disk device. SAme for SCSI, /dev/sdb3 is the third partition on the second SCSI disk.</para>
	</section>
	<section><title>fdisk -l</title>
		<para>In the <command>fdisk -l</command> example below you can see that two partitions exist on /dev/sdb2. The first partition spans 31 cylinders and contains a Linux swap partition. The second partition is much bigger.</para>
		<screen>
root@laika:~# fdisk -l /dev/sdb

Disk /dev/sdb: 100.0 GB, 100030242816 bytes
255 heads, 63 sectors/track, 12161 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          31      248976   82  Linux swap / Solaris
/dev/sdb2              32       12161    97434225   83  Linux
root@laika:~#		
		</screen>
	</section>
	<section><title>df</title>
		<para>In the <command>df -h</command> example below you can see the size, free space, used gigabytes and percentage and mount point of a partition.</para>
		<screen>
root@laika:~# df -h | egrep -e "(sdb2|File)"
Filesystem            Size Used Avail Use% Mounted on
/dev/sdb2              92G   83G  8.6G  91% /media/sdb2
root@laika:~# 			
		</screen>
	</section>
	<section><title>other tools</title>
		<para>You might be interested in more GUI-oriented alternatives to fdisk and parted like cfdisk, sfdisk and gparted.</para>
	</section>
	<section><title>Partitioning new disks</title>
		<para>In the example below, we bought a new disk for our system. After the new hardware is properly attached, you can use <command>fdisk</command> and <command>parted</command> to create the necessary partition(s). This example uses fdisk, but there is nothing wrong with using parted.</para>
		<para>First, we check with <command>fdisk -l</command> whether Linux can see the new disk. Yes it does, the new disk is seen as /dev/sdb, but it does not have any partitions yet.</para>
		<screen>
root@RHELv4u2:~# fdisk -l
		
Disk /dev/sda: 12.8 GB, 12884901888 bytes
255 heads, 63 sectors/track, 1566 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          13      104391   83  Linux
/dev/sda2              14        1566    12474472+  8e  Linux LVM
		
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Disk /dev/sdb doesn't contain a valid partition table
		</screen>
		<para>Then we create a partition with fdisk on /dev/sdb. First we start the fdisk tool with /dev/sdb as argument. Be very very careful not to partition the wrong disk!!</para>
		<screen>
root@RHELv4u2:~# fdisk /dev/sdb
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content won't be recoverable.
		
Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)
		</screen>
		<para>Inside the fdisk tool, we can issue the <command>p</command> command to see the current disks partition table.</para>
		<screen>
Command (m for help): p
		
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
		
		</screen>
		<para>No partitions exist yet, so we issue <command>n</command> to create a new partition. We choose p for primary, 1 for the partition number, 1 for the start cylinder and 14 for the end cylinder.</para>
		<screen>
Command (m for help): n
Command action
e   extended
p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-130, default 1): 
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-130, default 130): 14
		</screen>
		<para>We can now issue p again to verify our changes, but they are not yet written to disk. This means we can still cancel this operation! But it looks good, so we use <command>w</command> to write the changes to disk, and then quit the fdisk tool.</para>
		<screen>
Command (m for help): p
	
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          14      112423+  83  Linux
		
Command (m for help): w
The partition table has been altered!
		
Calling ioctl() to re-read partition table.
Syncing disks.
root@RHELv4u2:~#
		</screen>
		<para>Let's verify again with <command>fdisk -l</command> to make sure reality fits our dreams. Indeed, the screenshot below now shows a partition on /dev/sdb. </para>
		<screen>
root@RHELv4u2:~# fdisk -l
		
Disk /dev/sda: 12.8 GB, 12884901888 bytes
255 heads, 63 sectors/track, 1566 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          13      104391   83  Linux
/dev/sda2              14        1566    12474472+  8e  Linux LVM
		
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1          14      112423+  83  Linux
root@RHELv4u2:~# 
		</screen>
	</section>
	<section><title>Practice Partitions</title>
		<para>1. Use fdisk and df to display existing partitions and sizes. Compare the output of the two commands.</para>
		<para>2. Create a 50 MB partition on the small SCSI disk.</para>
		<para>3. Create a primary partition of four gigabyte on the big disk.</para>
		<para>4. Create four logical drives of one gigabyte each.</para>
		<para>5. Use df and fdisk -l to verify your work.</para>
	</section>
</chapter>
<chapter><title>File Systems</title>
	<section><title>About file systems</title>
		<para>After you are finished partitioning the hard disk, you can put a <command>file system</command> on each partition. A file system is a way of organizing files on your partition. Besides file-based storage, file systems usually include <command>directories</command> and <command>access control</command>, and contain meta information about files like access times, modification times and file ownership. </para>
		<para>The properties (length, character set, ...) of filenames are determined by the file system you choose. Directories are usually implemented as files, you will have to learn how this is implemented! Access control in file systems is tracked by user ownership (and group owner- and membership) in combination with one or more access control lists.</para>
	</section>
	<section><title>Common file systems</title>
		<section><title>ext2 and ext3</title>
			<para>Once the most common Linux file systems is the <command>ext2</command> (the second extended) file system. A disadvantage is that file system checks on ext2 can take a long time. You will see that ext2 is being replaced by <command>ext3</command> on most Linux machines. They are essentially the same, except for the <command>journaling</command> which is only present in ext3.</para>
			<para>Journaling means that changes are first written to a journal on the disk. The journal is flushed regularly, writing the changes in the file system. Journaling keeps the file system in a consistent state, so you don't need a file system check after an unclean shutdown or power failure.</para>
			<para>You can create these file systems with the <command>/sbin/mkfs</command> or <command>/sbin/mke2fs</command> commands. Use <command>mke2fs -j</command> to create an ext3 file system. You can convert an ext2 to ext3 with <command>tune2fs -j</command>. You can mount an ext3 file system as ext2, but then you lose the journaling. Do not forget to run <command>mkinitrd</command> if you are booting from this device.</para>
		</section>
		<section><title>vfat</title>
			<para>The <command>vfat</command> file system exists in a couple of forms : FAT12 for floppy disks, <command>FAT16</command> on DOS, and <command>FAT32</command> for larger disks. The Linux VFAT implementation supports all of these, but vfat lacks a lot of features like security and links. FAT disks can be read by every operating system, and are used a lot for digital cameras, USB sticks and to exchange data between different OS'ses on a home user's computer.</para>
		</section>
		<section><title>ISO 9660</title>
			<para><command>ISO 9660</command> is the standard format for CD-ROM's. Chances are you will encounter this file system also on your harddisk in the form of images of CD-ROM's (often with the .ISO extension). The ISO 9660 standard limits filenames to the 8.3 format. The Unix world didn't like this, and thus added the <command>Rock Ridge</command> extensions, which allows for filenames up to 255 characters and Unix-style file-modes, ownership and symbolic links. Another extensions to ISO 9660 is <command>Joliet</command>, which adds 64 unicode characters to the filename. The <command>El Torito</command> standard extends ISO 9660 to be able to boot from CD-ROM's.</para>
		</section>
		<section><title>UDF</title>
			<para>Most optical media today (including CD's and DVD's) use <command>UDF</command>, the Universal Disk Format.</para>
		</section>
		<section><title>swap</title>
			<para>All things considered, swap is not a file system. But to use a partition as a <command>swap partition</command> it must be formatted as swap space.</para>
		</section>
		<section><title>others...</title>
			<para>You might encounter <command>reiserfs</command> on Linux systems, but it is not common on Red Hat. Maybe you will see a <command>zfs</command>, or one of the dozen other file systems available.</para>
		</section>
	</section>
	<section><title>Putting a file system on a partition</title>
		<para>We now have a fresh partition. The system binaries to make file systems can be found with ls.</para>
		<screen>
[root@RHEL4b ~]# ls -lS /sbin/mk*
-rwxr-xr-x  3 root root 34832 Apr 24  2006 /sbin/mke2fs
-rwxr-xr-x  3 root root 34832 Apr 24  2006 /sbin/mkfs.ext2
-rwxr-xr-x  3 root root 34832 Apr 24  2006 /sbin/mkfs.ext3
-rwxr-xr-x  3 root root 28484 Oct 13  2004 /sbin/mkdosfs
-rwxr-xr-x  3 root root 28484 Oct 13  2004 /sbin/mkfs.msdos
-rwxr-xr-x  3 root root 28484 Oct 13  2004 /sbin/mkfs.vfat
-rwxr-xr-x  1 root root 20313 Apr 10  2006 /sbin/mkinitrd
-rwxr-x---  1 root root 15444 Oct  5  2004 /sbin/mkzonedb
-rwxr-xr-x  1 root root 15300 May 24  2006 /sbin/mkfs.cramfs
-rwxr-xr-x  1 root root 13036 May 24  2006 /sbin/mkswap
-rwxr-xr-x  1 root root  6912 May 24  2006 /sbin/mkfs
-rwxr-xr-x  1 root root  5905 Aug  3  2004 /sbin/mkbootdisk
[root@RHEL4b ~]# 
		</screen>
		<para>It is time for you to read the manual pages of <command>mkfs</command> and <command>mke2fs</command>. In the example below, you see the creation of an <command>ext2 file system</command> on /dev/sdb1. In real life, you might want to use options like -m0 and -j.</para>
		<screen>
root@RHELv4u2:~# mke2fs /dev/sdb1
mke2fs 1.35 (28-Feb-2004)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
28112 inodes, 112420 blocks
5621 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
14 block groups
8192 blocks per group, 8192 fragments per group
2008 inodes per group
Superblock backups stored on blocks: 
8193, 24577, 40961, 57345, 73729
		
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done
		
This filesystem will be automatically checked every 37 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
		</screen>
	</section>
	<section><title>Tuning a file system</title>
		<para>You can use <command>tune2fs</command> to list and set file system settings. The first screenshot lists the reserved space for root (which is set at five percent).</para>
		<screen>
[root@rhel4 ~]# tune2fs -l /dev/sda1 | grep -i "block count"
Block count:              104388
Reserved block count:     5219
[root@rhel4 ~]#
		</screen>
		<para>This example changes this value to ten percent. You can use tune2fs while the file system is active, even if it is the root file system (as in this example).</para>
		<screen>
[root@rhel4 ~]# tune2fs -m10 /dev/sda1 
tune2fs 1.35 (28-Feb-2004)
Setting reserved blocks percentage to 10 (10430 blocks)
[root@rhel4 ~]# tune2fs -l /dev/sda1 | grep -i "block count"
Block count:              104388
Reserved block count:     10430
[root@rhel4 ~]# 
		</screen>
	</section>
	<section><title>Disk Usage</title>
		<para>The <command>du</command> command can summarize disk usage for files and directories. Preventing du to go into subdirectories with the -s option will give you a total for that directory. This option is often used together with -h, so <command>du -sh</command> on a mount point gives the total amount used in that partition.</para>
		<screen>
root@pasha:~# du -sh /home/reet
881G     /home/reet
		</screen>
	</section>
	<section><title>Checking a file system</title>
		<para>The <command>fsck</command> command is a front end tool used to check a file system for errors.</para>
		<screen>
[root@RHEL4b ~]# ls /sbin/*fsck*
/sbin/dosfsck  /sbin/fsck         /sbin/fsck.ext2  /sbin/fsck.msdos
/sbin/e2fsck   /sbin/fsck.cramfs  /sbin/fsck.ext3  /sbin/fsck.vfat
[root@RHEL4b ~]#
		</screen>
		<para>The last column in <command>/etc/fstab</command> is used to determine whether a file system should be checked at bootup.</para>
		<screen>
[paul@RHEL4b ~]$ grep ext /etc/fstab 
/dev/VolGroup00/LogVol00   /             ext3    defaults        1 1
LABEL=/boot                /boot         ext3    defaults        1 2
[paul@RHEL4b ~]$
		</screen>
		<para>Manually checking a mounted file system results in a warning from fsck.</para>
		<screen>
[root@RHEL4b ~]# fsck /boot
fsck 1.35 (28-Feb-2004)
e2fsck 1.35 (28-Feb-2004)
/dev/sda1 is mounted.  

WARNING!!!  Running e2fsck on a mounted filesystem may cause
SEVERE filesystem damage.

Do you really want to continue (y/n)? no

check aborted.
[root@RHEL4b ~]#
		</screen>
		<para>But after unmounting fsck and <command>e2fsck</command> can be used to check an ext2 file system.</para>
		<screen>
[root@RHEL4b ~]# fsck  /boot
fsck 1.35 (28-Feb-2004)
e2fsck 1.35 (28-Feb-2004)
/boot: clean, 44/26104 files, 17598/104388 blocks
[root@RHEL4b ~]# fsck -p /boot
fsck 1.35 (28-Feb-2004)
/boot: clean, 44/26104 files, 17598/104388 blocks
[root@RHEL4b ~]# e2fsck -p /dev/sda1
/boot: clean, 44/26104 files, 17598/104388 blocks
[root@RHEL4b ~]#
		</screen>
	</section>
	<section><title>Practice File Systems</title>
		<para>1. List the filesystems that are known by your system.</para>
		<para>2. Create an ext2 filesystem on the 50MB partition.</para>
		<para>3. Create an ext3 filesystem on the 4GB primary and one of the 1GB logical drives.</para>
		<para>4. Set the reserved space for root on the logical drive to 0 percent.</para>
		<para>5. Verify your work with the usual commands.</para>
		<para>6. Put a reiserfs on one of the logical drives.</para>
	</section>
</chapter>
<chapter><title>Mounting</title>
	<para>Once you've put a file system on a partition, you can <command>mount</command> it. Mounting a file system makes it available for use, usually as a directory. We say <command>mounting a file system</command> instead of mounting a partition because we will see later that we can also mount file systems that do not exists on partitions.</para>
	<section><title>Mounting local disks</title>
		<para>On all Unix systems, every file and every directory is part of one big file tree. To access a file, you need to know the full path starting from the root directory. When adding a file system to your computer, you need to make it available somewhere in the file tree. The directory where you make a file system available is called a <command>mount point</command>. Once mounted, the new file system is accessible to users. The screenshot below shows the creation of a mount point, and the mounting of an ext2 partition on a newly added SCSI disk. </para>
		<screen>
root@RHELv4u2:~# mkdir /home/project55
root@RHELv4u2:~# mount -t ext2 /dev/sdb1 /home/project55/
root@RHELv4u2:~# ls /home/project55/
lost+found
root@RHELv4u2:~# 
		</screen>
		<para>Actually the explicit -t ext2 option to set the file system is not always necesarry. The mount command is able to automatically detect a lot of file systems on partitions.</para>
	</section>
	<section><title>Displaying mounted file systems</title>
		<para>To view all mounted file systems, look at the files <command>/proc/mounts</command> or <command>/etc/mtab</command>. The kernel provides the info in /proc/mount in file form, but /proc/mount does not exist as a file on any hard disk. Looking at /proc/mount is the best way to be sure, since the information comes directly from the kernel. The /etc/mtab file on the other hand is updated by the mount command. Do not edit /etc/mtab manually!</para>
		<para>Another way to view all mounts is by issuing the <command>mount</command> command without any arguments. The screenshot below pipes the output of these three through grep, to only show our added SCSI disk.</para>
		<screen>
root@RHELv4u2:~# cat /proc/mounts | grep /dev/sdb
/dev/sdb1 /home/project55 ext2 rw 0 0
root@RHELv4u2:~# cat /etc/mtab | grep /dev/sdb
/dev/sdb1 /home/project55 ext2 rw 0 0
root@RHELv4u2:~# mount | grep /dev/sdb
/dev/sdb1 on /home/project55 type ext2 (rw)
		</screen>
		<para>A more user friendly way to look at mounted hard disks is <command>df</command>. The df(diskfree) command has the added benefit of showing you the free space on each mounted disk. Like a lot of Linux commands, df supports the <command>-h</command> switch to make the output more <command>human readable</command>.</para>
		<screen>
root@RHELv4u2:~# df
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/mapper/VolGroup00-LogVol00
11707972   6366996   4746240  58% /
/dev/sda1               101086      9300     86567  10% /boot
none                    127988         0    127988   0% /dev/shm
/dev/sdb1               108865      1550    101694   2% /home/project55
root@RHELv4u2:~# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup00-LogVol00
12G  6.1G  4.6G  58% /
/dev/sda1              99M  9.1M   85M  10% /boot
none                  125M     0  125M   0% /dev/shm
/dev/sdb1             107M  1.6M  100M   2% /home/project55
		</screen>
	</section>
	<section><title>Permanent mounts</title>
		<para>Until now, we performed all mounts manually. This works nice, until the next reboot. Luckily there is a way to tell your computer to automatically mount certain file systems during boot. This is done using the file system table located in the <command>/etc/fstab</command> file. Below is a sample /etc/fstab file.</para>
		<screen>
root@RHELv4u2:~# cat /etc/fstab 
/dev/VolGroup00/LogVol00 /                   ext3    defaults        1 1
LABEL=/boot             /boot                ext3    defaults        1 2
none                    /dev/pts             devpts  gid=5,mode=620  0 0
none                    /dev/shm             tmpfs   defaults        0 0
none                    /proc                proc    defaults        0 0
none                    /sys                 sysfs   defaults        0 0
/dev/VolGroup00/LogVol01 swap                swap    defaults        0 0
		</screen>
		<para>By adding the following two lines, we can automate the mounting of these file systems. The first line is for our freshly added SCSI disk, the second line mounts an NFS share.</para>
		<screen>
/dev/sdb1                /home/project55         ext2    defaults    0 0
server12:/mnt/data/iso   /home/iso               nfs     defaults    0 0
		</screen>
	</section>
	<section><title>Practice File Systems</title>
		<para>1. Mount the small 50MB partition on /home/project22.</para>
		<para>2. Mount the big primary partition on /mnt, the copy some files to it (everything in /etc). Then mount the partition as read only on /srv/nfs/salesnumbers.</para>
		<para>3. Verify your work with fdisk, df, mount. Also look in /etc and /proc to interesting files.</para>
		<para>4. Make both mounts permanent, test that it works.</para>
		<para>5. What happens when you mount a partition on a directory that contains some files ?</para>
		<para>6. What happens when you mount two partitions on the same mountpoint ?</para>
		<para>7. Describe the difference between these file searching commands: find, locate, updatedb, whereis, apropos and which.</para>
		<para>8. Perform a file system check on the partition mounted at /srv/nfs/salesnumbers.</para>
	</section>
</chapter>
<chapter><title>File Links</title>
	<section><title>About inodes</title>
		<para>To understand links in a file system, you first have to understand what an <command>inode</command> is. When the file system stores a new file on the hard disk, it stores not only the contents (data) of the file, but also some extra properties like the name of the file, the creation date, the permissions, the owner of the file... and more. All this information (except the name of the file and the data) is stored in the inode of the file.</para>
		<para>All the inodes are created when you create the file system (with mkfs). Most of them are unused and empty, each inode has a unique number (the inode number). You can see the inode numbers with the <command>ls -li</command> command.</para>
		<screen>
paul@RHELv4u4:~/test$ touch file1
paul@RHELv4u4:~/test$ touch file2
paul@RHELv4u4:~/test$ touch file3
paul@RHELv4u4:~/test$ ls -li
total 12
817266 -rw-rw-r--  1 paul paul 0 Feb  5 15:38 file1
817267 -rw-rw-r--  1 paul paul 0 Feb  5 15:38 file2
817268 -rw-rw-r--  1 paul paul 0 Feb  5 15:38 file3
paul@RHELv4u4:~/test$ 
		</screen>
		<para>Three files created one after the other get three different inodes (the first column). All the information you see with this ls command resides in the inode, except for the filename (which is contained in the directory). Let's put some data in one of the files.</para>
		<screen>
paul@RHELv4u4:~/test$ ls -li
total 16
817266 -rw-rw-r--  1 paul paul  0 Feb  5 15:38 file1
817270 -rw-rw-r--  1 paul paul 92 Feb  5 15:42 file2
817268 -rw-rw-r--  1 paul paul  0 Feb  5 15:38 file3
paul@RHELv4u4:~/test$ cat file2
It is winter now and it is very cold.
We do not like the cold, we prefer hot summer nights.
paul@RHELv4u4:~/test$
		</screen>
		<para>The data that is displayed by the cat commend is not in the inode, but somewhere else on the disk. But the inode contains a pointer to the data.</para>
	</section>
	<section><title>About directories</title>
		<para>A <command>directory</command> is a special kind of file. It contains a table mapping filenames to inodes. Looking at our current directory with <command>ls -ali</command> will display the contents of the directory file.</para>
		<screen>
paul@RHELv4u4:~/test$ ls -ali
total 32
817262 drwxrwxr-x   2 paul paul 4096 Feb  5 15:42 .
800768 drwx------  16 paul paul 4096 Feb  5 15:42 ..
817266 -rw-rw-r--   1 paul paul    0 Feb  5 15:38 file1
817270 -rw-rw-r--   1 paul paul   92 Feb  5 15:42 file2
817268 -rw-rw-r--   1 paul paul    0 Feb  5 15:38 file3
paul@RHELv4u4:~/test$ 
		</screen>
		<para>You can see five names, and the mapping to their five inodes. The dot <command>.</command> is a mapping to itself, and the dotdot <command>..</command> is a mapping to the parent directory. The three others are mappings to files.</para>
	</section>
	<section><title>Hard links</title>
		<para>When we create a <command>hard link</command> to a file, then an extra entry is added in the directory. A new file name is mapped to an existing inode.</para>
		<screen>
paul@RHELv4u4:~/test$ ln file2 hardlink_to_file2
paul@RHELv4u4:~/test$ ls -li
total 24
817266 -rw-rw-r--  1 paul paul  0 Feb  5 15:38 file1
817270 -rw-rw-r--  2 paul paul 92 Feb  5 15:42 file2
817268 -rw-rw-r--  1 paul paul  0 Feb  5 15:38 file3
817270 -rw-rw-r--  2 paul paul 92 Feb  5 15:42 hardlink_to_file2
paul@RHELv4u4:~/test$ 
		</screen>
		<para>Both files have the same inode, so they will always have the same permissions and the same owner. And they will both have the same content. Actually, both files are equal now, meaning you can safely remove the original file, the hardlinked file will remain. The inode contains a counter, counting the number of hard links to itself. When the counter drops to zero, then the inode is emptied.</para>
		<para>You can use the <command>find</command> command to look for files with a certain inode. The screenshot below proves that / and /boot are different partitions, since every <command>inode</command> number is unique to the partition.</para>
		<screen>
paul@RHELv4u4:~/test$ find / -inum 2 2> /dev/null
/
/boot
/var/lib/nfs/rpc_pipefs/lockd
/proc/self
paul@RHELv4u4:~/test$ 
		</screen>
	</section>
	<section><title>Symbolic links</title>
		<para>Symbolic links (sometimes called <command>soft links</command>) do not link to inodes, but create a name to name mapping. As you can see below, the <command>symbolic link</command> gets an inode of its own.</para>
		<screen>
paul@RHELv4u4:~/test$ ls -li
total 32
817273 -rw-rw-r--  1 paul paul  13 Feb  5 17:06 file1
817270 -rw-rw-r--  2 paul paul 106 Feb  5 17:04 file2
817268 -rw-rw-r--  1 paul paul   0 Feb  5 15:38 file3
817270 -rw-rw-r--  2 paul paul 106 Feb  5 17:04 hardlink_to_file2
817267 lrwxrwxrwx  1 paul paul   5 Feb  5 16:55 symlink_to_file2 -> file2
paul@RHELv4u4:~/test$ 
		</screen>
		<para>Permissions on a symbolic link have no meaning, since the permissions of the target apply. Hard links are limited to their own partition (because they point to an inode), symbolic links can link anywhere (other file systems, even networked).</para>	
	</section>
	<section><title>Practice Links</title>
		<para>1. Create two files named winter.txt and summer.txt, put some text in them.</para>
		<para>2. Create a hard link to winter.txt named hlwinter.txt.</para>
		<para>3. Display the inode numbers of these three files, the hard links should have the same inode.</para>
		<para>4. Use the find command to list the two hardlinked files</para>
		<para>5. Everything about a file is in the inode, except two things : name them!</para>
		<para>6. Create a symbolic link to summer.txt called slsummer.txt.</para>
		<para>7. Find all files with inode number 2. What does this information tell you ?</para>
		<para>8. Look at the directories /etc/init.d/ /etc/rc.d/ /etc/rc3.d/ ... do you see the links ?</para>
		<para>9. Look in /lib with ls -l...</para>
	</section>
</chapter>
<chapter><title>Logging</title>
	<section><title>About logging</title>
		<section><title>/var/log</title>		
			<para>The location for log files according to the FHS is <command>/var/log</command>. You will find a lot of log files and directories for common applications in /var/log.</para>
			<screen>
[paul@RHEL4b ~]$ ls /var/log
acpid            cron.2     maillog.2    quagga            secure.4
amanda           cron.3     maillog.3    radius            spooler
anaconda.log     cron.4     maillog.4    rpmpkgs           spooler.1
anaconda.syslog  cups       mailman      rpmpkgs.1         spooler.2
anaconda.xlog    dmesg      messages     rpmpkgs.2         spooler.3
audit            exim       messages.1   rpmpkgs.3         spooler.4
boot.log         gdm        messages.2   rpmpkgs.4         squid
boot.log.1       httpd      messages.3   sa                uucp
boot.log.2       iiim       messages.4   samba             vbox
boot.log.3       iptraf     mysqld.log   scrollkeeper.log  vmware-tools-guestd
boot.log.4       lastlog    news         secure            wtmp
canna            mail       pgsql        secure.1          wtmp.1
cron             maillog    ppp          secure.2          Xorg.0.log
cron.1           maillog.1  prelink.log  secure.3          Xorg.0.log.old
[paul@RHEL4b ~]$ 
			</screen>
		</section>
		<section><title>/var/log/messages</title>
			<para>A typical first file to check when troubleshooting is the <command>/var/log/messages</command> file. By default this file will contain information on what just happened to the system.</para>
			<screen>
[root@RHEL4b ~]# tail /var/log/messages
Jul 30 05:13:56 localhost anacron: anacron startup succeeded
Jul 30 05:13:56 localhost atd: atd startup succeeded
Jul 30 05:13:57 localhost messagebus: messagebus startup succeeded
Jul 30 05:13:57 localhost cups-config-daemon: cups-config-daemon startup succeeded
Jul 30 05:13:58 localhost haldaemon: haldaemon startup succeeded
Jul 30 05:14:00 localhost fstab-sync[3560]: removed all generated mount points
Jul 30 05:14:01 localhost fstab-sync[3628]: added mount point /media/cdrom for /dev/hdc
Jul 30 05:14:01 localhost fstab-sync[3646]: added mount point /media/floppy for /dev/fd0
Jul 30 05:16:46 localhost sshd(pam_unix)[3662]: session opened for user paul by (uid=0)
Jul 30 06:06:37 localhost su(pam_unix)[3904]: session opened for user root by paul(uid=500)
[root@RHEL4b ~]#
			</screen>
		</section>
	</section>
	<section><title>Login logging</title>
		<para>To keep track of who is logging into the system, Linux can maintain the <command>/var/log/wtmp</command>, <command>/var/log/btmp</command>, <command>/var/run/utmp</command> and <command>/var/log/lastlog</command> files.</para>
		<section><title>/var/run/utmp (who)</title>	
			<para>Use the <command>who</command> command to see the /var/run/utmp file.</para> 
			<screen>
[root@rhel4a ~]# who
paul     pts/1        Feb 14 18:39 (192.168.1.45)
			</screen>
		</section>
		<section><title>/var/log/wtmp (last)</title>	
			<para>The /var/log/wtmp file is updated by the <command>login program</command>. Use <command>last</command> to see the /var/run/wtmp file.</para>
			<screen>
[root@rhel4a ~]# last | head
paul     pts/1        192.168.1.45     Wed Feb 14 18:39   still logged in   
reboot   system boot  2.6.9-42.0.8.ELs Wed Feb 14 18:21          (01:15)    
nicolas  pts/5        pc-dss.telematic Wed Feb 14 12:32 - 13:06  (00:33)    
stefaan  pts/3        pc-sde.telematic Wed Feb 14 12:28 - 12:40  (00:12)    
nicolas  pts/3        pc-nae.telematic Wed Feb 14 11:36 - 12:21  (00:45)    
nicolas  pts/3        pc-nae.telematic Wed Feb 14 11:34 - 11:36  (00:01)    
dirk     pts/5        pc-dss.telematic Wed Feb 14 10:03 - 12:31  (02:28)    
nicolas  pts/3        pc-nae.telematic Wed Feb 14 09:45 - 11:34  (01:48)    
dimitri  pts/5        rhel4           Wed Feb 14 07:57 - 08:38  (00:40)    
stefaan  pts/4        pc-sde.telematic Wed Feb 14 07:16 - down   (05:50)    
[root@rhel4a ~]# 
			</screen>
			<para>The last command can also be used to get a list of last reboots.</para>
			<screen>
				
[paul@rekkie ~]$ last reboot 
reboot   system boot  2.6.16-rekkie   Mon Jul 30 05:13         (370+08:42)  

wtmp begins Tue May 30 23:11:45 2006
[paul@rekkie ~]$ 				
			</screen>
		</section>
		<section><title>/var/log/lastlog (lastlog)</title>	
			<para>Use <command>lastlog</command> to see the /var/log/lastlog file.</para>
			<screen>
[root@rhel4a ~]# lastlog | tail
tim              pts/5    10.170.1.122     Tue Feb 13 09:36:54 +0100 2007
rm               pts/6    rhel4           Tue Feb 13 10:06:56 +0100 2007
henk                                       **Never logged in**
stefaan          pts/3    pc-sde.telematic Wed Feb 14 12:28:38 +0100 2007
dirk             pts/5    pc-dss.telematic Wed Feb 14 10:03:11 +0100 2007
arsene                                     **Never logged in**
nicolas          pts/5    pc-dss.telematic Wed Feb 14 12:32:18 +0100 2007
dimitri          pts/5    rhel4           Wed Feb 14 07:57:19 +0100 2007
bashuserrm       pts/7    rhel4           Tue Feb 13 10:35:40 +0100 2007
kornuserrm       pts/5    rhel4           Tue Feb 13 10:06:17 +0100 2007
[root@rhel4a ~]# 
			</screen>
		</section>
		<section><title>/var/log/btmp (lastb)</title>	
			<para>There is also the <command>lastb</command> command to display the <command>/var/log/btmp</command> file. This file is updated by the login program when entering the wrong password, so it contains failed login attempts. Many computers will not have this file, resulting in no logging of failed login attempts.</para>
			<screen>
[root@RHEL4b ~]# lastb
lastb: /var/log/btmp: No such file or directory
Perhaps this file was removed by the operator to prevent logging lastb info.
[root@RHEL4b ~]#
			</screen>
			<para>The reason given for this is that users sometimes type their password by mistake instead of their login, so this world readable file poses a security risk. You can enable bad login logging by simply creating the file. Doing a chmod o-r /var/log/btmp improves security.</para>
			<screen>
[root@RHEL4b ~]# touch /var/log/btmp
[root@RHEL4b ~]# ll /var/log/btmp
-rw-r--r--  1 root root 0 Jul 30 06:12 /var/log/btmp
[root@RHEL4b ~]# chmod o-r /var/log/btmp 
[root@RHEL4b ~]# lastb

btmp begins Mon Jul 30 06:12:19 2007
[root@RHEL4b ~]# 
			</screen>
			<para>Failed logins via ssh, rlogin or su are not registered in /var/log/btmp. Failed logins via tty are.</para>
			<screen>
[root@RHEL4b ~]# lastb
HalvarFl tty3                          Mon Jul 30 07:10 - 07:10  (00:00)    
Maria    tty1                          Mon Jul 30 07:09 - 07:09  (00:00)    
Roberto  tty1                          Mon Jul 30 07:09 - 07:09  (00:00)    

btmp begins Mon Jul 30 07:09:32 2007
[root@RHEL4b ~]#
			</screen>
		</section>
		<section><title>su and ssh logins</title>
			<para>Depending on the distribution, you may also have the <command>/var/log/secure</command> file being filled with messages from the auth and/or authpriv syslog facilities. This log will include su and/or ssh failed login attempts. Some distributions put this in <command>/var/log/auth.log</command>, verify the syslog configuration.</para>
			<screen>
[root@RHEL4b ~]# cat /var/log/secure
Jul 30 07:09:03 localhost sshd[4387]: Accepted publickey for paul from ::ffff:19\
2.168.1.52 port 33188 ssh2
Jul 30 05:09:03 localhost sshd[4388]: Accepted publickey for paul from ::ffff:19\
2.168.1.52 port 33188 ssh2
Jul 30 07:22:27 localhost sshd[4655]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 05:22:27 localhost sshd[4656]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 07:22:30 localhost sshd[4655]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 05:22:30 localhost sshd[4656]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 07:22:33 localhost sshd[4655]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 05:22:33 localhost sshd[4656]: Failed password for Hermione from ::ffff:1\
92.168.1.52 port 38752 ssh2
Jul 30 08:27:33 localhost sshd[5018]: Invalid user roberto from ::ffff:192.168.1\
.52
Jul 30 06:27:33 localhost sshd[5019]: input_userauth_request: invalid user rober\
to
Jul 30 06:27:33 localhost sshd[5019]: Failed none for invalid user roberto from \
::ffff:192.168.1.52 port 41064 ssh2
Jul 30 06:27:33 localhost sshd[5019]: Failed publickey for invalid user roberto \
from ::ffff:192.168.1.52 port 41064 ssh2
Jul 30 08:27:36 localhost sshd[5018]: Failed password for invalid user roberto f\
rom ::ffff:192.168.1.52 port 41064 ssh2
Jul 30 06:27:36 localhost sshd[5019]: Failed password for invalid user roberto f\
rom ::ffff:192.168.1.52 port 41064 ssh2
[root@RHEL4b ~]# 
			</screen>
			<para>You can enable this yourself, with a custom logfile by adding the following line tot syslog.conf.</para>
			<screen>auth.*,authpriv.*                 /var/log/customsec.log</screen>
		</section>
	</section>
	<section><title>Syslogd daemon</title>
		<section><title>About syslog</title>
			<para>The standard method of logging on Linux is through the <command>syslogd</command> daemon. Syslog was developed by <command>Eric Allman</command> for sendmail, but quickly became a standard among many Unix applications and was much later written as rfc 3164. The syslog daemon can receive messages on udp <command>port 514</command> from many applications (and appliances), and can append to logfiles, print, display messages on terminals and forward logs to other syslogd daemons on other machines. The syslogd daemon is configured in <command>/etc/syslog.conf</command>.</para>
			<para>Each line in the configuration file uses a <command>facility</command> to determine where the message is coming from. It also contains a <command>level</command> for the severity of the message, and an <command>action</command> to decide on what to do with the message.</para>
		</section>
		<section><title>Facilities</title>
			<para>The <command>man syslog.conf</command> will explain the different default facilities for certain daemons, such as mail, lpr, news and kern(el) messages. The local0 to local7 facility can be used for appliances (or any networked device that supports syslog). Here is a list of all facilities for syslog.conf version 1.3. The security keyword is deprecated.</para>
			<screen>
auth (security)
authpriv
cron
daemon
ftp
kern
lpr mail
mark (internal use only)
news
syslog
user
uucp
local0-7
			</screen>
		</section>
		<section><title>Levels</title>
			<para>The worst severity a message can have is <command>emerg</command> followed by <command>alert</command> and <command>crit</command>. Lowest priority should go to <command>info</command> and <command>debug</command> messages. Specifying a severity will also log all messages with a higher severity. You can prefix the severity with = to obtain only messages that match that severity. You can also specify <command>.none</command> to prevent a specific action from any message from a certain facility.</para>
			<para>Here is a list of all levels, in ascending order. The keywords warn, error and panic are deprecated.</para>
			<screen>
debug
info
notice
warning (warn)
err (error)
crit
alert
emerg (panic)
			</screen>
		</section>
		<section><title>Actions</title>
			<para>The default action is to send a message to the username listed as action. When the action is prefixed with a <command>/</command> then syslog will send the message to the file (which can be a regular file, but also a printer or terminal). The <command>&#064;</command> sign prefix will send the message on to another syslog server. Here is a list of all possible actions.</para>
			<screen>
root,user1      list of users, seperated by comma's
*               message to all logged on users
/               file (can be a printer, a console, a tty, ...)
-/              file, but don't sync after every write
&#124;               named pipe
&#064;               other syslog hostname
			</screen>
			<para>In addition, you can prefix actions with a - to omit syncing the file after every logging.</para>
		</section>
		<section><title>Configuration</title>
			<para>Below a sample configuration of custom local4 messages in <command>/etc/syslog.conf</command>.</para>
			<screen>
local4.crit                            /var/log/critandabove
local4.=crit                           /var/log/onlycrit
local4.*                               /var/log/alllocal4
			</screen>
			<para>Don't forget to restart the server.</para>
			<screen>
[root@rhel4a ~]# /etc/init.d/syslog restart
Shutting down kernel logger:                               [  OK  ]
Shutting down system logger:                               [  OK  ]
Starting system logger:                                    [  OK  ]
Starting kernel logger:                                    [  OK  ]
[root@rhel4a ~]#
			</screen>
		</section>
	</section>
	<section><title>logger</title>
		<para>The logger command can be used to generate syslog test messages. You can aslo use it in scripts. An example of testing syslogd with the <command>logger</command> tool.</para>
		<screen>
[root@rhel4a ~]# logger -p local4.debug "l4 debug"
[root@rhel4a ~]# logger -p local4.crit "l4 crit"
[root@rhel4a ~]# logger -p local4.emerg "l4 emerg"
[root@rhel4a ~]#
		</screen>
		<para>The results of the tests with logger.</para>
		<screen>
[root@rhel4a ~]# cat /var/log/critandabove 
Feb 14 19:55:19 rhel4a paul: l4 crit
Feb 14 19:55:28 rhel4a paul: l4 emerg
[root@rhel4a ~]# cat /var/log/onlycrit 
Feb 14 19:55:19 rhel4a paul: l4 crit
[root@rhel4a ~]# cat /var/log/alllocal4 
Feb 14 19:55:11 rhel4a paul: l4 debug
Feb 14 19:55:19 rhel4a paul: l4 crit
Feb 14 19:55:28 rhel4a paul: l4 emerg
[root@rhel4a ~]# 
		</screen>
	</section>
	<section><title>Watching logs</title>
		<para>You might want to use the <command>tail -f</command> command to look at the last lines of a log file. The -f option will dynamically display lines that are appended to the log. You can do the same for the login logfiles with the <command>watch</command> command.</para>
	</section>
	<section><title>Rotating logs</title>
		<para>A lot of log files are always growing in size. To keep this within bounds, you might want to use <command>logrotate</command> to rotate, compress, remove and mail logfiles. More info on the logrotate command in the scheduling chapter.</para>
	</section>
	<section><title>Practice Logging</title>
		<para>1. Display the /var/run/utmp file.</para>
		<para>2. Display the /var/log/wtmp file.</para>
		<para>3. Use the lastlog and lastb commands, understand the difference.</para>
		<para>4. Examine syslog to find the location of the log file continaing ssh failed logins.</para>
		<para>5. Configure syslog to put local4.error and above messages in /var/log/l4e.log and local4.info only .info in /var/log/l4i.log. Test that it works with the logger tool!</para>
		<para>6. Configure /var/log/Mysu.log, all the su to root messages should go in that log. Test that it works!</para>
		<para>7. Send the local5 messages to the syslog server of your neighbour. Test that it works.</para>
		<para>8. Write a script that executes logger to local4 every 5 seconds (different message). Use tail -f and watch on your local4 log files. </para>
	</section>
</chapter>
<chapter><title>System init</title>
	<section><title>Booting</title>
		<para>The details on what happens between 'power on' and 'kernel loading' are discussed later in the booting Linux chapter. When the kernel is loaded, it starts the <command>init daemon</command>. The init daemon has <command>PID 1</command>. Many unix and linux systems use(d) init scripts to start daemons in the <command>System V release 4</command> style (explained in detail below).</para>
		<para>But this synchronous (one after the other) method of starting daemons is slow, and although slow booting is not a problem on servers where uptime is measured in years, the recent uptake of linux on the desktop results in user complaints. To improve linux (and Solaris) startup speed, <command>Canonical</command> has developed <command>upstart</command> (first used in Ubuntu) and <command>Sun</command> has developed <command>Service Management Facility</command> for Solaris 10. Both systems are asynchronous and can replace the SysV init scripts. There is also an ongoing effort to create <command>initng</command> (init next generation).</para>
	</section>
	<section><title>Daemons</title>
		<para>A daemon is a process that runs in background, without a link to a GUI or terminal. Daemons are usually started at system boot, and stay alive until the system shuts down. In more recent technical writings, daemons are often refered to as <command>services</command>.</para>
		<para>Unix <command>daemons</command> are not to be confused with demons. Evi Nemeth, co-author of the UNIX System Administration Handbook has the following to say about daemons:</para>
		<para><emphasis>Many people equate the word "daemon" with the word "demon", implying some kind of satanic connection between UNIX and the underworld. This is an egregious misunderstanding. "Daemon" is actually a much older form of "demon"; daemons have no particular bias towards good or evil, but rather serve to help define a person's character or personality. The ancient Greeks' concept of a "personal daemon" was similar to the modern concept of a "guardian angel" ...</emphasis>.</para>
	</section>
	<section><title>Init</title>
		<section><title>/etc/inittab</title>
			<para>After the kernel, <command>/sbin/init</command> is started with PID 1. Init will read its configuration file <command>/etc/inittab</command>. In that file, it will look for the value of initdefault (3 in the screenshot below).</para>
			<screen>
[paul@rhel4 ~]$ grep &#094;id /etc/inittab 
id:3:initdefault:
			</screen>
		</section>	
		<section><title>Runlevel</title>
			<para>This number indicates the default <command>runlevel</command>. Some linuxes have a brief description of runlevels in /etc/inittab, like here on Red Hat Enterprise Linux 4.</para>
			<screen>
# Default runlevel. The runlevels used by RHS are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
			</screen>
			<para>Runlevel 0 means the system is shutting down. Runlevel 1 is used for troubleshooting, only the root user can log on, and only at the console. Runlevel 3 is typical for servers, whereas runlevel 5 is typical for desktops (graphical logon). Besides runlevels 0, 1 and 6, the use may vary depending on the distribution. Some Debian and derived linux systems have full network and GUI logon on runlevels 2 to 5. So always verify the proper meaning of runlevels on your system.</para>
		</section>
		<section><title>sysinit</title>
			<para>Independent of the runlevel, init will run the <command>/etc/rc.d/rc.sysinit</command> script (<command>/etc/init.d/rcS</command> on debian). This script does a lot of things : setting environment, populating /etc/mtab, mounting file systems, starting swap and more.</para>
			<screen>
[paul@rhel4 ~]$ egrep -e"^# Ini" -e"^# Sta" -e"^# Che" /etc/rc.d/rc.sysinit 
# Check SELinux status
# Initialize hardware
# Start the graphical boot, if necessary; /usr may not be mounted yet, so we
# Initialiaze ACPI bits
# Check filesystems
# Start the graphical boot, if necessary and not done yet.
# Check to see if SELinux requires a relabel
# Initialize pseudo-random number generator
# Start up swapping.
# Initialize the serial ports.
[paul@rhel4 ~]$ 
			</screen>
			<para>That <command>egrep</command> command could also have been written with <command>grep</command> like this : grep "^# \(Ini\|Sta\|Che\)".</para>
		</section>
		<section><title>rc scripts</title>
			<para>Init will continue to read /etc/inittab and meets this section on debian linux.</para>
			<screen>
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6
			</screen>
			<para>(on Red Hat Enterprise Linux it is identical except init.d is rc.d.</para>
			<screen>
l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2
l3:3:wait:/etc/rc.d/rc 3
l4:4:wait:/etc/rc.d/rc 4
l5:5:wait:/etc/rc.d/rc 5
l6:6:wait:/etc/rc.d/rc 6
			</screen>
			<para>In both cases, this means that init will start the rc script with as only parameter the runlevel. Actually /etc/inittab has fields seperated by colons. The second field determines the runlevel in which this line should be executed. So in both cases, only one line of the seven will be executed, depending on the runlevel set by initdefault.</para>
			<para>When you take a look in the relevant <command>/etc/rc3.d</command> directory, which is real on debian and a symbolic link to <command>/etc/rc.d/rc3.d</command> on Red Hat, then you will see a lot of (links to) scripts who's name start with either uppercase K or uppercase S. When entering a runlevel, scripts with uppercase S are started in alphabetical order with "start" as the only parameter. When leaving a runlevel, the same happens for scripts starting with K. All this is done by the rc script.</para>
		</section>
		<section><title>Power and Ctrl-Alt-Del</title>
			<para>When rc is finished starting all those scripts, init will continue to read /etc/inittab. It will read commands on what to execute in case of <command>powerfailure</command>, powerok and <command>Ctrl-Alt-Delete</command>. The init process never stops keeping an eye on power failures and that triple key combo.</para>
			<para>The relevant part on Red Hat Enterprise Linux.</para>
			<screen>
[paul@RHEL4b ~]$ grep "\(^c\|^p\)" /etc/inittab 
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"
pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"
			</screen>
			<para>And very similar on Debian Etch.</para>
			<screen>
paul@barry:~$ grep "\(^c\|^p\)" /etc/inittab
ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
pf::powerwait:/etc/init.d/powerfail start
pn::powerfailnow:/etc/init.d/powerfail now
po::powerokwait:/etc/init.d/powerfail stop
 			</screen>
		</section>
		<section><title>getty</title>
			<para>Almost at the end of /etc/inittab, there is a section to start and <command>respawn</command> several mingetty's.</para>
			<screen>
[root@RHEL4b ~]# grep getty /etc/inittab 
# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
[root@RHEL4b ~]#
			</screen>
			<para>A mingetty will display a message on a virtual console and allow you to type a userid and sends that info to the login program. The login program will verify whether that user exists in /etc/passwd and prompt for (and verify) a password. If the password is correct, login passes control to the shell listed in /etc/passwd.</para>
			<para>So the getty's are started by init, and watched until they die (user exit's the shell and is logged out). When this happens, the init daemon will respawn a new mingetty. So even if you kill the mingetty's, they will be reborn automatically.</para>
			<screen>
[root@RHEL4b ~]# ps fax |grep mingetty
 3038 tty1     Ss+    0:00 /sbin/mingetty tty1
 3039 tty2     Ss+    0:00 /sbin/mingetty tty2
 3040 tty3     Ss+    0:00 /sbin/mingetty tty3
 3041 tty4     Ss+    0:00 /sbin/mingetty tty4
 3042 tty5     Ss+    0:00 /sbin/mingetty tty5
 3043 tty6     Ss+    0:00 /sbin/mingetty tty6
[root@RHEL4b ~]# kill 3038 3039 3040 3041 3042 3043
[root@RHEL4b ~]# ps fax |grep mingetty
 4774 tty1     Ss+    0:00 /sbin/mingetty tty1
 4884 tty2     Ss+    0:00 /sbin/mingetty tty2
 4974 tty3     Ss+    0:00 /sbin/mingetty tty3
 5026 tty4     Ss+    0:00 /sbin/mingetty tty4
 5073 tty5     Ss+    0:00 /sbin/mingetty tty5
 5098 tty6     Ss+    0:00 /sbin/mingetty tty6
[root@RHEL4b ~]# 			
			</screen>
			<para>You can disable a mingetty for a certain tty by removing the runlevel from the second field in its line in /etc/inittab. Don't forget to tell init about the change of its configuration file with <command>kill -1 1</command>.</para>
		</section>
	</section>
	<section><title>Starting and stopping daemons</title>
		<para>The K and S scripts usually are links to the real scripts in <command>/etc/init.d</command> or <command>/etc/rc.d/init.d</command>. These can also be used when the system is running to start and stop daemons (or services). Most of them accept the following parameters: start, stop, restart, status.</para>
		<screen>
root@laika:~# /etc/init.d/samba restart
 * Stopping Samba daemons...                               [ OK ] 
 * Starting Samba daemons...                               [ OK ] 
root@laika:~# 				
		</screen>
		<para>You can achieve the same result on Red Hat and derived linuxes with the <command>service</command> command. </para>
		<screen>
[root@RHEL4b ~]# service smb restart
Shutting down SMB services:                                [  OK  ]
Shutting down NMB services:                                [  OK  ]
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b ~]# 
		</screen>
	</section>
	<section><title>Display the runlevel</title>
		<para>You can see your current runlevel with the <command>runlevel</command> or <command>who -r</command> commands.</para>
		<para>The runlevel command is typical linux and will output the previous and the current runlevel. If there was no previous runlevel, then it will mark it with the letter N.</para>
		<screen>
[root@RHEL4b ~]# runlevel 
N 3
		</screen>
		<para>The history of who -r dates back to older unixes, and it still works on linux.</para>
		<screen>
[root@RHEL4b ~]# who -r
         run-level 3  Jul 28 09:15                   last=S
		</screen>
	</section>
	<section><title>Changing the runlevel</title>
		<para>You can switch to another runlevel with the <command>telinit</command> command. On Linux <command>/sbin/telinit</command> is usually a hard link to /sbin/init.</para>
	</section>
	<section><title>more info</title>
	<para>You might also want to take a look at <command>chkconfig</command>, <command>update-rc.d</command>, <command>shutdown</command>, <command>poweroff</command> and passing <command>init=/bin/bash</command> to the kernel.</para>
</section>
<section><title>Practice</title>
	<para>1. Change /etc/inittab so that only two mingetty's are respawned. Kill the other mingetty's and verify that they don't come back.</para>
	<para>2. Use the Red Hat Enterprise Linux 4 virtual machine. Go to runlevel 5, display the current and previous runlevel, then go back to runlevel 3.</para>
	<para>3. Is the sysinit script on your computers setting or changing the PATH environment variable ?</para>
	<para>4. Write a script that acts like a daemon script in /etc/init.d/. It should have a case statement to act on start/stop/restart and status. Test the script!</para>
	<para>5. Have your script started automatically in runlevel 3, test that it works. If it works, also try stopping it in a runlevel.</para>
	<para>6. If time permits, use chkconfig to setup your script in runlevels 2 and 3.</para>
</section>

</chapter>
<chapter><title>Scheduling</title>
	<section><title>at</title>
		<para>Simple scheduling can be done with the <command>at</command> command. This screenshot shows the scheduling of the date command at 22:01 and the sleep command at 22:03. <emphasis>In real life you will hopefully be scheduling more useful commands.</emphasis></para>
		<screen>
root@laika:~# at 22:01
at&#062; date
at&#062; &#060;EOT&#062;
job 1 at Wed Aug  1 22:01:00 2007
root@laika:~# at 22:03
at&#062; sleep 10
at&#062; &#060;EOT&#062;
job 2 at Wed Aug  1 22:03:00 2007
root@laika:~#
		</screen>
		<para>It is easy to check what is scheduled with the <command>atq</command> or <command>at -l</command> commands.</para>
		<screen>
root@laika:~# atq
1       Wed Aug  1 22:01:00 2007 a root
2       Wed Aug  1 22:03:00 2007 a root
root@laika:~# at -l
1       Wed Aug  1 22:01:00 2007 a root
2       Wed Aug  1 22:03:00 2007 a root
root@laika:~# 	
		</screen>
		<para>The at command understands English words like tomorrow and teatime.</para>
		<screen>
root@laika:~# at 10:05 tomorrow
at&#062; sleep 100
at&#062; &#060;EOT&#062;
job 5 at Thu Aug  2 10:05:00 2007
root@laika:~# at teatime tomorrow
at&#062; tea
at&#062; &#060;EOT&#062;
job 6 at Thu Aug  2 16:00:00 2007
root@laika:~# atq
6       Thu Aug  2 16:00:00 2007 a root
5       Thu Aug  2 10:05:00 2007 a root
root@laika:~# 
		</screen>
		<para>Jobs in the at queue can be removed with <command>atrm</command>.</para>
		<screen>
root@laika:~# atq
6       Thu Aug  2 16:00:00 2007 a root
5       Thu Aug  2 10:05:00 2007 a root
root@laika:~# atrm 5
root@laika:~# atq
6       Thu Aug  2 16:00:00 2007 a root
root@laika:~# 
		</screen>
		<para>For more information, check the man page of at for the significance of <command>/etc/at.allow</command> and <command>/etc/at.deny</command> and at output redirection.</para>
	</section>
	<section><title>crontab</title>
		<para>The <command>crontab(1)</command> command can be used to maintain the <command>crontab(5)</command> file. Each user can have their own crontab file to schedule jobs at a specific time. This time can be specified with five fields in this order: minute, hour, day of the month, month and day of the week. If a field contains an asterisk (*), then this means all values of that field. </para>
		<para>The following example means : run script42 eight minutes after two, every day of the month, every month and every day of the week.</para>
		<screen>8 14 * * * script42</screen>
		<para>Run script8472 every month on the first of the month at 25 past midnight.</para>
		<screen>25 0 1 * * script8472</screen>
		<para>Run this script33 every two minutes on sunday (both 0 and 7 refer to sunday).</para>
		<screen>*/2 * * * 0</screen>
		<para>Instead of these five fields, you can also type one of these: @reboot, @yearly or @annually, @monthly, @weekly, @daily or @midnight, and @hourly.</para>
		<para>Users should not edit the crontab file directly, instead they should type <command>crontab -e</command> which will use the editor defined in the EDITOR or VISUAL environment variable. Users can display their cron table with <command>crontab -l</command>. The <command>cron daemon</command> is reading the cron tables, taking into account the <command>/etc/cron.allow</command> and <command>/etc/cron.deny</command> files.</para>
	</section>
	<section><title>Practice Scheduling</title>
		<para>1. Schedule two jobs with at, display the at queue and remove a job.</para>
		<para>2. As normal user, use crontab -e to schedule a script to run every two minutes.</para>
		<para>3. As root, display the crontab file of your normal user.</para>
		<para>4. Take a look at the cron files and directories in /etc and understand them. What is the run-parts command doing ?</para>
		<para></para>
	</section>
</chapter>
<chapter><title>Memory</title>
	<para>You can display information about RAM memory with <command>free -om</command>, <command>top</command> and cat <command>/proc/meminfo</command>. You should understand terms like <command>swapping</command>, <command>paging</command> and <command>virtual memory</command>.</para>
        <section><title>Swap space</title>
		<section><title>About swap space</title>
			<para>When the operating system needs more memory than physically present in RAM, it will use <command>swap space</command>. Swap space is located on slower but cheaper memory. Notice that, although hard disks are commonly used for swap space, their access times are one hundred thousand times slower.</para>
			<para>The swap space can be a file, a partition, or a combination of files and partitions. You can see the swap space with the <command>free</command> command, or with <command>cat /proc/swaps</command>.</para>
			<screen>
paul@RHELv4u4:~$ free -om
total       used       free     shared    buffers     cached
Mem:           249        245          4          0        125         55
Swap:         1023          0       1023
paul@RHELv4u4:~$ cat /proc/swaps 
Filename                                Type            Size    Used    Priority
/dev/mapper/VolGroup00-LogVol01         partition       1048568 0       -1
paul@RHELv4u4:~$
			</screen>
			<para>The amount of swap space that you need depends heavily on the services that the computer provides.</para>
		</section>
		<section><title>Creating a swap partition</title>
			<para>You can activate or deactivate swap space with the <command>swapon</command> an <command>swapoff</command> commands. New swap space can be created with the <command>mkswap</command> command. The screenshot below shows the creation and activation of a swap partition.</para>
			<screen>
root@RHELv4u4:~# fdisk -l 2> /dev/null | grep hda
Disk /dev/hda: 536 MB, 536870912 bytes
/dev/hda1               1        1040      524128+  83  Linux
root@RHELv4u4:~# mkswap /dev/hda1
Setting up swapspace version 1, size = 536702 kB
root@RHELv4u4:~# swapon /dev/hda1
			</screen>
			<para>Now you can see that <command>/proc/swaps</command> displays all swap spaces separately, whereas the <command>free -om</command> command only makes a human readable summary.</para> 
			<screen>
root@RHELv4u4:~# cat /proc/swaps
Filename                                Type            Size    Used    Priority
/dev/mapper/VolGroup00-LogVol01         partition       1048568 0       -1
/dev/hda1                               partition       524120  0       -2
root@RHELv4u4:~# free -om
total       used       free     shared    buffers     cached
Mem:           249        245          4          0        125         54
Swap:         1535          0       1535
root@RHELv4u4:~# 
			</screen>
		</section>
		<section><title>Creating a swap file</title>
			<para>Here is one more example showing you how to create a <command>swap file</command>. On Solaris you can use <command>mkfile</command> instead of <command>dd</command>.</para>
			<screen>
root@RHELv4u4:~# dd if=/dev/zero of=/smallswapfile bs=1024 count=4096
4096+0 records in
4096+0 records out
root@RHELv4u4:~# mkswap /smallswapfile 
Setting up swapspace version 1, size = 4190 kB
root@RHELv4u4:~# swapon /smallswapfile 
root@RHELv4u4:~# cat /proc/swaps 
Filename                                Type            Size    Used    Priority
/dev/mapper/VolGroup00-LogVol01         partition       1048568 0       -1
/dev/hda1                               partition       524120  0       -2
/smallswapfile                          file            4088    0       -3
root@RHELv4u4:~# 
			</screen>
		</section>
		<section><title>Swap space in /etc/fstab</title>
			<para>If you like these swaps to be permanent, then don't forget to add them to <command>/etc/fstab</command>. The lines in /etc/fstab will be similar to the following.</para>
			<screen>
/dev/hda1         swap       swap     defaults      0 0
/smallswapfile    swap       swap     defaults      0 0
		</screen>	
		</section>
	</section>
	<section><title>Practice Memory</title>
		<para>1. Use <command>dmesg</command> to find the total amount of memory in your computer.</para>
		<para>2. Use <command>free</command> to display memory usage in kilobytes (then in megabytes).</para>
		<para>3. On the Red Hat, create a swap partition on one of your new disks, and a swap file on the other new disk.</para>
		<para>4. Put all swap spaces in /etc/fstab and activate them. Use free again to verify that it works.</para>	
	</section>
</chapter>

<chapter><title>RAID</title>
	<section><title>Hardware or software</title>
		<para>Redundant Array of Independent Disks or <command>RAID</command> can be set up using hardware or software. Hardware RAID is more expensive, but offers better performance. Software RAID is cheaper and easier to manage, but it uses your CPU and your memory.</para>
	</section>
	<section><title>RAID levels</title>
		<section><title>RAID 0</title>
			<para>RAID 0 uses two or more disks, and is often called <command>striping</command> (or stripe set, or striped volume). Data is divided in <command>chunks</command>, those chunks are evenly spread across every disk in the array. The main advantage of RAID 0 is that you can create <command>larger drives</command>. RAID 0 is the only RAID without redundancy.</para>
		</section>
		<section><title>JBOD</title>
			<para>JBOD uses two or more disks, and is often called <command>concatenating</command> (spanning, spanned set, or spanned volume). Data is written to the first disk, until it is full. Then data is written to the second disk... The main advantage of JBOD (Just a Bunch of Disks) is that you can create <command>larger drives</command>. JBOD offers no redundancy.</para>
		</section>
		<section><title>RAID 1</title>
			<para>RAID 1 uses exactly two disks, and is often called <command>mirroring</command> (or mirror set, or mirrored volume). All data written to the array is written on each disk. The main advantage of RAID 1 is <command>redundancy</command>. The main disadvantage is that you lose at least half of your available disk space (in other words, you at least double the cost).</para>
		</section>
		<section><title>RAID 2, 3 and 4 ?</title>
			<para>RAID 2 uses bit level striping, RAID 3 byte level, and RAID 4 is the same as RAID 5, but with a dedicated parity disk. This is actually slower than RAID 5, because every write would have to write parity to this one (bottleneck) disk. It is unlikely that you will ever see these RAID levels in production.</para>
		</section>
		<section><title>RAID 5</title>
			<para>RAID 5 uses <command>three</command> or more disks, each divided into chunks. Every time chunks are written to the array, one of the disks will receive a <command>parity</command> chunk. Unlike RAID 4, the parity chunk will alternate between all disks. The main advantage of this is that RAID 5 will allow for full data recovery in case of <command>one</command> hard disk failure.</para>
		</section>
		<section><title>RAID 6</title>
			<para>RAID 6 is very similar to RAID 5, but uses two parity chunks. RAID 6 protects against two hard disk failures.</para>
		</section>
		<section><title>RAID 0+1</title>
			<para>RAID 0+1 is a mirror(1) of stripes(0). This means you first create two RAID 0 stripe sets, and then you set them up as a mirror set. For example, when you have six 100GB disks, then the stripe sets are each 300GB. Combined in a mirror, this makes 300GB total. RAID 0+1 will survive one disk failure. It will only survive the second disk failure if this disk is in the same stripe set as the previous failed disk.</para>
		</section>
		<section><title>RAID 1+0</title>
			<para>RAID 1+0 is a stripe(0) of mirrors(1). For example, when you have six 100GB disks, then you first create three mirrors of 100GB each. You then stripe them together into a 300GB drive. In this example, as long as not all disks in the same mirror fail, it can survive up to three hard disk failures.</para>
		</section>
		<section><title>RAID 50</title>
			<para>RAID 5+0 is a stripe(0) of RAID 5 arrays. Suppose you have nine disks of 100GB, then you can create three RAID 5 arrays of 200GB each. You can then combine them into one large stripe set.</para>
		</section>
		<section><title>many others</title>
			<para>There are many other nested RAID combinations, like RAID 30, 51, 60, 100, 150, ...</para>
		</section>
	</section>
	<section><title>Building a software RAID array</title>
		<para>You can do this during the installation with Disk Druid (easy), or afterwards using the commandline (not so easy). </para>
		<para>First, you have to attach some disks to your computer. In this scenario, three brand new disks of one gigabyte each are added. Check with <command>fdisk -l</command> that they are connected.</para>
		<screen>
root@RHELv4u2:~# fdisk -l
		
Disk /dev/sda: 12.8 GB, 12884901888 bytes
255 heads, 63 sectors/track, 1566 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          13      104391   83  Linux
/dev/sda2              14        1566    12474472+  8e  Linux LVM
		
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Disk /dev/sdb doesn't contain a valid partition table
		
Disk /dev/sdc: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Disk /dev/sdc doesn't contain a valid partition table
		
Disk /dev/sdd: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Disk /dev/sdd doesn't contain a valid partition table
		</screen>
		<para>So far so good! Next step is to create a partition of type <command>fd</command> on every disk. The fd type is to set the partition as <command>Linux RAID auto</command>. Like this screenshot shows. </para>
		<screen>
root@RHELv4u2:~# fdisk /dev/sdc
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content won't be recoverable.
		
Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)
		
Command (m for help): n
Command action
e   extended
p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-130, default 1): 
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-130, default 130): 
Using default value 130
		
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): fd
Changed system type of partition 1 to fd (Linux raid autodetect)
		
Command (m for help): p
		
Disk /dev/sdc: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdc1               1         130     1044193+  fd  Linux raid autodetect
		
Command (m for help): w
The partition table has been altered!
		
Calling ioctl() to re-read partition table.
Syncing disks.
root@RHELv4u2:~# 
		</screen>
		<para>Now all three disks are ready for RAID, so we have to tell the system what to do with these disks.</para>
		<screen>
root@RHELv4u2:~# fdisk -l
		
Disk /dev/sda: 12.8 GB, 12884901888 bytes
255 heads, 63 sectors/track, 1566 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          13      104391   83  Linux
/dev/sda2              14        1566    12474472+  8e  Linux LVM
		
Disk /dev/sdb: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         130     1044193+  fd  Linux raid autodetect
		
Disk /dev/sdc: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdc1               1         130     1044193+  fd  Linux raid autodetect
		
Disk /dev/sdd: 1073 MB, 1073741824 bytes
255 heads, 63 sectors/track, 130 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
		
Device Boot      Start         End      Blocks   Id  System
/dev/sdd1               1         130     1044193+  fd  Linux raid autodetect
		</screen>
		<para>The next step used to be <emphasis>create the RAID table in <command>/etc/raidtab</command></emphasis>. Nowadays, you can just issue the command <command>mdadm</command> with the correct parameters. The command below is split on two lines to fit this print, but you should type it on one line, without the backslash (\).</para>
		<screen>
root@RHELv4u2:~# mdadm --create /dev/md0 --chunk=64 --level=5 --raid-devices=3\
/dev/sdb1 /dev/sdc1 /dev/sdd1
mdadm: array /dev/md0 started.
		</screen>
		<para>Below a partial screenshot how fdisk -l sees the RAID5</para>
		<screen>
root@RHELv4u2:~# fdisk -l
		
&#060;cut&#062;
			
Disk /dev/md0: 2138 MB, 2138308608 bytes
2 heads, 4 sectors/track, 522048 cylinders
Units = cylinders of 8 * 512 = 4096 bytes
			
Disk /dev/md0 doesn't contain a valid partition table			
		</screen>
		<para>We will use this software RAID 5 array in the next topic, LVM.</para>
	</section>
	<section><title>Practice RAID</title>
		<para>1. Add three virtual disks of 200MB each to the virtual Red Hat machine.</para>
		<para>2. Create a software RAID 5 on the three disks. (It is not necessary to put a filesystem on it)</para>
		<para>3. Verify with fdisk and in /proc/ that the RAID exists.</para>
	</section>
</chapter>

<chapter><title>Logical Volume Management (LVM)</title>
	<section><title>About lvm</title>
		<para>Most LVM implementations support <command>physical storage grouping</command>, <command>logical volume resizing</command> and <command>data migration</command>. </para>
		<para>Physical storage grouping is a fancy name for grouping multiple physical devices (hard disks) into a logical mass storage device. To enlarge this physical group, hard disks or even single partitions can be added at a later time. The size of LVM volumes on this physical group is independent of the individual size of the components. The total size of the group is the limit.</para>
		<para>One of the nicest features of LVM is the logical volume resizing. You can increase the size of an LVM volume, sometimes even without any downtime. Additionally, you can migrate data away from a failing hard disk device. </para>
		<para>LVM does not replace hardware RAID yet. LVM and RAID are often used together.</para>
	</section>
	<section><title>An example of LVM</title>
		<para>First thing to do, is create physical volumes that can join the volume group with <command>pvcreate</command>. Below we  present our software RAID 5 to LVM. Then <command>vgcreate</command> creates a volume group using one device. Note that more devices could be added to the volume group. The last step <command>lvcreate</command> creates a logical volume, which we can use as any other disk.</para>
		<screen>
root@RHELv4u2:~# pvcreate /dev/md0
Physical volume "/dev/md0" successfully created
root@RHELv4u2:~# vgcreate vg /dev/md0
Volume group "vg" successfully created
root@RHELv4u2:~# lvcreate --size 500m vg
/dev/cdrom: open failed: Read-only file system
Logical volume "lvol0" created
		</screen>
		<para>The logical volume /dev/vg/lvol0 can now be formatted with ext2, and mounted for normal use.</para>
		<screen>
root@RHELv4u2:~# mke2fs -m0 -j /dev/vg/lvol0 
mke2fs 1.35 (28-Feb-2004)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
128016 inodes, 512000 blocks
0 blocks (0.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67633152
63 block groups
8192 blocks per group, 8192 fragments per group
2032 inodes per group
Superblock backups stored on blocks: 
8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409
			
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
			
This filesystem will be automatically checked every 37 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
root@RHELv4u2:~# mkdir /home/project10
root@RHELv4u2:~# mount /dev/vg/lvol0 /home/project10/
root@RHELv4u2:~# df -h | grep proj
/dev/mapper/vg-lvol0  485M   11M  474M   3% /home/project10
		</screen>
	</section>
	<section><title>Practice LVM</title>
		<para>1. Create a volume group that contains a software RAID5, a complete disk and a partition on another disk.</para>
		<para>2. Create two logical volumes a small one and a bigger one. Format them wih ext2, mount them and copy some files to them.</para>
		<para>3. Verify usage with fdisk and df.</para>
		<para>4. Enlarge the small logical volume by 50 percent.</para>
		<para>5. Take a look at other commands that start with vg* , pv* or lv*.</para>
	</section>
</chapter>
<chapter><title>Disk quotas</title>
	<section><title>Disk Quotas</title>
		<para>To limit the disk space used by user, you can set up <command>disk quotas</command>. This requires adding <command>usrquota</command> and/or <command>grpquota</command> to one or more of the file systems in <command>/etc/fstab</command>. </para>
		<screen>
root@RHELv4u4:~# cat /etc/fstab | grep usrquota
/dev/VolGroup00/LogVol02     /home     ext3     usrquota,grpquota   0 0
		</screen>
		<para>Next you need to remount the file system.</para>
		<screen>
root@RHELv4u4:~# mount -o remount /home
		</screen>
		<para>The next step is to build the <command>quota.user</command> and/or <command>quota.group</command> files. These files (called the <command>quota files</command>) contain the table of the disk usage on that file system. Use the <command>quotacheck</command> command to accomplish this.</para>
		<screen>
root@RHELv4u4:~# quotacheck -cug /home
root@RHELv4u4:~# quotacheck -avug
		</screen>
		<para>The <command>-c</command> is for create, <command>u</command> for user quota, <command>g</command> for group, <command>a</command> for checking all quota enabled file systems in /etc/fstab and <command>v</command> for verbose information. The next step is to edit individual user quotas with <command>edquota</command> or set a general quota on the file system with <command>edquota -t</command>. The tool will enable you to put <command>hard</command> (this is the real limit) and <command>soft</command> (allows a grace period) limits on <command>blocks</command> and <command>inodes</command>. The <command>quota</command> command will verify that quota for a user is set. You can have a nice overview with <command>repquota</command>.</para>
		<para>The final step (before your users start complaining about lack of disk space) is to enable quotas.</para>
		<screen>root@RHELv4u4:~# quotaon -vaug</screen>
		<para>Issue the following command to stop all complaints.</para>
		<screen>root@RHELv4u4:~# quotaoff -vaug</screen>
	</section>
	<section><title>Practice Disk quotas</title>
		<para>1. Implement disk quotas on one of your new partitions. Limit one of your users to 10 megabyte.</para>
		<para>2. Test that they work by copying many files to the quota'd partition.</para>	
	</section>
</chapter>

<chapter><title>Access Control Lists</title>
	<section><title>Access Control Lists</title>
		<para>When standard Unix permissions are insufficient, you can mount a partition with <command>acl</command> support, and use <command>setfacl</command> and <command>getfacl</command> to set and get Access Control Lists on your files.</para>
	</section>
</chapter>

<chapter><title>Installing Software</title>
	<para>Software for your Linux distribution is not scattered all over the place like some other OS'ses, but is in general managed in a central distributed repository. This means that applications in the repository are tested for your distribution. Installing this software is very easy. The problem begins when you need software from outside of the central repository.</para>
	<para>You can install software from the repository on Linux in different ways. Beginners should use the graphical software installation tool that is provided by the distribution (Synaptic on Debian, Add/Remove Software on Ubuntu, Yast on Suse, ...). More advanced people tend to use the command line (rpm, yum, dpkg, aptitude). A third option is to download vanilla source code and compile the software yourself, providing the application is open source.</para>
	<section><title>RPM (Red Hat, Suse, ...)</title>
		<para>The <command>RPM Package Manager</command> can be used on the command line with <command>rpm</command> or in a graphical way going to Applications--System Settings--Add/Remove Applications. Type <command>rpm --help</command> to see some of the options. Software distributed in the rpm format will be named foo-version.platform.rpm .</para>	
		<para>To obtain a list of all installed software, use the <command>rpm -qa</command> command. To check whether a package is provided by Red Hat, use the <command>--redhatprovides</command> option.</para>
		<screen>
root@RHELv4u4:~# rpm -q --redhatprovides bash
bash-3.0-19.3
root@RHELv4u4:~# rpm -q --redhatprovides gcc
gcc-3.4.6-3
root@RHELv4u4:~# rpm -q --redhatprovides laika
no package provides laika
root@RHELv4u4:~# 
		</screen>	
		<para>To verify whether a package is installed, use -q.</para>
		<screen>
root@RHELv4u4:~# rpm -q gcc
gcc-3.4.6-3
root@RHELv4u4:~# rpm -q laika
package laika is not installed
root@RHELv4u4:~# 
		</screen>
		<para>To install or upgrade a package, use the -Uvh switches.</para>
		<screen>rpm -Uvh gcc-3.4.6-3</screen>
		<para>To remove a package, use the -e switch.</para>
		<screen>rpm -e gcc-3.4.6-3</screen>
	</section>
	<section><title>Yum (Fedora)</title>
		<para>Yum is an easier way to work with rpm packages. It is installed by default on Fedora.</para>
		<para>Issue this to see a list of available packages.</para>
		<screen>yum list available</screen>
		<para>To install an application.</para>
		<screen>yum install $appName</screen>
		<para>To upgrade all applications.</para>
		<screen>yum update</screen>
		<para>To search for a package containing a certain string in the description or name.</para>
		<screen>yum search $string</screen>
	</section>
	<section><title>dpkg and Aptitude (Debian, Ubuntu, ...)</title>
		<para>Debian uses .deb packages, managed by <command>dpkg</command>, or more commonly today by <command>aptitude</command>. The big advantage of aptitude is it's ease of use and it's power to handle dependencies.</para>
		<para>To synchronize with the repositories.</para>
		<screen>aptitude update</screen>
		<para>To patch and upgrade all software to the latest version..</para>
		<screen>aptitude upgrade</screen>
		<para>To install an application with all dependencies.</para>
		<screen>aptitude install $appName</screen>
		<para>To search the repositories for applications that contain a certain string in their name or description.</para>
		<screen>aptitude search $string</screen>
		<para>To remove an application and all unused files.</para>
		<screen>aptitude remove $appName</screen>
	</section>
	<section><title>Downloading software</title>
		<para>First and most important, whenever you download software, start by reading the README file!</para>
		<para>Normally the readme will explain what to do after download. You will probably receive a .tar.gz or a .tgz file. Read the documentation, then put the compressed file in a directory. You can use the following to find out where the package wants to install.</para>
		<screen>tar tvzpf $downloadedFile.tgz</screen>
		<para>You unpack them like with <command>tar xzf</command>, it will create a directory called applicationName-1.2.3</para>
		<screen>tar xzf $applicationName.tgz</screen>
		<para>Replace the z with a j when the file ends in .tar.bz2. The <command>tar</command>, gzip and bzip2 commands are explained in detail later.</para>
		<para>If you download a .deb file, then you'll have to use dpkg to install it, .rpm's can be installed with the rpm command. Sometimes people use the <command>alien</command> command to convert between package formats.</para>
	</section>
	<section><title>Compiling software</title>
		<para>First and most important, whenever you download source code for installation, start by reading the README file!</para>
		<para>Usually the steps are always the same three : running <command>./configure</command> followed by <command>make</command> (which is the actual compiling) and then by <command>make install</command> to copy the files to their proper location.</para>
		<screen>
./configure
make
make install
		</screen>
	</section>
	<section><title>Practice Installing software</title>
		<para>1. Find the GUI app on all computers to add and remove applications.</para>
		<para>2. Use aptitude to install the 'dict' application.</para>
		<para>3. Search the internet for 'webmin' and install it.</para>
		<para>4. If time permits, uninstall Samba from the ubuntu machine, download the latest version from samba.org and install it.</para>
	</section>
</chapter>
<chapter><title>Backup</title>
	<section><title>backup devices</title>
		<para>Don't forget that the name of a device strictly speaking has no meaning since the kernel will use the major and minor number to find the hardware! See the man page of <command>mknod</command> and the devices.txt file in the linux kernel source for more info.</para>
		<section><title>SCSI tapes</title>
			<para>On the official Linux device list (http://www.lanana.org/docs/device-list/) we find the names for SCSI tapes (major 9 char). SCSI tape devices are located underneath <command>/dev/st</command> and are numbered starting with 0 for the first tape device.</para>
			<screen>
/dev/st0   First tape device
/dev/st1   Second tape device
/dev/st2   Third tape device
			</screen>
			<para>To prevent <command>automatic rewinding of tapes</command>, prefix them with the letter n.</para>
			<screen>
/dev/nst0   First no rewind tape device
/dev/nst1   Second no rewind tape device
/dev/nst2   Third no rewind tape device
			</screen>
			<para>By default, SCSI tapes on linux will use the highest hardware compression that is supported by the tape device. To lower the compression level, append one of the letters l (low), m (medium) or a (auto) to the tape name.</para>
			<screen>
/dev/st0l   First low compression tape device
/dev/st0m   First medium compression tape device
/dev/nst2m  Third no rewind medium compression tape device
			</screen>
		</section>
		<section><title>IDE tapes</title>
			<para>On the official Linux device list (http://www.lanana.org/docs/device-list/) we find the names for IDE tapes (major 37 char). IDE tape devices are located underneath <command>/dev/ht</command> and are numbered starting with 0 for the first tape device. No rewind and compression is similar to SCSI tapes.</para>
			<screen>
/dev/ht0   First IDE tape device
/dev/nht0  Second no rewind IDE tape device
/dev/ht0m  First medium compression IDE tape device
			</screen>
		</section>
	</section>
	<section><title>Backup Types</title>
		<para>Linux uses <command>multilevel incremental</command> backups using distinct levels. A full backup is a backup at level 0. A higher level x backup will include all changes since the last level x-1 backup.</para>
		<para>Suppose you take a full backup on Monday (level 0) and a level 1 backup on Tuesday, then the Tuesday backup will contain all changes since Monday. Taking a level 2 on Wednesday will contain all changes since Tuesday (the last level 2-1). A level 3 backup on Thursday will contain all changes since Wednesday (the last level 3-1). Another level 3 on Friday will also contain all changes since Wednesday. A level 2 backup on Saturday would take all changes since the last level 1 from Tuesday.</para>
	</section>
	<section><title>Compression</title>
		<para>It can be beneficial to compress files before backup. The two most popular tools for compression of regular files on linux are <command>gzip/gunzip</command> and <command>bzip2/bunzip2</command>. Below you can see gzip in action, notice that it adds the <command>.gz</command> extension to the file.</para>
		<screen>
paul@RHELv4u4:~/test$ ls -l allfiles.tx*
-rw-rw-r--  1 paul paul 8813553 Feb 27 05:38 allfiles.txt
paul@RHELv4u4:~/test$ gzip allfiles.txt 
paul@RHELv4u4:~/test$ ls -l allfiles.tx*
-rw-rw-r--  1 paul paul 931863 Feb 27 05:38 allfiles.txt.gz
paul@RHELv4u4:~/test$ gunzip allfiles.txt.gz 
paul@RHELv4u4:~/test$ ls -l allfiles.tx*
-rw-rw-r--  1 paul paul 8813553 Feb 27 05:38 allfiles.txt
paul@RHELv4u4:~/test$ 
		</screen>
		<para>In general, gzip is much faster than bzip2, but the latter one compresses a lot better. Let us compare the two.</para>
		<screen>
paul@RHELv4u4:~/test$ cp allfiles.txt bllfiles.txt 
paul@RHELv4u4:~/test$ time gzip allfiles.txt 
		
real    0m0.050s
user    0m0.041s
sys     0m0.009s
paul@RHELv4u4:~/test$ time bzip2 bllfiles.txt 
		
real    0m5.968s
user    0m5.794s
sys     0m0.076s
paul@RHELv4u4:~/test$ ls -l ?llfiles.tx*
-rw-rw-r--  1 paul paul 931863 Feb 27 05:38 allfiles.txt.gz
-rw-rw-r--  1 paul paul 708871 May 12 10:52 bllfiles.txt.bz2
paul@RHELv4u4:~/test$ 
		</screen>
	</section>
	<section><title>tar</title>
		<para>The <command>tar</command> utility gets its name from <command>Tape ARchive</command>. This tool will receive and send files to a destination (typically a tape or a regular file). The c option is used to create a tar archive (or tarfile), the f option to name/create the <command>tarfile</command>. The example below takes a backup of /etc into the file /backup/etc.tar .</para>
		<screen>
root@RHELv4u4:~# tar cf /backup/etc.tar /etc
root@RHELv4u4:~# ls -l /backup/etc.tar 
-rw-r--r--  1 root root 47800320 May 12 11:47 /backup/etc.tar
root@RHELv4u4:~#
		</screen>
		<para>Compression can be achieved without pipes since tar uses the z flag to compress with gzip, and the j flag to compress with bzip2.</para>
		<screen>
root@RHELv4u4:~# tar czf /backup/etc.tar.gz /etc
root@RHELv4u4:~# tar cjf /backup/etc.tar.bz2 /etc
root@RHELv4u4:~# ls -l /backup/etc.ta*
-rw-r--r--  1 root root 47800320 May 12 11:47 /backup/etc.tar
-rw-r--r--  1 root root  6077340 May 12 11:48 /backup/etc.tar.bz2
-rw-r--r--  1 root root  8496607 May 12 11:47 /backup/etc.tar.gz
root@RHELv4u4:~# 
		</screen>
		<para>The t option is used to <command>list the contents of a tar file</command>. Verbose mode is enabled with v (also useful when you want to see the files being archived during archiving).</para>
		<screen>
root@RHELv4u4:~# tar tvf /backup/etc.tar
drwxr-xr-x root/root         0 2007-05-12 09:38:21 etc/
-rw-r--r-- root/root      2657 2004-09-27 10:15:03 etc/warnquota.conf
-rw-r--r-- root/root     13136 2006-11-03 17:34:50 etc/mime.types
drwxr-xr-x root/root         0 2004-11-03 13:35:50 etc/sound/
...
		</screen>
		<para>To <command>list a specific file in a tar archive</command>, use the t option, added with the filename (without leading /).</para>
		<screen>
root@RHELv4u4:~# tar tvf /backup/etc.tar etc/resolv.conf
-rw-r--r-- root/root        77 2007-05-12 08:31:32 etc/resolv.conf
root@RHELv4u4:~# 
		</screen>
		<para>Use the x flag to <command>restore a tar archive</command>, or a single file from the archive. Remember that by default tar will restore the file in the current directory.</para>
		<screen>
root@RHELv4u4:~# tar xvf /backup/etc.tar etc/resolv.conf
etc/resolv.conf
root@RHELv4u4:~# ls -l /etc/resolv.conf
-rw-r--r--  2 root root 40 May 12 12:05 /etc/resolv.conf
root@RHELv4u4:~# ls -l etc/resolv.conf
-rw-r--r--  1 root root 77 May 12 08:31 etc/resolv.conf
root@RHELv4u4:~# 
		</screen>
		<para>You can <command>preserve file permissions</command> with the p flag. And you can exclude directories or file with <command>--exclude</command>.</para>
		<screen>
root@RHELv4u4:~# tar cpzf /backup/etc_with_perms.tgz /etc 
root@RHELv4u4:~# tar cpzf /backup/etc_no_sysconf.tgz /etc --exclude /etc/sysconfig
root@RHELv4u4:~# ls -l /backup/etc_*
-rw-r--r--  1 root root 8434293 May 12 12:48 /backup/etc_no_sysconf.tgz
-rw-r--r--  1 root root 8496591 May 12 12:48 /backup/etc_with_perms.tgz
root@RHELv4u4:~# 
		</screen>
		<para>You can also create a text file with names of files and directories to archive, and then supply this file to tar with the -T flag.</para>
		<screen>
root@RHELv4u4:~# find /etc -name *.conf > files_to_archive.txt
root@RHELv4u4:~# echo /home -iname *.pdf >> files_to_archive.txt
root@RHELv4u4:~# tar cpzf /backup/backup.tgz -T files_to_archive.txt 
		</screen>
		<para>The tar utility can receive filenames from the find command, with the help of xargs.</para>
		<screen>
root@RHELv4u4:~# find /etc -type f -name "*.conf" | xargs tar czf /backup/confs.tar.gz
		</screen>
		<para>You can also use tar to copy a directory, this is more efficient than using cp -r.</para>
		<screen>
root@RHELv4u4:~# (cd /etc; tar -cf - . ) | (cd /backup/copy_of_etc/; tar -xpf - )
		</screen>
		<para>Another example of tar, this copies a directory securely over the network.</para>
		<screen>
root@RHELv4u4:~# (cd /etc; tar -cf - . ) | (ssh user@server 'cd /backup/copy_of_etc/; tar -xf - ')
		</screen>
		<para>tar can be used together with gzip and copy a file to a remote server through ssh</para>
		<screen>
cat backup.tar | gzip | ssh bashuser@192.168.1.105 "cat - > backup.tgz"
		</screen>
		<para>Compress the tar backup when it is on the network, but leave it uncompressed at the destination.</para>
		<screen>
cat backup.tar | gzip | ssh bashuser@192.168.1.105 "gunzip | cat - > backup.tar"
		</screen>
		<para>Same as the previous, but let ssh handle the compression</para>
		<screen>
cat backup.tar | ssh -C bashuser@192.168.1.105 "cat - > backup.tar"
		</screen>
	</section>
	<section><title>dump and restore</title>
		<para>While <command>dump</command> is similar to tar, it is also very different because it looks at the file system. Where tar receives a lists of files to backup, dump will find files to backup by itself by examining ext2. Files found by dump will be copied to a tape or regular file. In case the target is not big enough to hold the dump (end-of-media), it is broken into multiple volumes.</para>
		<para>Restoring files that were backed up with dump is done with the <command>restore</command> command. In the example below we take a full level 0 backup of two partitions to a SCSI tape. The no rewind is mandatory to put the volumes behind each other on the tape.</para>
		<screen>
dump 0f /dev/nst0 /boot
dump 0f /dev/nst0 /
		</screen>
		<para>Listing files in a dump archive is done with <command>dump -t</command>, and you can compare files with <command>dump -C</command>.</para>
		<para>You can omit files from a dump by changing the dump attribute with the <command>chattr</command> command. The d attribute on ext will tell dump to skip the file, even during a full backup. In the following example, /etc/hosts is excluded from dump archives.</para>
		<screen>
chattr +d /etc/hosts
		</screen>
		<para>To restore the complete file system with <command>restore</command>, use the -r option. This can be useful to change the size or block size of a file system. You should have a clean file system mounted and cd'd into it. Like this example shows.</para>
		<screen>
mke2fs /dev/hda3
mount /dev/hda3 /mnt/data
cd /mnt/data
restore rf /dev/nst0
		</screen>
		<para>To extract only one file or directory from a dump, use the -x option.</para>
		<screen>
restore -xf /dev/st0 /etc
		</screen>
	</section>
	<section><title>cpio</title>
		<para>Different from tar and dump is <command>cpio</command> (Copy Input and Output). It can be used to receive filenames, but copies the actual files. This makes it an easy companion with find! Some examples below.</para>
		<para>find sends filenames to cpio, which puts the files in an archive.</para>
		<screen>find /etc -depth -print | cpio -oaV -O archive.cpio</screen>
		<para>The same, but compressed with gzip</para>
		<screen>find /etc -depth -print | cpio -oaV | gzip -c > archive.cpio.gz	</screen>
		<para>Now pipe it through ssh (backup files to a compressed file on another machine)</para>
		<screen>find /etc -depth -print | cpio -oaV | gzip -c | ssh user@host "cat - > backup.cpio.gz"</screen>
		<para>find sends filenames to cpio | cpio sends files to ssh | ssh sends files to cpio 'cpio extracts files'</para>
		<screen>find /etc -depth -print | cpio -oaV | ssh user@host 'cpio -imVd'</screen>
		<para>the same but reversed: copy a dir from the remote host to the local machine</para>
		<screen>ssh user@host "find path -depth -print | cpio -oaV" | cpio -imVd</screen>
	</section>
	<section><title>dd</title>
		<para>Some people use <command>dd</command> to create backups. This can be very powerful, but dd backups can only be restored to very similar partitions or devices. There are however a lot of useful things possible with dd. Some examples.</para>
		<para>The easiest way to create a <command>.ISO file</command> from any CD. The if switch means Input File, of is the Output File. Any good tool can burn a copy of the CD with this .ISO file.</para>
		<screen>dd if=/dev/cdrom of=/path/to/cdrom.ISO</screen>
		<para>A little outdated maybe, but just in case : make an image file from a 1.44MB floppy. Blocksize is defined by bs, and count contains the number of blocks to copy.</para>
		<screen>dd if=/dev/floppy of=/path/to/floppy.img bs=1024 count=1440
		</screen>
		<para>Use dd to copy the <command>MBR</command> (Master Boot Record) of hard disk /dev/hda to a file.</para>
		<screen>dd if=/dev/hda of=/MBR.img bs=512 count=1</screen>
		<para>This example shows how dd can copy files. Copy the file summer.txt to copy_of_summer.txt . </para>
		<screen>dd if=~/summer.txt of=~/copy_of_summer.txt</screen>
		<para>And who needs ghost when dd can create a (compressed) image of a partition.</para>
		<screen>
dd if=/dev/hdb2 of=/image_of_hdb2.IMG
dd if=/dev/hdb2 | gzip > /image_of_hdb2.IMG.gz
		</screen>
		<para>And there are of course endless combinations with ssh and bzip2. This example puts a bzip2 backup of a cdrom on a remote server.</para>
		<screen>dd if=/dev/cdrom | bzip2 | ssh user@host "cat - > /backups/cd/cdrom.iso.bz2"</screen>
	</section>
	<section><title>mt</title>
		<para>To manage your tapes, use <command>mt</command> (Magnetic Tape). Some examples.</para>
		<para>To receive information about the status of the tape.</para>
		<screen>mt -f /dev/st0 status</screen>
		<para>To rewind a tape...</para>
		<screen>mt -f /dev/st0 rewind</screen>
		<para>To rewind and eject a tape...</para>
		<screen>mt -f /dev/st0 eject</screen>
		<para>To erase a tape...</para>
		<screen>mt -f /dev/st0 erase</screen>
	</section>
	<section><title>Practice backup</title>
		<para>!! Careful with tar options and the position of the backup file, mistakes can destroy your system!!</para>
		<para>1. Create a directory (or partition if you like) for backups. Link (or mount) it under /mnt/backup.</para>
		<para>2a. Use tar to backup /etc in /mnt/backup/etc_date.tgz, the backup must be gzipped. (Replace date with the current date)</para>
		<para>2b. Use tar to backup /bin to /mnt/backup/bin_date.tgz, the backup must be bzip2'd.</para>
		<para>2c. Choose a file in /etc and /bin and verify with tar that the file is indeed backed up.</para>
		<para>2d. Extract those two files to your home directory.</para>
		<para>3a. Create a backup directory for your neighbour, make it accessible under /mnt/neighbourName</para>
		<para>3b. Combine ssh and tar to put a backup of your /boot on your neighbours computer in /mnt/YourName</para>
		<para>4a. Combine find and cpio to create a cpio archive of /etc.</para>
		<para>4b. Choose a file in /etc and restore it from the cpio archive into your home directory.</para>	
		<para>5. Use dd and ssh to put a backup of the master boot record on your neighbours computer.</para>	
		<para>6. (On the real computer) Create and mount an ISO image of the ubuntu cdrom.</para>	
		<para>7. Combine dd and gzip to create a 'ghost' image of one of your partitions on another partition.</para>	
	</section>
</chapter>
<chapter><title>Server performance monitoring</title>
	<para>Monitoring means obtaining information about the utilization of memory, CPU power, bandwidth and storage. You should start monitoring your system as soon as possible, to be able to create a <command>baseline</command>. Make sure that you get to know your system. <emphasis>Boys, just give your computer a girls name and get to know her.</emphasis> The baseline is important, it allows you to see a steady growth in CPU utilization or a steady decline in free disk space. It will allow you to plan for scaling up or scaling out.</para>
	<para>Let us look at some tools that go beyond <command>ps fax</command>, <command>df -h</command>, <command>lspci</command>, <command>fdisk -l</command> and <command>du -sh</command>.</para>
	<section><title>top</title>
		<para>To start monitoring, you can use <command>top</command>. This tool will monitor Memory, CPU and running processes. Top will automatically refresh. Inside top you can use many commands, like <command>k</command> to kill processes, or <command>t</command> and <command>m</command> to toggle displaying task and memory information, or the number <command>1</command> to have one line per cpu, or one summary line for all cpu's.</para>
		<screen>
top - 12:23:16 up 2 days,  4:01,  2 users,  load average: 0.00, 0.00, 0.00
Tasks:  61 total,   1 running,  60 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.3% us,  0.5% sy,  0.0% ni, 98.9% id,  0.2% wa,  0.0% hi,  0.0% si
Mem:    255972k total,   240952k used,    15020k free,    59024k buffers
Swap:   524280k total,      144k used,   524136k free,   112356k cached
	
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                     
 1 root      16   0  2816  560  480 S  0.0  0.2   0:00.91 init                                                        
 2 root      34  19     0    0    0 S  0.0  0.0   0:00.01 ksoftirqd/0                                                 
 3 root       5 -10     0    0    0 S  0.0  0.0   0:00.57 events/0                                                    
 4 root       5 -10     0    0    0 S  0.0  0.0   0:00.00 khelper                                                     
 5 root      15 -10     0    0    0 S  0.0  0.0   0:00.00 kacpid                                                      
16 root       5 -10     0    0    0 S  0.0  0.0   0:00.08 kblockd/0                                                   
26 root      15   0     0    0    0 S  0.0  0.0   0:02.86 pdflush
...
		</screen>
		<para>You can customize top to display the columns of your choice, or to display only the processes that you find interesting.</para>
		<screen>[paul@RHELv4u3 ~]$ top p 3456 p 8732 p 9654</screen>
	</section>
	<section><title>free</title>
		<para>The <command>free</command> command is common on Linux to monitor free memory. You can use free to display information every x seconds, but the output is not ideal.</para>
		<screen>
[paul@RHELv4u3 gen]$ free -om -s 10
total       used       free     shared    buffers     cached
Mem:           249        222         27          0         50        109
Swap:          511          0        511
		
total       used       free     shared    buffers     cached
Mem:           249        222         27          0         50        109
Swap:          511          0        511
		
[paul@RHELv4u3 gen]$ 
		</screen>
	</section>
	<section><title>watch</title>
		<para>It might be more interesting to combine free with the <command>watch</command> program. This program can also run commands with a delay, and can highlight changes (with the -d switch).</para>
		<screen>
[paul@RHELv4u3 ~]$ watch -d -n 3 free -om
...
Every 3.0s: free -om                             Sat Jan 27 12:13:03 2007

total       used       free     shared    buffers     cached
Mem:           249        230         19          0         56        109
Swap:          511          0        511
		</screen>
		<para>intro sysadmin ch2 3 4, en sysadmin deel VI</para>
	</section>
	<section><title>vmstat</title>
		<para>To monitor CPU, disk and memory statistics in one line there is <command>vmstat</command>. The screenshot below shows vmstat running every two seconds 100 times (or until the Ctrl-C). Below the r, you see the number of processes waiting for the CPU, sleeping processes go below b. Swap usage (swpd) stayed constant at 144 kilobytes, free memory dropped from 16.7MB to 12.9MB. See man vmstat for the rest</para>
		<screen>
[paul@RHELv4u3 ~]$ vmstat 2 100
procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----
r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
0  0    144  16708  58212 111612    0    0     3     4   75    62  0  1 99  0
0  0    144  16708  58212 111612    0    0     0     0  976    22  0  0 100  0
0  0    144  16708  58212 111612    0    0     0     0  958    14  0  1 99  0
1  0    144  16528  58212 111612    0    0     0    18 1432  7417  1 32 66  0
1  0    144  16468  58212 111612    0    0     0     0 2910 20048  4 95  1  0
1  0    144  16408  58212 111612    0    0     0     0 3210 19509  4 97  0  0
1  0    144  15568  58816 111612    0    0   300  1632 2423 10189  2 62  0 36
0  1    144  13648  60324 111612    0    0   754     0 1910  2843  1 27  0 72
0  0    144  12928  60948 111612    0    0   312   418 1346  1258  0 14 57 29
0  0    144  12928  60948 111612    0    0     0     0  977    19  0  0 100  0
0  0    144  12988  60948 111612    0    0     0     0  977    15  0  0 100  0
0  0    144  12988  60948 111612    0    0     0     0  978    18  0  0 100  0
		
[paul@RHELv4u3 ~]$
		</screen>
	</section>
	<section><title>iostat</title>
		<para>The <command>iostat</command> tool can display disk and cpu statistics. The -d switch below makes iostat only display disk information (500 times every two seconds). The first block displays statistics since the last reboot.</para>
		<screen>
[paul@RHELv4u3 ~]$ iostat -d 2 500
Linux 2.6.9-34.EL (RHELv4u3.localdomain)        01/27/2007
		
Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
hdc               0.00         0.01         0.00       1080          0
sda               0.52         5.07         7.78     941798    1445148
sda1              0.00         0.01         0.00        968          4
sda2              1.13         5.06         7.78     939862    1445144
dm-0              1.13         5.05         7.77     939034    1444856
dm-1              0.00         0.00         0.00        360        288
		
Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
hdc               0.00         0.00         0.00          0          0
sda               0.00         0.00         0.00          0          0
sda1              0.00         0.00         0.00          0          0
sda2              0.00         0.00         0.00          0          0
dm-0              0.00         0.00         0.00          0          0
dm-1              0.00         0.00         0.00          0          0
...
[paul@RHELv4u3 ~]$ 
		</screen>
		<para>You can have more statistics using <command>iostat -d -x</command>, or display only cpu statistics with <command>iostat -c</command>.</para>
		<screen>
[paul@RHELv4u3 ~]$ iostat -c 5 500
Linux 2.6.9-34.EL (RHELv4u3.localdomain)        01/27/2007
		
avg-cpu:  %user   %nice    %sys %iowait   %idle
0.31    0.02    0.52    0.23   98.92
		
avg-cpu:  %user   %nice    %sys %iowait   %idle
0.62    0.00   52.16   47.23    0.00
		
avg-cpu:  %user   %nice    %sys %iowait   %idle
2.92    0.00   36.95   60.13    0.00
		
avg-cpu:  %user   %nice    %sys %iowait   %idle
0.63    0.00   36.63   62.32    0.42
		
avg-cpu:  %user   %nice    %sys %iowait   %idle
0.00    0.00    0.20    0.20   99.59
		
	[paul@RHELv4u3 ~]$ 
		</screen>
	</section>
	<section><title>mpstat</title>
		<para>On multi-processor machines, <command>mpstat</command> can display statistics for all, or for a selected cpu.</para>
		<screen>
paul@laika:~$ mpstat -P ALL
Linux 2.6.20-3-generic (laika)  02/09/2007
		
08:20:02 PM  CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
08:20:02 PM  all    1.77    0.03    1.37    1.03    0.02    0.39    0.00   95.40   1304.91
08:20:02 PM    0    1.73    0.02    1.47    1.93    0.04    0.77    0.00   94.04   1304.91
08:20:02 PM    1    1.81    0.03    1.27    0.13    0.00    0.00    0.00   96.76      0.00
paul@laika:~$
		</screen>
	</section>
	<section><title>sadc and sar</title>
		<para>The <command>sadc</command> tool writes system utilization data to <command>/var/log/sa/sa??</command>, where ?? is replaced with the current day of the month. By default, cron runs the <command>sal</command> script every 10 minutes, the sal script runs sadc for one second. Just before midnight every day, cron runs the <command>sa2</command> script, which in turn invokes <command>sar</command>. The sar tool will read the daily data generated by sadc and put it in /var/log/sa/sar??. These <command>sar reports</command> contain a lot of statistics.</para>
		<para>You can also use sar to display a portion of the statistics that were gathered. Like this example for cpu statistics.</para>
		<screen>
[paul@RHELv4u3 sa]$ sar -u | head
Linux 2.6.9-34.EL (RHELv4u3.localdomain)        01/27/2007
		
12:00:01 AM       CPU     %user     %nice   %system   %iowait     %idle
12:10:01 AM       all      0.48      0.01      0.60      0.04     98.87
12:20:01 AM       all      0.49      0.01      0.60      0.06     98.84
12:30:01 AM       all      0.49      0.01      0.64      0.25     98.62
12:40:02 AM       all      0.44      0.01      0.62      0.07     98.86
12:50:01 AM       all      0.42      0.01      0.60      0.10     98.87
01:00:01 AM       all      0.47      0.01      0.65      0.08     98.80
01:10:01 AM       all      0.45      0.01      0.68      0.08     98.78
[paul@RHELv4u3 sa]$
		</screen>
		<para>There are other useful sar options, like <command>sar -I PROC</command> to display interrupt activity per interrupt and per CPU, or <command>sar -r</command> for memory related statistics. Check the manual page of sar for more.</para>
	</section>	
	<section><title>ntop</title>
		<para>The <command>ntop</command> tool is not present in default Red Hat installs. Once run, it will generate a very extensive analysis of network traffic in html on http://localhost:3000 .</para>
	</section>
	<section><title>iftop</title>
		<para>The iftop tool will display bandwidth by socket statistics for a specific network device. Not available on default Red Hat servers.</para>
		<screen>screenshot maken (to do)
		</screen>
	</section>
</chapter>
<chapter><title>Kernel Compilation</title>
	<section><title>preparing for a rescue boot</title>
		<para>Modifying the boot process of your system may render it unbootable. So before we start playing with the kernel, let's make sure we have a backup boot method. One way to boot an unbootable system is by using the official Red Hat Enterprise Linux CD 1. At the boot prompt of this CD, type <command>linux rescue</command>, and an attempt will be made to rescue your system. Another way is to create a bootable floppy for your system with the <command>mkbootdisk</command> command. That is, if you still can, since most kernels are too big to fit on a 1.44M floppy these days.</para>
		<screen>
root@RHELv4u4:~# mkbootdisk `uname -r`
Insert a disk in /dev/fd0. Any information on the disk will be lost.
Press &#060;Enter&#062; to continue or ^C to abort: 
cp: writing `/tmp/mkbootdisk.yU3889/vmlinuz': No space left on device
cp: writing `/tmp/mkbootdisk.yU3889/initrd.img': No space left on device
cat: write error: No space left on device
cat: write error: No space left on device
20+0 records in
20+0 records out
root@RHELv4u4:~# 
		</screen>
	</section>
	<section><title>booting the system</title>
		<para>There are a variety of boot loaders available, most common on intel architecture is <command>GRUB</command>, which is replacing <command>Lilo</command> in many places. When installing Linux on SPARC architecture, you can choose <command>Silo</command>, Itanium systems can use <command>ELILO</command>, IBM S/390 and zSeries use <command>z/IPL</command> and PowerPC architectures use <command>YABOOT</command> (which means Yet Another boot loader). We will focus on grub, the others work in a similar way.</para>
		<para>The grub configuration file is located in <command>/boot/grub/</command> and is now called <command>menu.lst</command> (used to be grub.conf).</para>
		<screen>
root@RHELv4u4:~# cat /boot/grub/menu.lst 
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/VolGroup00/LogVol00
#          initrd /initrd-version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title Red Hat Enterprise Linux AS (2.6.9-42.0.3.EL)
root (hd0,0)
kernel /vmlinuz-2.6.9-42.0.3.EL ro root=/dev/VolGroup00/LogVol00 rhgb quiet
initrd /initrd-2.6.9-42.0.3.EL.img
title Red Hat Enterprise Linux AS (2.6.9-42.EL)
root (hd0,0)
kernel /vmlinuz-2.6.9-42.EL ro root=/dev/VolGroup00/LogVol00 rhgb quiet
initrd /initrd-2.6.9-42.EL.img
root@RHELv4u4:~# 
		</screen>
		<para>At the bottom of the screenshot above, you can see two <command>stanzas</command> starting with the <command>title</command> directive. Once you compiled a kernel, to be able to select it from the boot menu, you'll have to add your own stanza. You can test adding your stanza by copying an existing kernel, and adding this to the <command>menu.lst</command> file. First, let's copy some files.</para>
		<screen>
root@RHELv4u4:/boot# ls -l
total 6897
-rw-r--r--  1 root root   50337 Sep 25 17:23 config-2.6.9-42.0.3.EL
-rw-r--r--  1 root root   50333 Jul 12  2006 config-2.6.9-42.EL
drwxr-xr-x  2 root root    1024 Nov  3 15:58 grub
-rw-r--r--  1 root root 1170657 Nov  3 15:58 initrd-2.6.9-42.0.3.EL.img
-rw-r--r--  1 root root 1170764 Nov  3 14:29 initrd-2.6.9-42.EL.img
drwx------  2 root root   12288 Nov  3 09:21 lost+found
-rw-r--r--  1 root root   23108 Aug  3  2005 message
-rw-r--r--  1 root root   21282 Aug  3  2005 message.ja
-rw-r--r--  1 root root  749489 Sep 25 17:23 System.map-2.6.9-42.0.3.EL
-rw-r--r--  1 root root  749462 Jul 12  2006 System.map-2.6.9-42.EL
-rw-r--r--  1 root root 1504432 Sep 25 17:23 vmlinuz-2.6.9-42.0.3.EL
-rw-r--r--  1 root root 1504146 Jul 12  2006 vmlinuz-2.6.9-42.EL
root@RHELv4u4:/boot# cp vmlinuz-2.6.9-42.0.3.EL vmlinuz-2.6.9-42.0.3.EL.paul
root@RHELv4u4:/boot# cp initrd-2.6.9-42.0.3.EL.img initrd-2.6.9-42.0.3.EL.paul.img 
root@RHELv4u4:/boot# cp System.map-2.6.9-42.0.3.EL System.map-2.6.9-42.0.3.EL.paul 
root@RHELv4u4:/boot# cp config-2.6.9-42.0.3.EL config-2.6.9-42.0.3.EL.paul
		</screen>
		<para>The <command>vmlinux</command> file is the compressed kernel.</para>
		<para>The kernel uses <command>initrd</command> (an initial RAM disk) at boot time. The initrd is mounted before the kernel loads, and can contain additional drivers and modules. It is a <command>compressed cpio archive</command>, so you can look at the contents in this way.</para>
		<screen>
root@RHELv4u4:/boot# mkdir /mnt/initrd
root@RHELv4u4:/boot# cp initrd-2.6.9-42.0.3.EL.img TMPinitrd.gz
root@RHELv4u4:/boot# gunzip TMPinitrd.gz 
root@RHELv4u4:/boot# file TMPinitrd 
TMPinitrd: ASCII cpio archive (SVR4 with no CRC)
root@RHELv4u4:/boot# cd /mnt/initrd/
root@RHELv4u4:/mnt/initrd# cpio -i &#124; /boot/TMPinitrd 
4985 blocks
root@RHELv4u4:/mnt/initrd# ls -l
total 76
drwxr-xr-x  2 root root 4096 Feb  5 08:36 bin
drwxr-xr-x  2 root root 4096 Feb  5 08:36 dev
drwxr-xr-x  4 root root 4096 Feb  5 08:36 etc
-rwxr-xr-x  1 root root 1607 Feb  5 08:36 init
drwxr-xr-x  2 root root 4096 Feb  5 08:36 lib
drwxr-xr-x  2 root root 4096 Feb  5 08:36 loopfs
drwxr-xr-x  2 root root 4096 Feb  5 08:36 proc
lrwxrwxrwx  1 root root    3 Feb  5 08:36 sbin -> bin
drwxr-xr-x  2 root root 4096 Feb  5 08:36 sys
drwxr-xr-x  2 root root 4096 Feb  5 08:36 sysroot
root@RHELv4u4:/mnt/initrd# 
		</screen>
		<para>The <command>System.map</command> contains the symbol table and changes with every kernel compile. The symbol table is also present in <command>/proc/kallsyms</command> (pre 2.6 kernels name this file /proc/ksyms). </para>
		<screen>
root@RHELv4u4:/boot# head System.map-`uname -r`
00000400 A __kernel_vsyscall
0000041a A SYSENTER_RETURN_OFFSET
00000420 A __kernel_sigreturn
00000440 A __kernel_rt_sigreturn
c0100000 A _text
c0100000 T startup_32
c01000c6 t checkCPUtype
c0100147 t is486
c010014e t is386
c010019f t L6
root@RHELv4u4:/boot# head /proc/kallsyms 
c0100228 t _stext
c0100228 t calibrate_delay_direct
c0100228 t stext
c0100337 t calibrate_delay
c01004db t rest_init
c0100580 t do_pre_smp_initcalls
c0100585 t run_init_process
c01005ac t init
c0100789 t early_param_test
c01007ad t early_setup_test
root@RHELv4u4:/boot#
		</screen>
		<para>The last file copied is the kernel configuration used for compilation. This file is not necessary in the /boot directory, but it is common practice to put a copy there. It allows you to recompile a kernel, starting from the same configuration as an existing working one. So we are now ready to create a new stanza, and reboot the machine with it.</para>
		<screen>
root@RHELv4u4:/boot/grub# vi menu.lst 
root@RHELv4u4:/boot/grub# tail menu.lst 
kernel /vmlinuz-2.6.9-42.0.3.EL ro root=/dev/VolGroup00/LogVol00 rhgb quiet
initrd /initrd-2.6.9-42.0.3.EL.img
title Red Hat Enterprise Linux AS (2.6.9-42.EL)
root (hd0,0)
kernel /vmlinuz-2.6.9-42.EL ro root=/dev/VolGroup00/LogVol00 rhgb quiet
initrd /initrd-2.6.9-42.EL.img
title Red Hat Enterprise Linux AS Paul (2.6.9-42.0.3.EL.paul)
root (hd0,0)
kernel /vmlinuz-2.6.9-42.0.3.EL.paul ro root=/dev/VolGroup00/LogVol00 rhgb quiet
initrd /initrd-2.6.9-42.0.3.EL.paul.img
root@RHELv4u4:/boot/grub# 
		</screen>
		<para>At the boot menu (after the reboot), you can now select your own stanza. The next step is to really create those four files ourselves.</para>
	</section>		
	<section><title>kernel module management</title>
		<para>The system must be configured to load the proper kernel module for each piece of hardware. Normally the <command>kudzu</command> program will detect and configure hardware on Red Hat Enterprise Linux, and might also put an alias for the hardware in <command>/etc/modprobe.conf</command>.</para>
		<section><title>lsmod</title>
			<para>To see a list of currently loaded modules, use <command>lsmod</command>. You see the name of each loaded module, the size, the use count, and the names of other modules using this one. The same information is present in <command>/proc/modules</command>.</para>
			<screen>
[root@RHELv4u3 ~]# lsmod
Module                  Size  Used by
iptable_filter          2753  0 
ip_tables              16705  1 iptable_filter
nls_utf8                2113  0 
parport_pc             24577  1 
lp                     12077  0 
parport                37129  2 parport_pc,lp
autofs4                24773  0 
i2c_dev                11329  0 
...
			</screen>
		</section>
		<section><title>modprobe</title>
			<para>The advantage of <command>modprobe</command> over <command>insmod</command> is that modprobe will load all necessary modules, whereas insmod requires manual loading of depedencies.</para>
			<screen>
[root@RHELv4u3 ~]# modprobe isdn
[root@RHELv4u3 ~]# lsmod | grep isdn
isdn                  133537  0 
slhc                    7233  1 isdn
[root@RHELv4u3 ~]# 
			</screen>
			<para>Same as insmod, the <command>rmmod</command> tool is rarely used anymore.</para>
			<screen>
[root@RHELv4u3 ~]# modprobe isdn
[root@RHELv4u3 ~]# rmmod slhc
ERROR: Module slhc is in use by isdn
[root@RHELv4u3 ~]# rmmod isdn
[root@RHELv4u3 ~]# rmmod slhc
[root@RHELv4u3 ~]# lsmod | grep isdn
[root@RHELv4u3 ~]# 
			</screen>
			<para>Contrary to rmmod, modprobe will remove unneeded modules.</para>
			<screen>
[root@RHELv4u3 ~]# modprobe isdn
[root@RHELv4u3 ~]# lsmod | grep isdn
isdn                  133537  0 
slhc                    7233  1 isdn
[root@RHELv4u3 ~]# modprobe -r isdn
[root@RHELv4u3 ~]# lsmod | grep isdn
[root@RHELv4u3 ~]# lsmod | grep slhc
[root@RHELv4u3 ~]# 
			</screen>
			<para>To force the loading of a module at boot (normally you will never have to do this manually), put the modprobe command in <command>/etc/rc.modules</command> (which is loaded before <command>/etc/rc.local</command>).</para>
			<screen>
[root@RHELv4u3 ~]# cat /etc/rc.modules
cat: /etc/rc.modules: No such file or directory
[root@RHELv4u3 ~]# echo modprobe isdn > /etc/rc.modules
[root@RHELv4u3 ~]# chmod +x /etc/rc.modules
[root@RHELv4u3 ~]# 
			</screen>
		</section>
	</section>
	<section><title>compiling a kernel</title>
		<section><title>vanilla</title>
			<para>To compile a kernel, you need to get the source code first. The vanilla kernel is downloadable from <command>ftp.kernel.org</command>. But getting this one to work perfectly with your Red Hat distribution will be tricky.</para>
		</section>
		<section><title>Red Hat Enterprise Linux 4 specific</title>
			<para>It will be safer to start with the Red Hat kernel source, which is located on the fourth source cdrom. The file is called <command>kernel-2.6.9-42.EL.src.rpm</command> for RHELv4u4.</para>
			<para>Issue the <command>rpm -i -vv kernel-2.6.9-42.EL.src.rpm</command> command to install this Red Hat package.</para>
			<para>issue <command>rpmbuild -bp -vv --target=i686 /usr/src/redhat/SPECS/kernel-2.6.spec</command>.  It will put a lot of files in <command>/usr/src/redhat/BUILD</command>.</para>
			<para>Now go into <command>/usr/src/redhat/BUILD/kernel-2.6.9/linux-2.6.9/</command> .</para>
		</section>			
		<section><title>Normal kernel compilation</title>
			<para>Now clean up the source from any previous installs with <command>make mrproper</command>. If this is your first after downloading the source code, then this is not needed.</para>
			<para>Now copy a working .config from /boot to our kernel directory.</para>
			<para>Now run the <command>make menuconfig</command> (or in GUI <command>make xconfig</command>). This tool allows you to select whether to compile stuff as a module (m), as part of the kernel (*), or not at all (smaller kernel size). If you remove to much, your kernel will not work.</para>
			<screen>screenshot make menuconfig maken !! (to do)</screen>
			<para>Next, change the extraversion in the <command>Makefile</command>, to give your compiled kernel a unique name.</para>
			<screen>
[root@RHELv4u3 2.6.9-34.EL-i686]# vi Makefile 
[root@RHELv4u3 2.6.9-34.EL-i686]# head -5 Makefile 
VERSION = 2
PATCHLEVEL = 6
SUBLEVEL = 9
EXTRAVERSION = -34.EL.paul
NAME=AC 1
[root@RHELv4u3 2.6.9-34.EL-i686]# 
			</screen>
			<para>Issue a <command>make clean</command> to prepare the kernel for compile. And then run <command>make bzImage</command>, sit back and relax while the kernel compiles. You can use <command>time make bzImage</command> to know how long it takes to compile, so next time you can go for a short walk (it took six minutes in vmware).</para>
			<screen>
[root@RHELv4u3 2.6.9-34.EL-i686]# clean
[root@RHELv4u3 2.6.9-34.EL-i686]# time make bzImage
			</screen>
			<para>You can already copy this image to /boot with <command>cp arch/i386/boot/bzImage /boot</command>.</para>
			<para>Now run <command>make modules</command> (took me 22 minutes) and <command>make modules install</command> (20 seconds). Compilation is now finished, don't forget to  create an additional stanza in grub.conf. It is common to copy your .config to /boot, this will help you in the next compile to start from a known good configuration. Also copy the System.map. You might also need <command>mkinitrd</command> when booting from SCSI.
			</para>
		</section>	
	</section>
	<section><title>Overview kernel compile</title>
		<para>An overview of the steps executed to compile the kernel (first attempt, no network connection but otherwise functioning kernel).</para>
		<screen>
mkdir kernelcompile
cd kernelcompile/
mv /home/paul/kernel-2.6.9-42.EL.src.rpm .
rpm -i -vv kernel-2.6.9-42.EL.src.rpm 
cd /usr/src/redhat/SPECS/
rpmbuild -bp -vv --target=i686 kernel-2.6.spec
cd ../BUILD/kernel-2.6.9/linux-2.6.9/
make mrproper
vi Makefile 
make menuconfig
time make bzImage
cp arch/i386/boot/bzImage /boot/vmlinuz-2.6.9-paul
time make modules
time make modules_install
ls -l /lib/modules/
cp .config /boot/config-2.6.9-paul
cp System.map /boot/System.map-2.6.9-paul
(mkinitrd /boot/initrd-2.6.9-paul.img 2.6.9-paul)
cp /boot/initrd-2.6.9-42.0.8.ELsmp.img /boot/initrd-2.6.9-paul.img
ll /boot
vi /boot/grub/menu.lst 
reboot
		</screen>
		<para>The second attempt...</para>
		<screen>
cd /usr/src/redhat/BUILD/kernel-2.6.9/linux-2.6.9/
make mrproper
uname -a
cp /boot/config-2.6.9-42.0.8.ELsmp ./.config
vi Makefile 
time make bzImage modules modules_install
cp System.map /boot/System.map-2.6.9-paul-2
cp arch/i386/boot/bzImage /boot/vmlinuz-2.6.9-paul-2
cp .config /boot/config-2.6.9-paul-2
mkinitrd /boot/initrd-2.6.9-paul-2.img 2.6.9-paul-2 
ll /boot
vi /boot/grub/menu.lst
		</screen>
		<para>...everything seems to work now.</para>
		<screen>
paul@laika:~$ ssh 192.168.1.44
paul@192.168.1.44's password: 
Last login: Thu Feb 15 18:29:48 2007 from 192.168.1.45
[paul@rhel4a ~]$ uname -r
2.6.9-paul-2
[paul@rhel4a ~]$
		</screen>
	</section>
	<section><title>Compiling one module</title>
		<para>A little C program that will be our module.</para>
		<screen>
[root@rhel4a kernel_module]# cat hello.c 
#include &#060;linux/module.h&#062;
#include &#060;section&#062;
			
int init_module(void)
{
	printk(KERN_INFO "Start Hello World...\n");
	return 0;
}
			
void cleanup_module(void)
{
	printk(KERN_INFO "End Hello World... \n");
}
		</screen>
		<para>The make file for this module.</para>
		<screen>
[root@rhel4a kernel_module]# cat Makefile 
obj-m += hello.o
all:
make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
		</screen>
		<para>These are the only two files needed.</para>
		<screen>
[root@rhel4a kernel_module]# ll
total 16
-rw-rw-r--  1 paul paul 250 Feb 15 19:14 hello.c
-rw-rw-r--  1 paul paul 153 Feb 15 19:15 Makefile
		</screen>
		<para>The running of the <command>make</command> command.</para>
		<screen>
[root@rhel4a kernel_module]# make
make -C /lib/modules/2.6.9-paul-2/build M=/home/paul/kernel_module modules
make[1]: Entering directory `/usr/src/redhat/BUILD/kernel-2.6.9/linux-2.6.9'
CC [M]  /home/paul/kernel_module/hello.o
Building modules, stage 2.
MODPOST
CC      /home/paul/kernel_module/hello.mod.o
LD [M]  /home/paul/kernel_module/hello.ko
make[1]: Leaving directory `/usr/src/redhat/BUILD/kernel-2.6.9/linux-2.6.9'
[root@rhel4a kernel_module]# 
		</screen>
		<para>Now we have more files.</para>
		<screen>
[root@rhel4a kernel_module]# ll
total 172
-rw-rw-r--  1 paul paul   250 Feb 15 19:14 hello.c
-rw-r--r--  1 root root 64475 Feb 15 19:15 hello.ko
-rw-r--r--  1 root root   632 Feb 15 19:15 hello.mod.c
-rw-r--r--  1 root root 37036 Feb 15 19:15 hello.mod.o
-rw-r--r--  1 root root 28396 Feb 15 19:15 hello.o
-rw-rw-r--  1 paul paul   153 Feb 15 19:15 Makefile
[root@rhel4a kernel_module]#
		</screen>
		<para>Use <command>modinfo</command> to verify that it is really a module.</para>
		<screen>
[root@rhel4a kernel_module]# modinfo hello.ko 
filename:       hello.ko
vermagic:       2.6.9-paul-2 SMP 686 REGPARM 4KSTACKS gcc-3.4
depends:        
[root@rhel4a kernel_module]#
		</screen>
		<para>Good, so now we can load our hello module.</para>
		<screen>
[root@rhel4a kernel_module]# lsmod | grep hello
[root@rhel4a kernel_module]# insmod ./hello.ko
[root@rhel4a kernel_module]# lsmod | grep hello
hello                   5504  0 
[root@rhel4a kernel_module]# tail -1 /var/log/messages 
Feb 15 19:16:07 rhel4a kernel: Start Hello World...
[root@rhel4a kernel_module]# rmmod hello
[root@rhel4a kernel_module]#
		</screen>
		<para>Finally <command>/var/log/messages</command> has a little surprise.</para>
		<screen>
[root@rhel4a kernel_module]# tail -2 /var/log/messages 
Feb 15 19:16:07 rhel4a kernel: Start Hello World...
Feb 15 19:16:35 rhel4a kernel: End Hello World... 
[root@rhel4a kernel_module]# 
		</screen>
	</section>
</chapter>
<chapter><title>CUPS</title>
	<section><title>About CUPS</title>
		<para>The standard for printing on Linux is CUPS or <command>Common Unix Printing Service</command>. CUPS is based on IPP, the <command>Internet Printing Protocol</command>. With <command>IPP</command> print servers and clients use the HTTP protocol to communicate. Drivers and howtos for all existing printers can be found on http://www.linux-foundation.org/en/OpenPrinting (the former linuxprinting.org website).</para>
	</section>
	<section><title>CUPS Administration</title>
		<para>You can use the web-based administration of cups for most tasks, just go to http://localhost:631 on the print server. The configuration will be stored in the <command>/etc/cups/</command> directory. After adding a printer with the web interface, the <command>/etc/cups/printers.conf</command> file is updated. In the rare case where you do not have a web browser available, you can use the <command>lpadmin</command> command to manage printers.</para>
		<screen>
		[root@RHELv4u3 ~]# cat /etc/cups/printers.conf
		# Printer configuration file for CUPS v1.1.22rc1
		# Written by cupsd on Thu 08 Feb 2007 11:05:52 PM CET
		&#060;DefaultPrinter HPLaserjet4Si&#062;
			Info Dit is de snelle printer met wit papier
			Location aan het raam
			DeviceURI socket://192.168.1.41:9100
			State Idle
			Accepting Yes
			JobSheets none none
			QuotaPeriod 0
			PageLimit 0
			KLimit 0
		&#060;/Printer&#062;
		[root@RHELv4u3 ~]# 
		</screen>
	</section>
	<section><title>CUPS Administration Access</title>
		<para>By default, cups web administration is limited in the <command>/etc/cups/cupsd.conf</command> file to the localhost. But you can easily add ip-addresses to the list of allowed hosts for administration of CUPS.</para>
		<screen>
&#060;Location /&#062;
Order Deny,Allow
Deny From All
Allow From 127.0.0.1
Allow From 10.10.10.77
Allow From 10.10.10.75
&#060;/Location&#062;
		</screen>
		<para>And make sure cups also listens on other ip-addresses besides 127.0.0.1</para>
		<screen>
[root@rhel4 ~]# grep -i listen /etc/cups/cupsd.conf | tail -1
Listen *:631
[root@rhel4 ~]#
		</screen>
	</section>
	<section><title>Command line tools for CUPS</title>
		<section><title>lpq</title>
			<para>You can use <command>lpq</command> to look at the queue.</para>
			<screen>
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready
no entries
[root@RHELv4u3 ~]# 
			</screen>
		</section>
		<section><title>lpstat and lpc</title>
			<para>You can see the status of printers with <command>lpstat</command> and <command>lpc</command>.</para>
			<screen>
[root@RHELv4u3 ~]# lpstat -a
HPLaserjet4Si accepting requests since Jan 01 00:00
[root@RHELv4u3 ~]# 
[root@RHELv4u3 ~]# lpc status
HPLaserjet4Si:
printer is on device 'socket' speed -1
queuing is enabled
printing is enabled
2 entries
daemon present
[root@RHELv4u3 ~]# 
			</screen>
		</section>
		<section><title>lpr</title>
			<para>You can now use <command>lp</command> and <command>lpr</command> to print documents to your printer.</para>
			<screen>
[root@RHELv4u3 ~]# lp /etc/passwd
request id is HPLaserjet4Si-1 (1 file(s))
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    1       passwd                          3072 bytes
[root@RHELv4u3 ~]# lpr /etc/hosts
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    1       passwd                          3072 bytes
1st     root    2       hosts                           1024 bytes
[root@RHELv4u3 ~]#
			</screen>
		</section>
		<section><title>lprm and cancel</title>
			<para>You can use <command>lprm</command> to remove print jobs from the queue. You can remove jobs by job number. When you are root, you can use <command>lprm paul</command>, to remove all print jobs from user paul from the system.</para>
			<screen>
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    1       passwd                          3072 bytes
1st     root    2       hosts                           1024 bytes
[root@RHELv4u3 ~]# lprm 2
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    1       passwd                          3072 bytes
[root@RHELv4u3 ~]#
			</screen>
			<para>You can also use <command>cancel</command> for this.</para>
		<screen>
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    1       passwd                          3072 bytes
[root@RHELv4u3 ~]# cancel 1
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready
no entries
[root@RHELv4u3 ~]#
			</screen>
		</section>
		<section><title>lpoptions</title>
			<para>You can use <command>lpoptions</command> to display or set options like page size or color mode for the printer. Just typing <command>lpoptions -l</command> will list all the options for the (default) printer.</para>
			<screen>
[root@RHELv4u3 ~]# lpoptions -l
ColorModel/Output Mode: *Gray Black
Resolution/Resolution: 150dpi *300dpi 600dpi
PageSize/Media Size: *Letter Legal Executive Statement A4 C5 C6 DL COM10 Monarch
InputSlot/Media Source: *Standard Manual MultiPurpose Upper Lower LargeCapacity Auto
PageRegion/PageRegion: Letter Legal Executive Statement A4 C5 C6 DL COM10 Monarch
...
			</screen>
			<para>You can override default options explicitly with the <command>lp -o</command> command. In the screenshot below a color document is printed in grayscale on a color printer.</para>
			<screen>
[paul@laika ~]# lp -o"ColorModel=Gray" plan.pdf
			</screen>
		</section>
		<section><title>lpmove</title>
			<para>Jobs can be move to another printer with the <command>lpmove</command> command.</para>
			<screen>
[root@RHELv4u3 ~]# lpq
HPLaserjet4Si is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    3       hosts                           1024 bytes
1st     root    5       passwd                          3072 bytes
2nd     root    6       passwd                          3072 bytes
3rd     root    7       passwd                          3072 bytes
[root@RHELv4u3 ~]# lpmove 6 HPDJ500
[root@RHELv4u3 ~]# lpq -P HPDJ500
HPDJ500 is ready and printing
Rank    Owner   Job     File(s)                         Total Size
active  root    6       passwd                          3072 bytes
[root@RHELv4u3 ~]#
			</screen>
		</section>
		<section><title>enable and disable</title>
			<para>Printers can be stopped and started with the <command>disable</command> and <command>enable</command> commands. Be careful in /bin/bash, since <command>enable</command> is also a bash built-in command, you have to give the full path <command>/usr/bin/enable</command> to use the CUPS enable command. You can access the man page of <command>CUPS enable</command> with <command>man 8 enable</command>.</para>
			<screen>
[root@RHELv4u3 ~]# lpq -P HPDJ500
HPDJ500 is ready
no entries
[root@RHELv4u3 ~]# disable HPDJ500
[root@RHELv4u3 ~]# lpq -P HPDJ500
HPDJ500 is not ready
no entries
[root@RHELv4u3 ~]# /usr/bin/enable HPDJ500
[root@RHELv4u3 ~]# lpq -P HPDJ500
HPDJ500 is ready
no entries
[root@RHELv4u3 ~]# 
			</screen>
		</section>
		<section><title>accept and reject</title>
			<para>Printers can be prevented from accepting jobs with the <command>reject</command> command. Printers will start accepting jobs again after the <command>accept</command> command.</para>
			<screen>
[root@RHELv4u3 ~]# lpstat -a
HPDJ500 accepting requests since Jan 01 00:00
HPLaserjet4Si accepting requests since Jan 01 00:00
[root@RHELv4u3 ~]# reject HPDJ500
[root@RHELv4u3 ~]# lpstat -a
HPDJ500 not accepting requests since Jan 01 00:00 -
Rejecting Jobs
HPLaserjet4Si accepting requests since Jan 01 00:00
[root@RHELv4u3 ~]# accept HPDJ500
[root@RHELv4u3 ~]# lpstat -a
HPDJ500 accepting requests since Jan 01 00:00
HPLaserjet4Si accepting requests since Jan 01 00:00
[root@RHELv4u3 ~]# 
			</screen>
		</section>
	</section>	
</chapter>
<chapter><title>TCP/IP</title>
<section><title>Overview of tcp/ip v4</title>
	<para>The unicast <command>Internet Protocol</command> is one of the oldest network protocols, commonly used today for LAN and WAN networks. Every <command>host</command> gets a unique 32-bit <command>ip-address</command>, this is either static or received from a <command>DHCP</command> server. Internet networks contain several <command>subnets</command>. Those subnets used to be <command>classful</command> (A,B,C,D or E), but this wasted a lot of address space. Today we work with <command>CIDR</command> notation to determine <command>network id</command> and <command>host id</command>.</para>
	<para>In a couple of years we will all be using IPv6! <emphasis>At least, that is what people say since 1995...</emphasis></para>
</section>
<section><title>Internet and routers</title>
	<para>The internet is a collection of <command>routers</command> that act as gateways between different <command>segments</command>. Routers use their <command>routing table</command> to determine the route of tcp/ip <command>packets</command>. Routers are <command>layer 3</command> devices, layer 2 contains <command>bridges</command> and <command>switches</command>, layer 1 is cabling with <command>repeaters</command> and <command>hubs</command>. Layer 2 devices know your 48-bit unique in the world <command>MAC</command> address.</para>
</section>
<section><title>many protocols</title>
	<para>For reliable connections, you use <command>tcp</command>, whereas <command>udp</command> is connectionless but faster. The <command>icmp</command> error messages are used by <command>ping</command>, multicast groups are managed by <command>igmp</command> and the ip to mac resolution is done by the <command>broadcast</command> protocol <command>arp</command>.</para>
	<para>These protocols are visible in the protocol field of the ip header, and are listed in the <command>/etc/protocols</command> file.</para>
	<screen>
paul@laika:~$ grep tcp /etc/protocols 
tcp     6       TCP             # transmission control protocol
paul@laika:~$
	</screen>
	<para>Every host receives a <command>hostname</command>, usually placed in a <command>DNS name space</command> forming the <command>FQDN</command> or Fully Qualified Domain Name. Common application level protocols like SMTP, HTTP, SSH, telnet and FTP have fixed <command>port numbers</command>.</para>
	<para>To find a port number, look in <command>/etc/services</command>.</para>
	<screen>
paul@laika:~$ grep tftp /etc/services
tftp            69/udp
paul@laika:~$
	</screen>
</section>
<section><title>Practice TCP/IP</title>
	<para>1. Which ports are used by http, pop3, ssh, telnet, nntp and ftp ?</para>
	<para>2. Explain why e-mail and websites are sent over tcp, whereas internet streaming radio and live broadcasts are using udp.</para>
</section>
</chapter>
<chapter><title>IP address configuration</title>
	<section><title>to GUI or not to GUI</title>
		<para>If you can, setup your tcp/ip configuration at install time, otherwise use the graphical tool from your distribution. In the case of RHEL, this is the <command>Network Administration Tool</command>, Novell and OpenSUSE users can use YaST. Avoid mixed use of the GUI tool with command line or direct editing of network configuration files. You should choose only one method to manage these files, because many GUI tools will override your manually edited settings. Also, on Red Hat Servers avoid editing the files in <command>/etc/sysconfig/networking</command> manually!</para>
		<para>Now that we settled this, let's take a look at the files and script that configure your network.</para>
	</section>
	<section><title>/sbin/ifconfig</title>
		<para>You can use the <command>ifconfig</command> command to see the tcp/ip configuration of a network interface. The first ethernet network card on linux is eth0.</para>
		<screen>
[root@RHEL4b ~]# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:3B:15:80  
          inet addr:192.168.1.191  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe3b:1580/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:84 errors:0 dropped:0 overruns:0 frame:0
          TX packets:80 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:9216 (9.0 KiB)  TX bytes:8895 (8.6 KiB)
          Interrupt:185 Base address:0x1400 

[root@RHEL4b ~]#
		</screen>
		<para>You can also disable a network interface with <command>ifconfig eth0 down</command>, or enable it with <command>ifconfig eth0 up</command>.</para>
		<para>Every user has access to /sbin/ifconfig, providing the path is set. Normal users cannot use it to disable or enable interfaces, or set the ip address.</para>
		<screen>
[root@RHEL4b ~]# ifconfig eth0 192.168.1.199
[root@RHEL4b ~]#
		</screen>
		<para>The ip address change will be valid until the next change, or until reboot. You can also supply the <command>subnet mask</command> with ifconfig.</para>
		<screen>
root@laika:~# ifconfig eth0 192.168.1.40 netmask 255.255.255.0
root@laika:~#
		</screen>
		<para>Careful, if you try this via an ssh connection, then you might lose your ssh connection.</para>
	</section>
	
	<section><title>/etc/init.d/network(ing)</title>
		<para>If you have a problem with network interfaces, you can try to restart the network init script, as shown here on Ubuntu 7.04. The script stops and starts the interfaces, and renews an ip configuration with the DHCP server.</para>
		<screen>
root@laika:~# /etc/init.d/networking restart
 * Reconfiguring network interfaces...
There is already a pid file /var/run/dhclient.eth0.pid with pid 14570
killed old client process, removed PID file
Internet Systems Consortium DHCP Client V3.0.4
Copyright 2004-2006 Internet Systems Consortium.
All rights reserved.
For info, please visit http://www.isc.org/sw/dhcp/

Listening on LPF/eth0/00:90:f5:4e:ae:17
Sending on   LPF/eth0/00:90:f5:4e:ae:17
Sending on   Socket/fallback
DHCPRELEASE on eth0 to 192.168.1.1 port 67
There is already a pid file /var/run/dhclient.eth0.pid with pid 134993416
Internet Systems Consortium DHCP Client V3.0.4
Copyright 2004-2006 Internet Systems Consortium.
All rights reserved.
For info, please visit http://www.isc.org/sw/dhcp/

Listening on LPF/eth0/00:90:f5:4e:ae:17
Sending on   LPF/eth0/00:90:f5:4e:ae:17
Sending on   Socket/fallback
DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 5
DHCPOFFER from 192.168.1.1
DHCPREQUEST on eth0 to 255.255.255.255 port 67
DHCPACK from 192.168.1.1
bound to 192.168.1.40 -- renewal in 249143 seconds.
root@laika:~# 
		</screen>
	</section>	
	<section><title>/etc/sysconfig</title>
		<para>Red Hat derived Linux systems store their network configuration files in the <command>/etc/sysconfig/</command> directory. Debian derived systems do not have this directory.</para>
		<section><title>/etc/sysconfig/network</title>
			<para>Routing and host information for all network interfaces is specified in the <command>/etc/sysconfig/network</command> file. Below an example, setting 192.168.1.1 as the router (default gateway), and leaving the default hostname of localhost.localdomain. Common options not shown in this screenshot are <command>GATEWAYDEV</command> to set one of your network cards as the gateway device, and <command>NISDOMAIN</command> to specify the NIS domain name. </para>
			<screen>
paul@RHELv4u2:~$ cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=localhost.localdomain
GATEWAY=192.168.1.1
			</screen>
			<para>The same file, but here the hostname of the machine is not set to the default as above.</para>
			<screen>
[paul@RHEL4b ~]$ cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=RHEL4b
[paul@RHEL4b ~]$ 
			</screen>
		</section>
		<section><title>/etc/sysconfig/network-scripts</title>
			<para>For every network card in your computer, you should have an interface configuration file named <command>/etc/sysconfig/network-scripts/ifcfg-$IFNAME</command>. Be careful when editing these files, your edits will work, until you start the <command>system-config-network</command> (might soon be renamed to redhat-config-network) tool. This tool can and will overwrite your manual edits.</para>
			<para>The first ethernet NIC will get <command>ifcfg-eth0</command>, the next one ifcfg-eth1 and so on. Below is an example.</para>
			<screen>
paul@RHELv4u2:~$ cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
BOOTPROTO=static
BROADCAST=192.168.1.255
HWADDR=00:0C:29:5A:86:D7
IPADDR=192.168.1.222
NETMASK=255.255.255.0
NETWORK=192.168.1.0
ONBOOT=yes
TYPE=Ethernet
			</screen>
			<para>When the second nic is configured for dhcp, then this is the ifcfg-eth1. </para>
			<screen>
paul@RHELv4u2:~$ cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth1
BOOTPROTO=dhcp
HWADDR=00:0C:29:6A:34:D8
ONBOOT=yes
TYPE=Ethernet
			</screen>
			<para>Besides <command>dhcp</command> and <command>bootp</command> the BOOTPROTO variable can be <command>static</command> or <command>none</command>, both meaning there should be no protocol used at boottime to set the interface values. The BROADCAST variable is no longer needed, it will be calculated.</para>
			<para>The HWADDR can be used to make sure that the nic's get the correct name when multiple nic's are present in the computer. It can not be used to set the MAC address of a nic. For this, you need to specify the MACADDR variable. Do not use HWADDR and MACADDR in the same ifcfg file.</para>
		</section>
	</section>
	<section><title>/sbin/ifup and /sbin/ifdown</title>
		<para>The <command>ifup</command> and <command>ifdown</command> commands take an interface as argument and bring it up or down. The screenshot below deactivates the eth0 network interface.</para>
		<screen>
root@laika:~# ifdown eth0
There is already a pid file /var/run/dhclient.eth0.pid with pid 14925
killed old client process, removed PID file
Internet Systems Consortium DHCP Client V3.0.4
Copyright 2004-2006 Internet Systems Consortium.
All rights reserved.
For info, please visit http://www.isc.org/sw/dhcp/

Listening on LPF/eth0/00:90:f5:4e:ae:17
Sending on   LPF/eth0/00:90:f5:4e:ae:17
Sending on   Socket/fallback
DHCPRELEASE on eth0 to 192.168.1.1 port 67
		</screen>
		<para>On debian derived systems, these commands will look at <command>/etc/network/interfaces</command>, whereas on Red Hat derived systems they will look at /etc/sysconfig/network-scripts/ifcfg- files. In the screenshot below ifup is used to bring up the eth0 interface. Because the /etc/network/interfaces file says eth0 uses DHCP, the ifup tool will (try to) start the dhclient daemon.</para>
		<screen>
root@laika:~# ifup eth0
There is already a pid file /var/run/dhclient.eth0.pid with pid 134993416
Internet Systems Consortium DHCP Client V3.0.4
Copyright 2004-2006 Internet Systems Consortium.
All rights reserved.
For info, please visit http://www.isc.org/sw/dhcp/

Listening on LPF/eth0/00:90:f5:4e:ae:17
Sending on   LPF/eth0/00:90:f5:4e:ae:17
Sending on   Socket/fallback
DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 8
DHCPOFFER from 192.168.1.1
DHCPREQUEST on eth0 to 255.255.255.255 port 67
DHCPACK from 192.168.1.1
bound to 192.168.1.40 -- renewal in 231552 seconds.
root@laika:~#
		</screen>
	</section>
	<section><title>/sbin/dhclient</title>
		<para>Home and client Linux desktops often have <command>dhclient</command> running. This is a daemon that enables a network interface to lease an ip configuration from a DHCP server. When your adapter is configured for DHCP or BOOTP, then /sbin/ifup will start the dhclient daemon.</para>
	</section>
	<section><title>/sbin/route</title>
		<para>You can see the computer's local routing table with the <command>route</command> command (and also with <command>netstat -r</command> ).</para>
		<screen>
root@RHEL4b ~]# netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
192.168.1.0     *               255.255.255.0   U         0 0          0 eth0
[root@RHEL4b ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
[root@RHEL4b ~]# 
		</screen>
		<para>It appears this computer does not have a <command>gateway</command> configured, so we use <command>route add default gw</command> to add a <command>default gateway</command>.</para>
		<screen>
[root@RHEL4b ~]# route add default gw 192.168.1.1
[root@RHEL4b ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
default         192.168.1.1     0.0.0.0         UG    0      0        0 eth0
[root@RHEL4b ~]# 
		</screen>
	</section>
	<section><title>arp</title>
		<para>Mac to IP resolution is handled by the <command>arp</command> protocol. The arp table can be displayed with the arp tool.</para>
		<screen>
root@barry:~# arp -a
? (192.168.1.191) at 00:0C:29:3B:15:80 [ether] on eth1
agapi (192.168.1.73) at 00:03:BA:09:7F:D2 [ether] on eth1
anya (192.168.1.1) at 00:12:01:E2:87:FB [ether] on eth1
faith (192.168.1.41) at 00:0E:7F:41:0D:EB [ether] on eth1
kiss (192.168.1.49) at 00:D0:E0:91:79:95 [ether] on eth1
laika (192.168.1.40) at 00:90:F5:4E:AE:17 [ether] on eth1
pasha (192.168.1.71) at 00:03:BA:02:C3:82 [ether] on eth1
shaka (192.168.1.72) at 00:03:BA:09:7C:F9 [ether] on eth1
root@barry:~# 	
		</screen>
		<para><emphasis>Anya is a Cisco Firewall, Faith is an HP Color printer, Kiss is a Kiss DP600, laika is a Clevo laptop and Agapi, Shaka and Pasha are SPARC servers. The question mark is a Red Hat Enterprise Linux server running in vmware.</emphasis></para>
	</section>
	<section><title>ping</title>
		<para>If you can ping to another host, then ip is configured.</para>
		<screen>
[root@RHEL4b ~]# ping 192.168.1.5
PING 192.168.1.5 (192.168.1.5) 56(84) bytes of data.
64 bytes from 192.168.1.5: icmp_seq=0 ttl=64 time=1004 ms
64 bytes from 192.168.1.5: icmp_seq=1 ttl=64 time=1.19 ms
64 bytes from 192.168.1.5: icmp_seq=2 ttl=64 time=0.494 ms
64 bytes from 192.168.1.5: icmp_seq=3 ttl=64 time=0.419 ms

--- 192.168.1.5 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3009ms
rtt min/avg/max/mdev = 0.419/251.574/1004.186/434.520 ms, pipe 2
[root@RHEL4b ~]#		</screen>
	</section>
	<section><title>Practice IP Configuration</title>
		<para>1. Use ifconfig to list all your network interfaces and their ip-addresses. Write down your ip-address and subnet mask.</para>
		<para>2. Use the GUI tool of your distro to set a fix ip address (use the same address as the one you got from dhcp). Verify with ifconfig and ping to a neighbour that it works. Also look at the configuration files in /etc/network or /etc/sysconfig to see how the GUI tool sets a fixed address.</para>
		<para>3. Use the GUI tool to enable dhcp again (and verify the changes in the config files).</para>
		<para>4. Use ifdown or ifconfig to disable your eth0 network card.</para>
		<para>5. Restart networking to enable your network card again.</para>
		<para>6. Is the dhclient daemon running ?</para>
		<para>7. Verify that you have a default gateway.</para>	
		<para>8. Ping the default gateway, then look at the MAC address of the default gateway.</para>	
	</section>
</chapter>

<chapter><title>Name Resolution</title>
	<section><title>/etc/hosts</title>
		<para>Let's start with the <command>/etc/hosts</command> file. This file contains a static table to link ip-addresses to hostnames. Below is the default /etc/hosts file on Red Hat Enterprise Linux.</para>
		<screen>
paul@RHELv4u2:~$ cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
paul@RHELv4u2:~$ 
		</screen>
		<para>The message inside the hosts file is clear, do not remove the loopback address from /etc/hosts. But you are allowed to add some entries to the hosts file. One easy way to add a name to ip relation is using the <command>echo</command> command.</para>
		<screen>
root@RHELv4u4:~# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
root@RHELv4u4:~# echo 192.168.1.200 server1 >> /etc/hosts
root@RHELv4u4:~# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
192.168.1.200 server1
root@RHELv4u4:~# 
		</screen>
		<para>In small networks, the hosts file can be used to name servers. Like this example shows.</para>
		<screen>
paul@laika:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       laika	
# servers
192.168.1.71     pasha
192.168.1.72     shaka
192.168.1.5     barry
# appliances
192.168.1.41    faith
192.168.1.1     anya
10.0.0.138      xander
# virtual machines
192.168.1.103   Sol9a
192.168.1.103   Sol9b
		</screen>
	</section>
	<section><title>/etc/resolv.conf</title>
		<para>In larger networks, it is best to set up DNS instead of relying on the hosts file. Your computer can locate its DNS server using the <command>/etc/resolv.conf</command> file. </para>
		<screen>
paul@RHELv4u2:~$ cat /etc/resolv.conf 
nameserver 10.0.0.138
		</screen>
		<para>Big networks should use <command>Domain Name System</command> or <command>DNS</command> instead of the hosts file. But what happens when a hostname exists in /etc/hosts and in the DNS database ?</para>
	</section>
	<section><title>/etc/nsswitch.conf</title>
		<para>The <command>Name Service Switch</command> file <command>nsswitch.conf</command> can decide on the order of things to process. One of those is the order between the /etc/hosts file and DNS. The following screenshot shows the relevant part of nsswitch.conf. Setting dns before files will give dns priority over the hosts file.</para>
		<screen>
root@RHELv4u4:~# grep host /etc/nsswitch.conf 
#hosts:     db files ldap nis dns
hosts:      files dns
		</screen>
	</section>
	<section><title>Setting the hostname</title>
		<para>You can use the <command>hostname</command> tool to display or to set the machines hostname. The new hostname then stays valid until the next reboot.</para>
		<screen>
root@RHELv4u2:~# hostname
localhost.localdomain
root@RHELv4u2:~# hostname Borg
root@RHELv4u2:~# hostname
Borg
root@RHELv4u2:~# 
		</screen>
		<para>To change a machines hostname permanently, adjust the HOSTNAME directive in the /etc/sysconfig/network or /etc/network/interfaces file. It is a good idea to also put the hostname in <command>/etc/HOSTNAME</command> and <command>/etc/hosts</command> since applications sometimes expect it to be there. Changing the hostname requires a restart of the network services. <emphasis>This screenshot was taken via ssh, there is no guarantee that your ssh session will always survive a restart of network services.</emphasis></para>
		<screen>
root@RHELv4u4:~# vi /etc/sysconfig/network
root@RHELv4u4:~# echo RHELv4u4 > /etc/HOSTNAME
root@RHELv4u4:~# hostname
localhost.localdomain
root@RHELv4u4:~# service network restart
Shutting down interface eth0:                              [  OK  ]
Shutting down loopback interface:                          [  OK  ]
Setting network parameters:                                [  OK  ]
Bringing up loopback interface:                            [  OK  ]
Bringing up interface eth0:                                [  OK  ]
root@RHELv4u4:~# hostname
RHELv4u4.localdomain
root@RHELv4u4:~# 
		</screen>
		<para>Below an example of a properly configured hostname</para>
		<screen>
paul@RHELv4u2:~$ cat /etc/HOSTNAME 
RHELv4u2
paul@RHELv4u2:~$ cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
192.168.1.222           RHELv4u2 RHELv4u2.localdomain
paul@RHELv4u2:~$ cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=RHELv4u2.localdomain
paul@RHELv4u2:~$ 
		</screen>
	</section>
	<section><title>Practice hostname resolution</title>
		<para>1. Display your hostname, write it down here.</para>
		<para>2. Use echo or vi to add an entry for Antwerp (10.5.6.7) in the hosts file. Ping Antwerp.</para>
		<para>3. Change your hostname with the hostname command. Does it work ? How long will this hostname be valid ?</para>
		<para>4. Use the GUI tool to change your hostname. Verify what the GUI tool did in /etc/hosts.</para>
		<para>5. Add an entry for your neighbour's computer in your /etc/hosts file. Ping your neighbour using this name. Do you need to put the real hostname of your neighbour in your /etc/hosts ?</para>	
		<para>6. Is there a name server listed in /etc/resolv.conf ? Test that it workd by pinging google.com. You can also use the nslookup or dig commands.</para>	
		<para>7. Add an entry for google.com in /etc/hosts. Does it take priority to the name server ? Give the name server priority to the /etc/hosts file in /etc/nsswitch.conf.</para>	
	</section>
</chapter>

<chapter><title>OpenSSH</title>
	<section><title>Secure Shell</title>
		<para>Avoid using <command>telnet</command>, <command>rlogin</command> and <command>rsh</command> to remotely connect to your servers. These older protocols do not encrypt the login session, which means your user id and password can be sniffed by tools like <command>ethereal</command> aka wireshark. To securely connect to your servers, use <command>OpenSSH</command>. An ssh connection always starts with a cryptographic handshake, followed by encryption of the transport layer using a symmetric cypher. Then authentication takes place (using user id/password or public/private keys) and communication can take place over the encrypted connection. In other words, the tunnel is encrypted before you start typing anything.</para>
		<para>The OpenSSH package is maintained by the <command>OpenBSD</command> people and is distributed with a lot of operating systems (it may even be the most popular package in the world). Below sample use of <command>ssh</command> to connect from one server (RHELv4u2) to another one (RHELv4u4). </para>
		<screen>
paul@RHELv4u2:~$ ssh 192.168.1.220
The authenticity of host '192.168.1.220 (192.168.1.220)' can't be established.
RSA key fingerprint is c4:3c:52:e6:d8:8b:ce:17:8b:c9:78:5a:f3:51:06:4f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.1.220' (RSA) to the list of known hosts.
paul@192.168.1.220's password: 
Last login: Sun Jan 21 07:16:26 2007 from 192.168.1.40
paul@RHELv4u4:~$ 
		</screen>
		<para>The second time ssh remembers the connection. It added an entry to the ~/.ssh/known_hosts file.</para>
		<screen>
paul@RHELv4u2:~$ ssh 192.168.1.220
paul@192.168.1.220's password: 
Last login: Sun Jan 21 08:49:19 2007 from 192.168.1.222
paul@RHELv4u4:~$
		</screen>
	</section>
	<section><title>X forwarding via SSH</title>
		<para> The <command>ssh protocol</command> will remember the servers it connected to (and warn you in case something suspicious happened), and will use strong 128-bit encryption. Another popular feature of ssh is called <command>X11 forwarding</command> and is implemented with <command>ssh -X</command>.</para>
		<para>Below an example of X11 forwarding: user paul logs in as user greet on her computer to start the graphical application mozilla-thunderbird. Although the application will run on the remote computer from greet, it will be displayed on the screen attached locally to paul's computer.</para>
		<screen>
paul@laika:~/PDF$ ssh -X greet@greet.dyndns.org -p 55555
Warning: Permanently added the RSA host key for IP address '81.240.174.161' to the list of known hosts.
Password: 
Linux raika 2.6.8-2-686 #1 Tue Aug 16 13:22:48 UTC 2005 i686 GNU/Linux
				
Last login: Thu Jan 18 12:35:56 2007
greet@raika:~$ ps fax | grep thun
greet@raika:~$ mozilla-thunderbird &#038;
[1] 30336
		</screen>
	</section>
	<section><title>SSH Protocol versions</title>
		<para>The ssh protocol has two versions (1 and 2). Avoid using version 1 anywhere, since it contains some known vulnerabilities. You can control the protocol version via <command>/etc/ssh/ssh_config</command> for the client side and <command>/etc/ssh/sshd_config</command> for the openssh-server daemon.</para>
		<screen>
root@laika:/etc/ssh# grep Protocol ssh_config 
#   Protocol 2,1
root@laika:/etc/ssh# grep Protocol sshd_config 
Protocol 2
root@laika:/etc/ssh# 
		</screen>
		<para>Configuration of ssh is done in the <command>/etc/ssh</command> directory and is pretty straightforward.</para>
	</section>
	<section><title>Passwordless ssh</title>
		<para>To set up passwordless ssh authentication through public/private keys, use <command>ssh-keygen</command> to generate a key pair without a passphrase, and then copy your public key to the destination server.</para>
		<screen>
ssh-keygen -t rsa
scp .ssh/id_rsa.pub otheruser@192.168.1.105:~/.ssh/authorized_keys
		</screen>
		<para>You can now use ssh to connect passwordless to another computer. In combination with ssh's capability to execute commands on the remote host, this can be useful in pipes across different machines.</para>
		<screen>
paul@RHELv4u2:~$ ssh 192.168.1.220 "ls -l"
total 8
drwxr-xr-x  2 paul paul 4096 Jan 16 12:22 Desktop
paul@RHELv4u2:~$ 
		</screen>
	</section>
	<section><title>Troubleshooting ssh</title>
		<para>Use <command>ssh -v</command> to get debug information about the ssh connection attempt.</para>
		<screen>
paul@laika:~$ ssh -v bert@192.168.1.192
OpenSSH_4.3p2 Debian-8ubuntu1, OpenSSL 0.9.8c 05 Sep 2006
debug1: Reading configuration data /home/paul/.ssh/config
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: Applying options for *
debug1: Connecting to 192.168.1.192 [192.168.1.192] port 22.
debug1: Connection established.
debug1: identity file /home/paul/.ssh/identity type -1
debug1: identity file /home/paul/.ssh/id_rsa type 1
debug1: identity file /home/paul/.ssh/id_dsa type -1
debug1: Remote protocol version 1.99, remote software version OpenSSH_3.9p1
debug1: match: OpenSSH_3.9p1 pat OpenSSH_3.*
debug1: Enabling compatibility mode for protocol 2.0
...
		</screen>
	</section>
	<section><title>Practice SSH</title>
		<para>1. Create a user for your neighbour, then test ssh to your neighbour (by ip-address or by hostname). (You might need to install the openssh-server with aptitude.)</para>
		<para>2. Create a bookmark in Firefox, then close your firefox! Use ssh -X to run firefox on your screen, but on your neighbour's computer. Do you see your neighbour's bookmark ?</para>
		<para>3. Verify in the ssh configuration files that only protocol version 2 is allowed.</para>
		<para>4. Use ssh-keygen to create a keypait without passphrase. Setup passwordless ssh between you and your neighbour. (or between the ubuntu and the Red Hat)</para>
	</section>
</chapter>

<chapter><title>xinetd and inetd</title>
	<section><title>inetd or xinetd</title>
		<para>First veroify whether your computer is running inetd or xinetd. This Debian 4.0 Etch is running inetd.</para>
		<screen>
root@barry:~# ps fax | grep inet
 3870 ?        Ss     0:00 /usr/sbin/inetd
		</screen>
		<para>This Red Hat Enterprise Linux 4 update 4 is running xinetd.</para>
		<screen>
[root@RHEL4b ~]# ps fax | grep inet
 3003 ?        Ss     0:00 xinetd -stayalive -pidfile /var/run/xinetd.pid	
		</screen>
		<para>Both daemons have the same functionality (listening to many ports, starting other daemons when they are needed), but they have different configuration files.</para>
	</section>
	<section><title>The superdaemon xinetd</title>
		<para>The <command>xinetd</command> daemon is often called a superdaemon because it listens to a lot of incoming connections, and starts other daemons when they are needed. When a connection request is received, xinetd will first check TCP wrappers (/etc/hosts.allow and /etc/hosts.deny) and then give control of the connection to the other daemon. This superdaemon is configured through <command>/etc/xinetd.conf</command> and the files in the directory <command>/etc/xinetd.d</command>. Let's first take a look at /etc/xinetd.conf.</para>
		<screen>
paul@RHELv4u2:~$ cat /etc/xinetd.conf 
#
# Simple configuration file for xinetd
#
# Some defaults, and include /etc/xinetd.d/
				
defaults
{
instances               = 60
log_type                = SYSLOG authpriv
log_on_success          = HOST PID
log_on_failure          = HOST
cps                     = 25 30
}
				
includedir /etc/xinetd.d
				
paul@RHELv4u2:~$ 
		</screen>
		<para>According to the settings in this file, xinetd can handle 60 client requests at once. It uses the <command>authpriv</command> facility to log the host ip-address and pid of successful daemon spawns. When a service (aka protocol linked to daemon) gets more than 25 cps (connections per second), it holds subsequent requests for 30 seconds.</para>
		<para>The directory <command>/etc/xinetd.d</command> contains more specific configuration files. Let's also take a look at one of them.</para>
		<screen>
paul@RHELv4u2:~$ ls /etc/xinetd.d
amanda     chargen-udp  echo      klogin       rexec   talk
amandaidx  cups-lpd     echo-udp  krb5-telnet  rlogin  telnet
amidxtape  daytime      eklogin   kshell       rsh     tftp
auth       daytime-udp  finger    ktalk        rsync   time
chargen    dbskkd-cdb   gssftp    ntalk        swat    time-udp
paul@RHELv4u2:~$ cat /etc/xinetd.d/swat 
# default: off
# description: SWAT is the Samba Web Admin Tool. Use swat \
#              to configure your Samba server. To use SWAT, \
#              connect to port 901 with your favorite web browser.
service swat
{
port            = 901
socket_type     = stream
wait            = no
only_from       = 127.0.0.1
user            = root
server          = /usr/sbin/swat
log_on_failure  += USERID
disable         = yes
}
paul@RHELv4u2:~$
		</screen>
		<para>The services should be listed in the <command>/etc/services</command> file. Port determines the service port, and must be the same as the port specified in /etc/services. The <command>socket_type</command> should be set to <command>stream</command> for tcp services (and to dgram for udp). The <command>log_on_failure +=</command> concats the userid to the log message formatted in /etc/xinetd.conf. The last setting <command>disable</command> can be set to yes or no. Setting this to <command>no</command> means the service is enabled! </para>
		<para>Check the xinetd and xinetd.conf manual pages for many more configuration options.</para>
	</section>
	<section><title>The superdaemon inetd</title>
		<para>This superdaemon has only one configuration file <command>/etc/inetd.conf</command>. Every protocol or daemon that it is listening for, gets one line in this file.</para>
		<screen>
root@barry:~# grep ftp /etc/inetd.conf 
tftp            dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd /boot/tftp
root@barry:~#
		</screen>
		<para>You can disable a service in inetd.conf above by putting a &#035; at the start of that line. Here an example of the disabled vmware web interface (listening on tcp port 902).</para>
		<screen>
paul@laika:~$ grep vmware /etc/inetd.conf 
#902 stream tcp nowait root /usr/sbin/vmware-authd vmware-authd
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Verify on all systems whether they are using xinetd or inetd.</para>
		<para>2. Look at the configuration files.</para>
		<para>3. (If telnet is installable, then replace swat in these questions with telnet) Is swat installed ? If not, then install swat and look at the changes in the (x)inetd configuration. Is swat enabled or disabled ?</para>
		<para>4. Disable swat, test it. Enable swat, test it.</para>
	</section>
</chapter>

<chapter><title>multihomed hosts</title>
	<section><title>Binding multiple ip-addresses</title>
		<para>To bind more than one ip-addres to the same interface, use <command>ifcfg-eth0:0</command>, where the last zero can be anything else. Only two directives are required in the file. </para>
		<screen>
root@RHELv4u2:/etc/sysconfig/network-scripts# cat ifcfg-eth0:0
DEVICE=eth0:0
IPADDR=192.168.1.232
		</screen>
	</section>
	<section><title>Enabling extra ip-addresses</title>
		<para>To activate a virtual network interface, use <command>ifup</command>, to deactivate it, use <command>ifdown</command>. </para>
		<screen>
root@RHELv4u2:~# ifdown eth0:0
root@RHELv4u2:~# ifup eth0:0
		</screen>
		<para>To stop, start or restart all network interfaces and services, use <command>service network stop|start|restart</command>. <emphasis>Do not stop the network when connected through ssh.</emphasis></para>
	</section>
	<section><title>Bonding two network cards</title>
		<para>You can combine two physical network interfaces as one logical interface. This doubles the bandwidth, and provides hardware redundancy. For <command>bonding</command> to work, you have to load the kernel module for bonding. You can do this manually with <command>modprobe</command>.</para>
		<screen>
root@RHELv4u2:/etc/sysconfig/network-scripts# modprobe bonding
root@RHELv4u2:/etc/sysconfig/network-scripts# lsmod | grep bon
bonding                58984  0
		</screen>
		<para>Or automatically, by adding the alias to <command>/etc/modprobe.conf</command> (used to be called /etc/modules.conf). </para>
		<screen>
root@RHELv4u2:/etc/sysconfig/network-scripts# alias bond0 bonding >> /etc/modprobe.conf
		</screen>
		<para>You need two network cards to enable bonding, and add the <command>MASTER</command> and <command>SLAVE</command> variables. In this case we used eth0 and eth1, configured like this.</para>
		<screen>
root@RHELv4u2:~# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BROADCAST=192.168.1.255
HWADDR=00:0C:29:5A:86:D7
IPADDR=192.168.1.222
NETMASK=255.255.255.0
NETWORK=192.168.1.0
ONBOOT=yes
TYPE=Ethernet
GATEWAY=192.168.1.1
MASTER=bond0
SLAVE=yes
USERCTL=no
root@RHELv4u2:~# cat /etc/sysconfig/network-scripts/ifcfg-eth1
DEVICE=eth1
BROADCAST=192.168.1.255
HWADDR=00:0C:29:5A:86:E1
IPADDR=192.168.1.232
NETMASK=255.255.255.0
NETWORK=192.168.1.0
ONBOOT=yes
TYPE=Ethernet
GATEWAY=192.168.1.1
MASTER=bond0
SLAVE=yes
USERCTL=no
root@RHELv4u2:~# 
		</screen>
		<para>And you need to set up a bonding interface. In this case, we call it bond0.</para>
		<screen>
root@RHELv4u2:~# cat /etc/sysconfig/network-scripts/ifcfg-bond0 
DEVICE=bond0
BOOTPROTO=none
ONBOOT=no
NETWORK=192.168.1.0
NETMASK=255.255.255.0
IPADDR=192.168.1.229
USERCTL=no
root@RHELv4u2:~#
		</screen>
		<para>To bring up the interface, just use the <command>ifup bond0</command> command.</para>
		<screen>
root@RHELv4u2:/etc/sysconfig/network-scripts# ifup bond0
Enslaving eth0 to bond0
Enslaving eth1 to bond0
root@RHELv4u2:~#
		</screen>
		<para>The <command>ifconfig</command> command will show you all activated interfaces.</para>
		<screen>
root@RHELv4u2:~# ifconfig
bond0     Link encap:Ethernet  HWaddr 00:0C:29:5A:86:D7  
inet addr:192.168.1.229  Bcast:192.168.1.255  Mask:255.255.255.0
inet6 addr: fe80::200:ff:fe00:0/64 Scope:Link
UP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1
RX packets:3835 errors:0 dropped:0 overruns:0 frame:0
TX packets:1001 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0 
RX bytes:469645 (458.6 KiB)  TX bytes:139816 (136.5 KiB)
				
eth0      Link encap:Ethernet  HWaddr 00:0C:29:5A:86:D7  
inet6 addr: fe80::20c:29ff:fe5a:86d7/64 Scope:Link
UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
RX packets:3452 errors:0 dropped:0 overruns:0 frame:0
TX packets:837 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000 
RX bytes:412155 (402.4 KiB)  TX bytes:117844 (115.0 KiB)
Interrupt:11 Base address:0x1400 
				
eth1      Link encap:Ethernet  HWaddr 00:0C:29:5A:86:D7  
inet6 addr: fe80::20c:29ff:fe5a:86d7/64 Scope:Link
UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
RX packets:392 errors:0 dropped:0 overruns:0 frame:0
TX packets:177 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000 
RX bytes:58084 (56.7 KiB)  TX bytes:24078 (23.5 KiB)
Interrupt:10 Base address:0x1480 
		</screen>
	</section>
	<section><title>Practice multihomed hosts</title>
		<para>1. Add an extra ip address to your server. Test that it works (have your neighbour ssh to it)!</para>
		<para>2. Use ifdown and ifup to disable and enable the second ip address.</para>
		<para>3. Add a network card to the vmware machine, and bond the two cards as one virtual (double bandwidth and failover) card.</para>
	</section>
</chapter>
<chapter><title>NAS and NFS</title>
	<section><title>Network Attached Storage (NAS)</title>
		<para>NAS means using separate servers with lots of storage, connected over a (hopefully very fast) network. NAS servers offer <command>file-based access</command> over the network with protocols like <command>NCP</command> (old Novell Netware), Sun's <command>NFS</command> (common on Unix) or <command>SMB</command> (implemented on Unix/Linux with Samba). NAS is not to be confused with <command>SAN</command>, which uses <command>block-based access</command> over proprietary protocols (Fiber Channel, iSCSI, ...). A <command>NAS head</command> is a NAS without on-board storage, which connects to a SAN and acts as a translator between the file-level NAS protocols and the block-level SAN protocols.</para>
	</section>
	<section><title>NFS: the Network File System</title>
		<section><title>protocol versions</title>
			<para>The older <command>NFS</command> versions 2 and 3 are stateless (udp) by default, but they can use tcp. Clients connect to the server using <command>RPC</command> (on Linux this is controlled by the <command>portmap</command> daemon. Look at <command>rpcinfo</command> to verify that NFS and its related services are running.</para>
			<screen>
root@RHELv4u2:~# /etc/init.d/portmap status
portmap (pid 1920) is running...
root@RHELv4u2:~# rpcinfo -p
program vers proto   port
100000    2   tcp    111  portmapper
100000    2   udp    111  portmapper
100024    1   udp  32768  status
100024    1   tcp  32769  status
root@RHELv4u2:~# service nfs start
Starting NFS services:                                     [  OK  ]
Starting NFS quotas:                                       [  OK  ]
Starting NFS daemon:                                       [  OK  ]
Starting NFS mountd:                                       [  OK  ]
			</screen>
			<para>The same rpcinfo command when NFS is started.</para>
			<screen>
root@RHELv4u2:~# rpcinfo -p
program vers proto   port
100000    2   tcp    111  portmapper
100000    2   udp    111  portmapper
100024    1   udp  32768  status
100024    1   tcp  32769  status
100011    1   udp    985  rquotad
100011    2   udp    985  rquotad
100011    1   tcp    988  rquotad
100011    2   tcp    988  rquotad
100003    2   udp   2049  nfs
100003    3   udp   2049  nfs
100003    4   udp   2049  nfs
100003    2   tcp   2049  nfs
100003    3   tcp   2049  nfs
100003    4   tcp   2049  nfs
100021    1   udp  32770  nlockmgr
100021    3   udp  32770  nlockmgr
100021    4   udp  32770  nlockmgr
100021    1   tcp  32789  nlockmgr
100021    3   tcp  32789  nlockmgr
100021    4   tcp  32789  nlockmgr
100005    1   udp   1004  mountd
100005    1   tcp   1007  mountd
100005    2   udp   1004  mountd
100005    2   tcp   1007  mountd
100005    3   udp   1004  mountd
100005    3   tcp   1007  mountd
root@RHELv4u2:~#
			</screen>
			<para>NFS version 4 requires tcp (port 2049) and supports <command>Kerberos</command> user authentication as an option. NFS authentication only takes place when mounting the share. NFS versions 2 and 3 authenticate only the host.</para>
		</section>			
		<section><title>server configuration</title>
			<para> NFS is configured in <command>/etc/exports</command>. Here is a sample /etc/exports to explain the syntax. You need some way (NIS domain or LDAP) to synchronize userid's across computers when using NFS a lot. The <command>rootsquash</command> option will change UID 0 to the UID of the nfsnobody user account. The <command>sync</command> option will write writes to disk before completing the client request.</para>
			<screen>
paul@laika:~$ cat /etc/exports 
# Everyone can read this share
/mnt/data/iso  *(ro)
				
# Only the computers barry and pasha can readwrite this one
/var/www pasha(rw) barry(rw)
				
# same, but without root squashing for barry
/var/ftp pasha(rw) barry(rw,no_root_squash)
				
# everyone from the netsec.lan domain gets access
/var/backup       *.netsec.lan(rw)
				
# ro for one network, rw for the other
/var/upload   192.168.1.0/24(ro) 192.168.5.0/24(rw)
			</screen>
			<para>You don't need to restart the nfs server to start exporting your newly created exports. You can use the <command>exportfs -va</command> command to do this. It will write the exported directories to <command>/var/lib/nfs/xtab</command>, where they are immediately applied. </para>
		</section>	
		<section><title>client configuration</title>
			<para>We have seen the <command>mount</command> command and the <command>/etc/fstab</command> file before.</para>
			<screen>
root@RHELv4u2:~# mount -t nfs barry:/mnt/data/iso /home/project55/
root@RHELv4u2:~# cat /etc/fstab | grep nfs
barry:/mnt/data/iso   /home/iso               nfs     defaults    0 0
root@RHELv4u2:~# 
			</screen>
		</section>	
		<section><title>Mounting NAS</title>
			<para>Just a simple fictitious example. Suppose the project55 people tell you they only need a couple of CD-ROM images, and you already have them available on an NFS server. You could issue the following command to mount the network attached storage on their /home/project55 mount point.</para>
			<screen>
root@RHELv4u2:~# mount -t nfs 192.168.1.40:/mnt/data/iso /home/project55/
root@RHELv4u2:~# ls -lh /home/project55/
total 3.6G
drwxr-xr-x  2 1000 1000 4.0K Jan 16 17:55 RHELv4u1
drwxr-xr-x  2 1000 1000 4.0K Jan 16 14:14 RHELv4u2
drwxr-xr-x  2 1000 1000 4.0K Jan 16 14:54 RHELv4u3
drwxr-xr-x  2 1000 1000 4.0K Jan 16 11:09 RHELv4u4
-rw-r--r--  1 root root 1.6G Oct 13 15:22 sled10-vmwarews5-vm.zip
root@RHELv4u2:~# 
			</screen>
		</section>
	</section>
	<section><title>Practice NFS</title>
		<para>1. Create two directories with some files. Use NFS to share one of them as read only, the other must be writable. Have your neighbour connect to them to test.</para>
		<para>2. Investigate the user owner of the files created by your neighbour.</para>
		<para>3. Protect a share by ip-address or hostname, so only your neighbour can connect.</para>
	</section>
</chapter>

<chapter><title>Introduction to iptables</title>
	<section><title>Introducing iptables</title>
		<para>The Linux kernel has a built-in stateful firewall named iptables. To stop the <command>iptables</command> firewall on Red Hat, use the service command. </para>
		<screen>
root@RHELv4u4:~# service iptables stop
Flushing firewall rules:                                   [  OK  ]
Setting chains to policy ACCEPT: filter                    [  OK  ]
Unloading iptables modules:                                [  OK  ]
root@RHELv4u4:~# 
		</screen>
		<para>The easy way to configure iptables, is to use a graphical tool like KDE's <command>kmyfirewall</command> or <command>Security Level Configuration Tool</command>. You can find the latter in the GUI menu, somewhere in System Tools - Security, or you can start it by typing <command>system-config-securitylevel</command> in bash. These tools allow for some basic firewall configuration. You can decide whether to enable or disable the firewall, and what typical standard ports are allowed when the firewall is active. You can even add some custom ports. When you are done, the configuration is written to <command>/etc/sysconfig/iptables</command> on Red Hat. </para>
		<screen>
root@RHELv4u4:~# cat /etc/sysconfig/iptables
# Firewall configuration written by system-config-securitylevel
# Manual customization of this file is not recommended.
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:RH-Firewall-1-INPUT - [0:0]
-A INPUT -j RH-Firewall-1-INPUT
-A FORWARD -j RH-Firewall-1-INPUT
-A RH-Firewall-1-INPUT -i lo -j ACCEPT
-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT
-A RH-Firewall-1-INPUT -p 50 -j ACCEPT
-A RH-Firewall-1-INPUT -p 51 -j ACCEPT
-A RH-Firewall-1-INPUT -p udp --dport 5353 -d 224.0.0.251 -j ACCEPT
-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 25 -j ACCEPT
-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibited
COMMIT
root@RHELv4u4:~#
		</screen>
		<para>To start the service, issue the <command>service iptables start</command> command. You can configure iptables to start at boot time with chkconfig.</para>
		<screen>
root@RHELv4u4:~# service iptables start
Applying iptables firewall rules:                          [  OK  ]
root@RHELv4u4:~# chkconfig iptables on
root@RHELv4u4:~# 
		</screen>
		<para>One of the nice features of iptables is that it displays extensive <command>status</command> information when queried with the <command>service iptables status</command> command.</para>
		<screen>
root@RHELv4u4:~# service iptables status
Table: filter
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
RH-Firewall-1-INPUT  all  --  0.0.0.0/0            0.0.0.0/0           
				
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
RH-Firewall-1-INPUT  all  --  0.0.0.0/0            0.0.0.0/0           

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
				
Chain RH-Firewall-1-INPUT (2 references)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           icmp type 255 
ACCEPT     esp  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     ah   --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     udp  --  0.0.0.0/0            224.0.0.251         udp dpt:5353 
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           udp dpt:631 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:80 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:21 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:25 
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited 

root@RHELv4u4:~# 
		</screen>
		<para>Mastering firewall configuration requires a decent knowledge of tcp/ip. Good iptables tutorials can be found online here http://iptables-tutorial.frozentux.net/iptables-tutorial.html and here http://tldp.org/HOWTO/IP-Masquerade-HOWTO/.</para>
	</section>
	<section><title>Practice iptables</title>
		<para>1. Verify whether the firewall is running.</para>
		<para>2. Disable the firewall.</para>
	</section>
</chapter>
<chapter><title>VNC</title>
	<section><title>About VNC</title>
		<para>VNC can be configured in gnome or KDE using the <command>Remote Desktop Preferences</command>. VNC can be used to run your desktop on another computer (kinda like a software X-Terminal), but you can also use it to see and take over the Desktop of another user. The last part can be useful for help desks to show users how to do things. VNC has the added advantage of being operating system independent, a lot of products (realvnc, tightvnc, xvnc, ...) use the same protocol on Solaris, Linux, BSD and more. </para>
	</section>
	<section><title>VNC Server</title>
		<para>Starting the vnc server for the first time.</para>
		<screen>
[root@RHELv4u3 conf]# rpm -qa | grep -i vnc
vnc-server-4.0-8.1
vnc-4.0-8.1
[root@RHELv4u3 conf]# vncserver :2
				
You will require a password to access your desktops.
				
Password: 
Verify: 
xauth:  creating new authority file /root/.Xauthority
				
New 'RHELv4u3.localdomain:2 (root)' desktop is RHELv4u3.localdomain:2
				
Creating default startup script /root/.vnc/xstartup
Starting applications specified in /root/.vnc/xstartup
Log file is /root/.vnc/RHELv4u3.localdomain:2.log
				
[root@RHELv4u3 conf]# 
		</screen>
	</section>
	<section><title>VNC Client</title>
		<para>You can now use the <command>vncviewer</command> from another machine to connect to your vnc server. It will default to a very simple graphical interface...</para>
		<screen>
paul@laika:~$ vncviewer 192.168.1.49:2
VNC viewer version 3.3.7 - built Nov 20 2006 13:05:04
Copyright (C) 2002-2003 RealVNC Ltd.
Copyright (C) 1994-2000 AT&#038;T Laboratories Cambridge.
See http://www.realvnc.com for information on VNC.
VNC server supports protocol version 3.8 (viewer 3.3)
Password: 
VNC authentication succeeded
Desktop name "RHELv4u3.localdomain:2 (root)"
Connected to VNC server, using protocol version 3.3
...
		</screen>
		<para>If you don't like the simple twm window manager, you can comment out the last two lines of <command>~/.vnc/xstartup</command> and add a <command>gnome-session &#038;</command> line to have vnc default to gnome instead.</para>
		<screen>
[root@RHELv4u3 ~]# cat .vnc/xstartup 
#!/bin/sh
				
# Uncomment the following two lines for normal desktop:
# unset SESSION_MANAGER
# exec /etc/X11/xinit/xinitrc
				
[ -x /etc/vnc/xstartup ] &#038;&#038; exec /etc/vnc/xstartup
[ -r $HOME/.Xresources ] &#038;&#038; xrdb $HOME/.Xresources
xsetroot -solid grey
vncconfig -iconic &#038;
# xterm -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &#038;
# twm &#038;
gnome-session &#038;
[root@RHELv4u3 ~]#
		</screen> 
		<para>Don't forget to restart your vnc server after changing this file.</para>
		<screen>
[root@RHELv4u3 ~]# vncserver -kill :2
Killing Xvnc process ID 5785
[root@RHELv4u3 ~]# vncserver :2
		
New 'RHELv4u3.localdomain:2 (root)' desktop is RHELv4u3.localdomain:2
				
Starting applications specified in /root/.vnc/xstartup
Log file is /root/.vnc/RHELv4u3.localdomain:2.log
		</screen>
	</section>
	<section><title>Practive VNC</title>
		<para>1. Use VNC to connect from one machine to another.</para>
	</section>
</chapter>
<chapter><title>Backup network configuration</title>
	<section><title>Red Hat network settings backup</title>
		<para>It is always a good idea to have a backup of current network settings. The <command>system-config-network-cmd</command> can do this for you.</para>
		<screen>root@RHELv4u4:~# system-config-network-cmd -e > NetworkSettings20070208.txt</screen>
		<para>And system-config-network-cmd can also be used to restore these settings.</para>
		<screen>root@RHELv4u4:~# system-config-network-cmd -i -c &#060; NetworkSettings20070208.txt</screen>
		<para>For other Linux Systems, take a backup of the relevant portions in /etc.</para>
	</section>
</chapter>
<chapter><title>DHCP Server</title>
<section><title>About DHCP</title>
<para>The Dynamic Host Configuration Protocol is defined in rfc 2131 in 1997 (obsoleting rfc 1541 from 1993). The DHCP protocol allows for a DHCP server to provide a DHCP client with a complete IP address configuration, inlcuding ip address, subnet mask, default gateway (or router) and many more options.</para>
<para>Sniffing DHCP traffic will show four broadcasts. First a DHCPDISCOVER is sent from the client, then each server will broadcast a DHCPOFFER. The client will select an offer and broadcasts a DHCPREQUEST, which is then confirmed by the server with a DHCPACK.</para>
<para>The DHCP server leases this IP configuration for a certain lease time. The client will try to renew the lease before it expires by repeating the DHCPREQUEST packet and awaiting the corresponding DHCPACK.</para>
</section>
<section><title>Is DHCP installed ?</title>
<para>The most common DHPC server on Linux is the dhcpd daemon. You can verify installation with dpkg or rpm (depends on your choice of distribution).</para>
<screen>
rpm -qa | grep dhcpd
dpkg -l | grep dhcpd
</screen>
</section>
<section><title>About dhcpd</title>
<para>The <command>dhcpd</command> daemon has a configuration file <command>/etc/dhcpd.conf</command> and a file containing leases in /var/lib/dhcp/dhcpd.leases.</para>
<screen>
[paul@RHEL4b ~]$ apropos dhcpd
dhcpd                (8)  - Dynamic Host Configuration Protocol Server
dhcpd.conf [dhcpd]   (5)  - dhcpd configuration file
dhcpd.leases [dhcpd] (5)  - DHCP client lease database
[paul@RHEL4b ~]$ 
</screen>
<para>The default configuration file is very modest, but there are a lot of good examples in the manual page of dhcpd.</para>
<screen>
[root@RHEL4b ~]# ls -l /etc/dhcpd.conf 
-rw-rw-r--  1 root root 86 Nov 19  2005 /etc/dhcpd.conf
</screen>
</section>
<section><title>Example subnet</title>
<para>Below is a sample configuration for a subnet serviced by the dhcpd daemon. The subnet contains 100 available addresses in a 16-bit netmask.</para>
<screen>
[root@RHEL4b etc]# cat dhcpd.conf 

subnet 192.168.0.0 netmask 255.255.0.0 {
         range 192.168.55.1 192.168.55.100;
       }
</screen>
</section>
<section><title>Example router</title>
<para>This is an example subnet configuration with a router (aka default gateway) set to 192.168.100.1. The dhcpd daemon will warn you if the router is unreachable for the subnet clients.</para>
<screen>
[root@RHEL4b etc]# cat dhcpd.conf 

subnet 192.168.0.0 netmask 255.255.0.0 {
        option routers 192.168.100.1;
        range 192.168.55.1 192.168.55.100;
       }
</screen>
</section>

<section><title>Starting dhcpd</title>
<para>Below a complete and working example <command>dhcpd.conf</command> that can be used to start dhcpd.</para>
<screen>
[root@RHEL4b etc]# cat dhcpd.conf 
ddns-update-style ad-hoc;

subnet 192.168.0.0 netmask 255.255.0.0 {
        option routers 192.168.100.1;
        range 192.168.55.1 192.168.55.100;
       }

[root@RHEL4b etc]# service dhcpd start
Starting dhcpd:                                            [  OK  ]
</screen>
</section>
<section><title>address leases</title>
<para>The <command>/var/lib/dhcp/dhcpd.leases</command> file will contain an overview of all leases current leased by the DHCP server.</para>
<screen>
[root@RHEL4b etc]# tail /var/lib/dhcp/dhcpd.leases

lease 192.168.55.100 {
  starts 4 2007/08/30 06:09:39;
  ends 4 2007/08/30 18:09:39;
  binding state active;
  next binding state free;
  hardware ethernet 00:0c:29:2b:5b:ef;
  uid "\001\000\014)+[\357";
  client-hostname "WinXP";
}
[root@RHEL4b etc]# 
</screen>
</section>
<section><title>Host reservation</title>
<para>It is possible to tie a specific configuration to a host, using the MAC address of the host. This is called a DHCP host reservation. You can add additional options (like router and DNS server) to the host reservation.</para>
<screen>
[root@RHEL4b etc]# tail -5 dhcpd.conf 
host WinXP1 { 
        hardware ethernet 00:0C:29:2B:5B:EF; 
        fixed-address 192.168.55.104;
}
</screen>
</section>
<section><title>DNS server option</title>
<para>Adding the <command>domain-name-servers option</command> to a subnet (or other) section in /etc/dhcpd.conf will provide the client(s) with the ip address of a DNS name server.</para>
<screen>
[root@RHEL4b etc]# grep name dhcpd.conf 
option domain-name-servers      192.168.1.191;
</screen>
</section>
<section><title>Practice dhcpd</title>
	<para>1. Install dhcpd</para>
	<para>2. Configure a subnet in /etc/dhcpd.conf with router and DNS options, and start the dhcp server. Test with a client that it works.</para>
	<para>3. Create a host reservation with another DNS server for one of your clients. Test that it works.</para>
	<para></para>
	<para></para>
</section>
</chapter>
<chapter><title>Introduction to BIND</title>
<section><title>Domain Name System</title>
<para>DNS or Domain Name System is a worldwide distributed hierarchichal database. It's primary function is to resolve names to ip addresses, and to point to internet services like SMTP and LDAP.</para>
<para>Forward lookup zones are most common, they contain host or A records to translate hostnames or Fully Qualified Domain Names (FQDN) to ip addresses. Reverse lookup zones contain PTR records, they translate ip addresses to hostnames or FQDN's.</para>
<para>The internet contains thirteen logical DNS servers for the top of the hierarchy. This top is called the root, and is represented with a dot. Below the root are the Top Level Domains (TLD's). There are common TLD's like .com, .net. .info. aero. .museum, .gov, .mil, .edu and others. And there are country TLD's, like .be for Belgium and .fr for France.</para>
<para>The internet root name servers will only answer iterative queries, most local DNS servers will answer to recursive queries.</para>
</section>
<section><title>bind</title>
<para>One of the most common name servers on Linux is the Berkeley Internet Name Domain (bind) server. Use rpm or dpkg to verify whether it is installed.</para>
<screen>
[root@RHEL4b etc]# rpm -qa | grep -i bind
ypbind-1.17.2-8
bind-chroot-9.2.4-16.EL4
bind-utils-9.2.4-16.EL4
bind-devel-9.2.4-16.EL4
bind-libs-9.2.4-16.EL4
bind-9.2.4-16.EL4
</screen>
</section>
<section><title>named</title>
<para>The software is called 'bind', the daemon runs as 'named' ! So look for the named daemon, the named manual pages and /etc/named.conf to work with bind.</para>
<screen>
[root@RHEL4b etc]# apropos named | grep -i domain
named                (8)  - Internet domain name server
</screen>
</section>
<section><title>Caching only Name Server</title>
<para>A caching only name server is a DNS server that is not authoritative for any zone. It forwards queries to other DNS servers and locally caches the results.</para> 
<para>The default /etc/named.conf on RHEL is a caching only name server.</para>
</section>
<section><title>Our first zone</title>
<para>The way to set up zones in /etc/named.conf is to create a zone entry with a reference to another file located in /var/named.</para>
<para>Here is an example of such an entry in /etc/named.conf</para>
<screen>
zone "classdemo.local" IN {
	type master;
	file "classdemo.local.zone";
	allow-update { none; };
};
</screen>
<para>To create the zone file, the easy method is to copy an existing zone file (this is easier than writing from scratch).</para>
<screen>
[root@RHEL4b named]# cd /var/named/
[root@RHEL4b named]# pwd
/var/named
[root@RHEL4b named]# cp localhost.zone classdemo.local.zone
[root@RHEL4b named]#
</screen>
<para>Here is an example of a zone file.</para>
<screen>
[root@RHEL4b named]# cat classdemo.local.zone 
$TTL    86400
$ORIGIN classdemo.local.
@       IN SOA  rhel4b.classdemo.local.   admin.classdemo.local. (
                          2007083100      ; serial
                          3H              ; refresh
                          900             ; retry
                          1W              ; expiry
                          1D )            ; minimum

                IN NS           rhel4b.classdemo.local.
                IN MX     10    mail.classdemo.local.
                IN A            192.168.1.191

rhel4b          IN      A       192.168.1.191
mail            IN      A       192.168.1.191
www             IN      A       192.168.1.191
ftp             IN      A       192.168.1.191
server2         IN      A       192.168.1.1
</screen>
</section>
<section><title>Starting the name server</title>
<para>When starting the name server, don't forget to look at the log file to verify that all your zones are properly configured.</para>
<screen>
[root@RHEL4b etc]# service named restart
Stopping named:                                            [  OK  ]
Starting named:                                            [  OK  ]
[root@RHEL4b etc]# service named status
number of zones: 9
debug level: 0
xfers running: 0
xfers deferred: 0
soa queries in progress: 0
query logging is OFF
server is up and running
[root@RHEL4b etc]# 
</screen>
</section>
<section><title>Practice DNS</title>
<para>1. Set up a working DNS server with your own zone. Test that it works.</para>
<para>2. Set up a master and a slave server.</para>
<para></para>
</section>
</chapter>
<chapter><title>Introduction to Samba</title>
<section><title>Verify installed version</title>
<para>To see the version of samba installed on RedHat, use rpm -qa. Looks like Samba 3 in the screenshot here, version 3.0.10.</para>
<screen>
[paul@RHEL4b ~]$  rpm -qa | grep samba
samba-common-3.0.10-1.4E.9
samba-client-3.0.10-1.4E.9
system-config-samba-1.2.21-1
samba-swat-3.0.10-1.4E.9
samba-3.0.10-1.4E.9
[paul@RHEL4b ~]$ 
</screen>
<para>Use dpkg -l on Debian or Ubuntu. Our Feisty Fawn here uses Samba 3.0.24</para>
<screen>
paul@laika:~$ dpkg -l | grep samba
ii  samba-common    3.0.24-2ubuntu1.2    Samba common files used by both the...
paul@laika:~$ 
</screen>
</section>
<section><title>Installing Samba</title>
	<para>Samba is installed by default on Red Hat Enterprise Linux. If Samba is not yet installed, then the easiest way is to use the graphical menu (Applications -- System Settings -- Add/Remove Applications) and select "Windows File Server" in the Server section. The non-graphical way is to either use rpm -i followed by the samba-version.rpm file.</para>
	<screen>
[paul@RHEL4b ~]$  rpm -i samba-3.0.10-1.4E.9.rpm
	</screen>
	<para>Or if you have a subscription to RHN, then <command>up2date</command> is the tool to use.</para>
	<screen>
[paul@RHEL4b ~]$  up2date -i samba
	</screen>
	<para>Ubuntu and Debian users can use the aptitude program.</para>
	<screen>
paul@laika:~$ aptitude install samba-server
	</screen>
</section>
<section><title>Documentation</title>
	<para>Obviously there are manual pages for Samba. Don't forget <command>man smb.conf</command>.</para>
	<screen>
[root@RHEL4b samba]# apropos samba
cupsaddsmb       (8)  - export printers to samba for windows clients
lmhosts          (5)  - The Samba NetBIOS hosts file
net              (8)  - Tool for administration of Samba and remote CIFS servers
pdbedit          (8)  - manage the SAM database (Database of Samba Users)
samba            (7)  - A Windows SMB/CIFS fileserver for UNIX
smb.conf [smb]   (5)  - The configuration file for the Samba suite
smbpasswd        (5)  - The Samba encrypted password file
smbstatus        (1)  - report on current Samba connections
swat             (8)  - Samba Web Administration Tool
tdbbackup        (8)  - tool for backing up and ... of samba .tdb files
[root@RHEL4b samba]# 
</screen>
	<para>Samba comes with excellent documentation in html and pdf format (and also as a free download from Samba.org and are for sale as a printed book). Red Hat Enterprise Linux installs the html and pdf version in /usr/share/doc by default.</para>
	<screen>
[paul@RHEL4b ~]$ locate Samba-HOWTO-Collection.pdf
/usr/share/doc/samba-3.0.10/Samba-HOWTO-Collection.pdf
	</screen>
	<para>Ubuntu packages the docs as a seperate package from Samba.</para>
	<screen>
root@laika:~# aptitude search samba | grep -i documentation
i   samba-doc                       - Samba documentation                       
i   samba-doc-pdf                   - Samba documentation (PDF format)          
root@laika:~# find /usr/share/doc/samba-doc-pdf | grep -i howto
/usr/share/doc/samba-doc-pdf/Samba3-HOWTO.pdf.gz
	</screen>
	<para>Besides the howto, there is also an excellent book called <command>Samba by example</command> (again available as book in shops, and as a free pdf and html).</para>
</section>
<section><title>smb.conf</title>
<para>Samba configuration is done in the <command>smb.conf</command> file. The file can be edited manually, or you can use a web based interface like webmin or swat to manage it. The file is usually located in /etc/samba. You can find the exact location with <command>smbd -b</command>.</para>
<screen>
[root@RHEL4b ~]# smbd -b | grep CONFIGFILE
CONFIGFILE: /etc/samba/smb.conf
[root@RHEL4b ~]# 
</screen>
<para>The default smb.conf file contains a lot of examples with explanations.</para>
<screen>
[paul@RHEL4b ~]$ ls -l /etc/samba/smb.conf 
-rw-r--r--  1 root root 10836 May 30 23:08 /etc/samba/smb.conf
(...)
paul@laika:~$ ls -l /etc/samba/smb.conf 
-rw-r--r-- 1 root root 10515 2007-05-24 00:21 /etc/samba/smb.conf
</screen>
<para>Below is an example of a very minimalistic smb.conf. It allows samba to start, and to be visible to other computers (Microsoft shows computers in Network Neighborhood or My Network Places). </para>
<screen>
[paul@RHEL4b ~]$ cat /etc/samba/smb.conf
[global]
workgroup = WORKGROUP
[firstshare]
path = /srv/samba/public
[paul@RHEL4b ~]$ 
</screen>
<para>Below is a screenshot of the <command>net view</command> command on Microsoft Windows XP sp2. It shows how the Samba server with the minimalistic smb.conf is visible to Microsoft computers nearby.</para>
<screen>
C:\Documents and Settings\paul>net view
Server Name            Remark

-------------------------------------------------------------------------------
\\RHEL4B               Samba 3.0.10-1.4E.9                                     
\\W2000                                                                        
\\WINXP                                                                        
The command completed successfully.
</screen>
<para>Some parameters in smb.conf can get a long list of values behind them. You can continue a line (for clarity) on the next by ending the line with a backslash.</para>
<screen>
valid users = Serena, Venus, Lindsay \
              Kim, Justine, Sabine \
              Amelie, Marie, Suzanne
</screen>
<para>Curious but true, smb.conf accepts synonyms like <command>create mode</command> and <command>create mask</command>, and sometimes minor spelling errors like <command>browsable</command> and <command>browseable</command>. And on occasion you can even switch words, the <command>guest only</command> parameter is identical to <command>only guest</command>.</para>
</section>
<section><title>testparm</title>
<para>To verify the syntax of the smb.conf file, you can use testparm.</para>
<screen>
[paul@RHEL4b ~]$ testparm
Load smb config files from /etc/samba/smb.conf
Processing section "[firstshare]"
Loaded services file OK.
Server role: ROLE_STANDALONE
Press enter to see a dump of your service definitions
	
[paul@RHEL4b ~]$ 
</screen>
<para>An interesting option is <command>testparm -v</command>, which will output all the global options with their default value. The remark seen by the <command>net view</command> command is the default value for the "server string" option. Simply adding this value to the global section in smb.conf and restarting samba will change the option. After a while, the changed option is visible on the Microsoft computers.</para>
<screen>
C:\Documents and Settings\paul>net view
Server Name            Remark
	
-------------------------------------------------------------------------------
\\RHEL4B               Public File Server                                      
\\W2000                                                                        
\\WINXP                                                                        
The command completed successfully.
</screen>
<para>The samba daemons are constantly (once every 60 seconds) checking the smb.conf file, so it is good practice to keep this file small. But it is also good practice to document your samba configuration, and to explicitly set options that have the same default values. The <command>testparm -s</command> option allows you to do both. It will output the smallest possible samba configuration file, while retaining all your settings. The idea is to have your samba configuration in another file (like smb.conf.full) and let testparm parse this for you. The screenshot below shows you how. First the smb.conf.full file with the explicitly set option workgroup to WORKGROUP. </para>
<screen>
[root@RHEL4b samba]# cat smb.conf.full 
[global]
workgroup = WORKGROUP

# This is a demo of a documented smb.conf
# These two lines are removed by testparm -s

server string = Public Test Server

[firstshare]
path = /srv/samba/public
</screen>
<para>Next, we execute testparm with the -s option, and redirect stdout to the real smb.conf file.</para>
<screen>
[root@RHEL4b samba]# testparm -s smb.conf.full > smb.conf
Load smb config files from smb.conf.full
Processing section "[firstshare]"
Loaded services file OK.
</screen>
<para>And below is the end result. The two comment lines and the default option are no longer there.</para>
<screen>
[root@RHEL4b samba]# cat smb.conf
# Global parameters
[global]
server string = Public Test Server

[firstshare]
path = /srv/samba/public
[root@RHEL4b samba]# 
</screen>
</section>
<section><title>Samba daemons</title>
	<para>Samba 3 consists of three daemons, they are named <command>nmbd</command>, <command>smbd</command> and <command>winbindd</command>. The <command>nmbd</command> daemon takes care of all the names and naming. It registers and resolves names, and handles browsing. It should be the first daemon to start. The <command>smbd</command> daemon manages file transfers and authentication. It should be started after nmbd. The <command>winbindd</command> daemon is only started to handle Microsoft Windows domain membership.</para>
	<para>You can start the daemons by invoking <command>/etc/init.d/smb start</command> (some systems use <command>/etc/init.d/samba</command>) on any linux. Red Hat derived systems are happy with <command>service smb start</command>. </para>
	<screen>
[root@RHEL4b ~]# /etc/init.d/smb start
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b ~]# service smb restart
Shutting down SMB services:                                [  OK  ]
Shutting down NMB services:                                [  OK  ]
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b ~]# 
	</screen>
</section>
<section><title>smbclient</title>
	
	<para>With <command>smbclient</command> you can see browsing and share information from your smb server. It will display all your shares, your workgroup, and the name of the Master Browser. The -N switch is added to avoid having to enter an empty password. The -L switch is followed by the name of the host to check.</para>
	<screen>
[root@RHEL4b init.d]# smbclient -NL rhel4b
Anonymous login successful
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Sharename       Type      Comment
---------       ----      -------
firstshare      Disk      
IPC$            IPC       IPC Service (Public Test Server)
ADMIN$          IPC       IPC Service (Public Test Server)
Anonymous login successful
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Server               Comment
---------            -------
RHEL4B               Public Test Server
WINXP                

Workgroup            Master
---------            -------
WORKGROUP            WINXP
	</screen>
	<para>The screenshot below uses smbclient to display information about a remote smb server (in this case a Windows XP machine).</para>
	<screen>
[root@RHEL4b init.d]# smbclient -NL winxp
Anonymous login successful
Domain=[WORKGROUP] OS=[Windows 5.1] Server=[Windows 2000 LAN Manager]

Sharename       Type      Comment
---------       ----      -------
Error returning browse list: NT_STATUS_ACCESS_DENIED
Anonymous login successful
Domain=[WORKGROUP] OS=[Windows 5.1] Server=[Windows 2000 LAN Manager]

Server               Comment
---------            -------
RHEL4B               Public Test Server
W2000                
WINXP                

Workgroup            Master
---------            -------
WORKGROUP            WINXP
	</screen>
</section>
<section><title>smbtree</title>
	<para>Another useful tool to troubleshoot Samba or simply to browse the SMB network is <command>smbtree</command>. In its simplest form, smbtree will do an anonymous browsing on the local subnet. displaying all SMB computers and (if authorized) their shares.</para>
	<para> Let's take a look at two screenshots of smbtree in action (with blank password). The first one is taken immediately after booting four different computers (one MS Windows 2000, one MS Windows XP, one MS Windows 2003 and one RHEL 4 with Samba 3.0.10).</para>
	<screen>
[paul@RHEL4b ~]$ smbtree
Password: 
WORKGROUP
PEGASUS
	\\WINXP          
	\\RHEL4B                        Pegasus Domain Member Server
Error connecting to 127.0.0.1 (Connection refused)
cli_full_connection: failed to connect to RHEL4B&#060;20&#062; (127.0.0.1)
	\\HM2003         
[paul@RHEL4b ~]$
	</screen>
	<para>The information displayed in the previous screenshot looks incomplete. The browsing elections are still ongoing, the browse list is not yet distributed to all clients by the (to be elected) browser master. The next screenshot was taken about one minute later. And it shows even less.</para>
	<screen>
[paul@RHEL4b ~]$ smbtree
Password: 
WORKGROUP
	\\W2000          
[paul@RHEL4b ~]$
	</screen>
	<para>So we wait a while, and then run smbtree again, this time it looks a lot nicer.</para>
	<screen>
[paul@RHEL4b ~]$ smbtree
Password: 
WORKGROUP
	\\W2000          
PEGASUS
	\\WINXP          
	\\RHEL4B                        Pegasus Domain Member Server
		\\RHEL4B\ADMIN$                 IPC Service (Pegasus Domain Member Server)
		\\RHEL4B\IPC$                   IPC Service (Pegasus Domain Member Server)
		\\RHEL4B\domaindata             Active Directory users only
	\\HM2003         
[paul@RHEL4b ~]$ smbtree --version
Version 3.0.10-1.4E.9
[paul@RHEL4b ~]$ 
	</screen>
	<para>I added the version number of smbtree in the previous screenshot, to show you the difference when using the latest version of smbtree (below a screenshot taken from Ubuntu Feisty Fawn). The latest version shows a more complete overview of machines and shares.</para>
	<screen>
paul@laika:~$ smbtree --version
Version 3.0.24
paul@laika:~$ smbtree
Password: 
WORKGROUP
	\\W2000          
		\\W2000\firstshare     
		\\W2000\C$              Default share
		\\W2000\ADMIN$          Remote Admin
		\\W2000\IPC$            Remote IPC
PEGASUS
	\\WINXP          
cli_rpc_pipe_open: cli_nt_create failed on pipe \srvsvc to machine WINXP.
Error was NT_STATUS_ACCESS_DENIED
	\\RHEL4B                        Pegasus Domain Member Server
		\\RHEL4B\ADMIN$                 IPC Service (Pegasus Domain Member Server)
		\\RHEL4B\IPC$                   IPC Service (Pegasus Domain Member Server)
		\\RHEL4B\domaindata             Active Directory users only
	\\HM2003         
cli_rpc_pipe_open: cli_nt_create failed on pipe \srvsvc to machine HM2003.
Error was NT_STATUS_ACCESS_DENIED
paul@laika:~$ 
	</screen>
	<para>The previous screenshot also provides useful errors on why we cannot see shared info on computers winxp and w2003. Let us try the old smbtree version on our RHEL server, but this time with Administrator credentials (which are the same on all computers).</para>
	<screen>
[paul@RHEL4b ~]$ smbtree -UAdministrator%Stargate1
WORKGROUP
	 \\W2000          
PEGASUS
	 \\WINXP          
	  	\\WINXP\C$              Default share
	  	\\WINXP\ADMIN$          Remote Admin
	  	\\WINXP\share55        
	  	\\WINXP\IPC$            Remote IPC
	 \\RHEL4B                 	Pegasus Domain Member Server
	  	\\RHEL4B\ADMIN$         IPC Service (Pegasus Domain Member Server)
	  	\\RHEL4B\IPC$           IPC Service (Pegasus Domain Member Server)
	  	\\RHEL4B\domaindata     Active Directory users only
	 \\HM2003         
	  	\\HM2003\NETLOGON       Logon server share 
	  	\\HM2003\SYSVOL         Logon server share 
	  	\\HM2003\WSUSTemp       A network share used by Local Publishing ...
	  	\\HM2003\ADMIN$         Remote Admin
	  	\\HM2003\tools          
	  	\\HM2003\IPC$           Remote IPC
	  	\\HM2003\WsusContent    A network share to be used by Local ...
	  	\\HM2003\C$             Default share
[paul@RHEL4b ~]$ 
	</screen>
	<para>As you can see, this gives a very nice overview of all SMB computers and their shares.</para>
</section>
<section><title>Samba Web Administration Tool (SWAT)</title>
	<para>Samba comes with a web based tool to manage your samba configuration file. The tool is accessible with a web browser on port 901 of the host system. To enable the tool, first find out whether your system is using the inetd or the xinetd superdaemon.</para>
	<screen>
	[root@RHEL4b samba]# ps fax | grep inet
	15026 pts/0    S+     0:00                      \_ grep inet
	 2771 ?        Ss     0:00 xinetd -stayalive -pidfile /var/run/xinetd.pid
	[root@RHEL4b samba]# 
	</screen>
	<para>Then edit the inetd.conf or change the disable = yes line in /etc/xinetd.d/swat to disable = no.</para>
	<screen>
[root@RHEL4b samba]# cat /etc/xinetd.d/swat 
# default: off
# description: SWAT is the Samba Web Admin Tool. Use swat \
#              to configure your Samba server. To use SWAT, \
#              connect to port 901 with your favorite web browser.
service swat
{
	port            = 901
	socket_type     = stream
	wait            = no
	only_from       = 127.0.0.1
	user            = root
	server          = /usr/sbin/swat
	log_on_failure  += USERID
	disable         = no
}
[root@RHEL4b samba]# /etc/init.d/xinetd restart
Stopping xinetd:                                           [  OK  ]
Starting xinetd:                                           [  OK  ]
[root@RHEL4b samba]#
	</screen>
	<para>Be careful when using SWAT, it erases alle your manually edited comments in smb.conf.</para>
</section>
<section><title>Practice</title>
	<para>0. !! Make sure you know your student number, anything *ANYTHING* you name must include your student number!</para>
	<para>1. Verify that you can logon to a Linux/Unix computer. Write down the name and ip address of this machine.</para>
	<para>2. Do the same for all the other (virtual) machines available to you.</para>
	<para>3. Verify networking by pinging the machines, if you like names, edit the appropriate hosts files.</para>
	<para>4. Make sure Samba is installed, write down the version of Samba.</para>
	<para>5. Open the Official Samba-3 howto pdf file that is installed on your computer. How many A4 pages is this file ? Then look at the same pdf on samba.org, it is updated regularly.</para>
	<para>6. Take a backup copy of the original smb.conf, name it smb.conf.orig</para>
	<para>7. Enable SWAT and take a look at it.</para>
	<para>8. Stop the Samba server.</para>
	<para>9. Create a minimalistic smb.conf.minimal and test it with testparm.</para>
	<para>10. Start Samba with your minimal smb.conf.</para>
	<para>11. Verify with smbclient that your Samba server works.</para>
	<para>12. Verify that another (Microsoft) computer can see your Samba server.</para>
	<para>13. Browse the network with net view and smbtree.</para>
	<para>14. Change the "Server String" parameter in smb.conf. How long does it take before you see the change (net view, smbclient, My Network Places,...) ?</para>
	<para>15. Will restarting Samba after a change to smb.conf speed up the change ?</para>
	<para>16. Which computer is the master browser master in your workgroup ? What is the master browser ?</para>
	<para>17. If time permits (or if you are waiting for other students to finish this practice), then install a sniffer (ethereal/wireshark) and watch the browser elections.</para>
</section>
</chapter>
<chapter><title>Simple Samba File Servers</title>
	<section><title>Read Only File Server</title>
		<para>Let's start with setting up a very simple read only file server with Samba. Everyone (even anonymous guests) will receive read access.</para>
		<para>The first step is to create a directory and put some test files in it.</para>
		<screen>
[root@RHEL4b samba]# mkdir -p /srv/samba/readonly
[root@RHEL4b samba]# ls -l /srv/samba/
total 4
drwxr-xr-x  2 root root 4096 Jun 22 11:07 readonly
[root@RHEL4b samba]# cd /srv/samba/readonly/
[root@RHEL4b readonly]# echo "It is cold today." > winter.txt
[root@RHEL4b readonly]# echo "It is hot today." > summer.txt
[root@RHEL4b readonly]# ll
total 8
-rw-r--r--  1 root root 17 Jun 22 11:13 summer.txt
-rw-r--r--  1 root root 18 Jun 22 11:13 winter.txt
[root@RHEL4b readonly]#
		</screen>
		<para>Linux will always require a user account before giving access to files (the files in our example above are owned by root). So we will create a user for our readonly file server and make this user the owner of the directory and all of its files. (Strictly speaking, you can setup a Samba read only file server without creating an extra user account).</para>
		<screen>
[root@RHEL4b ~]# useradd -c "Anonymous Samba Access" -p secret -s /bin/false Samba_nobody
[root@RHEL4b samba]# chown Samba_nobody.Samba_nobody /srv/samba/readonly/
[root@RHEL4b samba]# chmod 777 /srv/samba/readonly/
[root@RHEL4b samba]# ls -l /srv/samba/
total 4
drwxrwxrwx  2 Samba_nobody Samba_nobody 4096 Jun 22 11:09 readonly
[root@RHEL4b samba]# cd /srv/samba/readonly/
[root@RHEL4b readonly]# chown Samba_nobody.Samba_nobody *
[root@RHEL4b readonly]# ll
total 8
-rw-r--r--  1 Samba_nobody Samba_nobody 17 Jun 22 11:13 summer.txt
-rw-r--r--  1 Samba_nobody Samba_nobody 18 Jun 22 11:13 winter.txt
[root@RHEL4b samba]# 
		</screen>
		<para>It is time to create the smb.conf file (feel free to test it with testparm). We put our file server in the default workgroup, give it a descriptive server string, and set the security to share level (more on this later). The share is called pubread, and access to the share is enforced by Samba (remember we gave 777 to the directory).</para>
		<screen>
[root@RHEL4b samba]# cat smb.conf
[global]
workgroup = WORKGROUP
server string = Public Anonymous File Server
security = share

[pubread]
path = /srv/samba/readonly
comment = files to read
read only = Yes
guest ok = Yes
[root@RHEL4b samba]# 
		</screen>
		<para>After testing with testparm, restart the samba server and verify the existence of the share with smbclient.</para>
		<screen>
[root@RHEL4b readonly]# service smb restart
Shutting down SMB services:                                [  OK  ]
Shutting down NMB services:                                [  OK  ]
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b readonly]# smbclient -L 127.0.0.1
Password: 
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Sharename       Type      Comment
---------       ----      -------
pubread         Disk      files to read
IPC$            IPC       IPC Service (Public Anonymous File Server)
ADMIN$          IPC       IPC Service (Public Anonymous File Server)
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Server               Comment
---------            -------
RHEL4B               Public Test Server
WINXP                

Workgroup            Master
---------            -------
WORKGROUP            WINXP
[root@RHEL4b readonly]#
		</screen>
		<para>The final test is to go to a Microsoft Windows computer and read a file on the Samba server. First we use the <command>net use</command> command to mount the pubread share on the driveletter k.</para>
		<screen>
C:\Documents and Settings\paul&#062;net use k: \\rhel4b\pubread
The command completed successfully.
		</screen>
		<para>Then we test looking at the contents of the share, and reading the files.</para>
		<screen>					
C:\Documents and Settings\paul&#062;k:
						
K:\&#062;dir
Volume in drive K is pubread
Volume Serial Number is 0D56-11F2
				
Directory of K:\
						
06/22/2007  11:13 AM    &#060;DIR&#062;          .
06/22/2007  11:09 AM    &#060;DIR&#062;          ..
06/22/2007  11:13 AM                18 winter.txt
06/22/2007  11:13 AM                17 summer.txt
2 File(s)             35 bytes
2 Dir(s)   2,763,522,048 bytes free

K:\&#062;type winter.txt
It is cold today.

K:\&#062;
		</screen>
		<para>Just to be on the safe side, let us try writing.</para>
		<screen>
K:\&#062;echo very cold &#062; winter.txt
Access is denied.

K:\&#062;
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Create a directory in a good location (FHS) to share files for everyone to read.</para>
		<para>2. Make sure the directory is owned properly, put a textfile in it, then share it with Samba.</para>
		<para>3. Verify from your own and from another computer (smbclient, net use, ...) that the share is accessible for reading.</para>
		<para>4. Make a backup copy of your smb.conf, name it smb.conf.ReadOnlyFileServer.</para>
	</section>
	<section><title>Writable File Server</title>
		<para>In this second example, we will create a share where everyone can create files and write to files. Similar to before, we start by creating a directory, and setting ownership to our Samba_nobody user account.</para>
		<screen>
[root@RHEL4b samba]# mkdir /srv/samba/writable
[root@RHEL4b samba]# chown Samba_nobody.Samba_nobody /srv/samba/writable/
[root@RHEL4b samba]# chmod 777 /srv/samba/writable/
		</screen>
		<para>Then we simply add a share to our file server by editing smb.conf. Below the check with testparm.</para>
		<screen>
[root@RHEL4b samba]# testparm
Load smb config files from /etc/samba/smb.conf
Processing section "[pubread]"
Processing section "[pubwrite]"
Loaded services file OK.
Server role: ROLE_STANDALONE
Press enter to see a dump of your service definitions

# Global parameters
[global]
server string = Public Anonymous File Server
security = SHARE

[pubread]
comment = files to read
path = /srv/samba/readonly
guest ok = Yes

[pubwrite]
comment = files to read and write
path = /srv/samba/writable
read only = No
guest ok = Yes
		</screen>
		<para>Restart Samba, then onto the Windows XP machine and test our writing skills.</para>
		<screen>
C:\Documents and Settings\paul&#062;net use w: \\rhel4b\pubwrite
The command completed successfully.

C:\Documents and Settings\paul&#062;w:

W:\&#062;echo This is a write test &#062; hello.txt

W:\&#062;dir
Volume in drive W is pubwrite
Volume Serial Number is 0D56-272A

Directory of W:\

06/22/2007  12:29 PM    &#060;DIR&#062;          .
06/22/2007  12:26 PM    &#060;DIR&#062;          ..
06/22/2007  12:31 PM                23 hello.txt
1 File(s)             23 bytes
2 Dir(s)   2,763,522,048 bytes free
	
W:\&#062;type hello.txt
type hello.txt
This is a write test 
	
W:\&#062;
		</screen>
		<para>There is one little issue though; the linux owner of the files created through this writable share is the linux guest account (usually named nobody).</para>
		<screen>
[root@RHEL4b samba]# ls -l /srv/samba/writable/
total 4
-rwxr--r--  1 nobody nobody 23 Jun 22 12:31 hello.txt
-rwxr--r--  1 nobody nobody  0 Jun 22 12:33 test.txt
[root@RHEL4b samba]# 
		</screen>
		<para>So this is not the cleanest solution. We will improve this in the next topic.</para>
	</section>
	<section><title>Forcing a User Owner</title>
		<para>The Samba_nobody user account that we created in the previous examples is actually not used by Samba. It just owns the files and directories that we created for our shares. The goal of this section is to force ownership of files created through the Samba share to belong to our Samba_nobody user. Remember, our server is still accessible to everyone, nobody needs to know this user account or password. We just want a clean linux server.</para>
		<para>To accomplish this, we first have to tell Samba about this user. We can do this by adding the account to <command>smbpasswd</command>. </para>
		<screen>
[root@RHEL4b samba]# smbpasswd -a Samba_nobody
New SMB password:
Retype new SMB password:
Added user Samba_nobody.
[root@RHEL4b samba]# 
		</screen>
		<para>To find out where Samba keeps this information, use <command>smbd -b</command>. The PRIVATE_DIR variable will show you where the smbpasswd database is located.</para>
		<screen>
[root@RHEL4b samba]# smbd -b | grep -i private
PRIVATE_DIR: /etc/samba
		</screen>
		<para>You can use a simple cat to see the contents of the smbpasswd database. The nobody user does not have a password, the Samba_nobody user does have one (it is secret).</para>
		<screen>
[root@RHEL4b samba]# cat /etc/samba/smbpasswd 
nobody:99:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXX...
Samba_nobody:502:552902031BEDE9EFAAD3B435B51404EE:878D8014606CDA29677A44...
[root@RHEL4b samba]# 
		</screen>
		<para>Now that Samba knows about this user, we can adjust our writable share to force the ownership of files created through it. For this we use the <command>force user</command> and <command>force group</command> options. Now we can be sure that all files in the Samba writable share are owned by the same Samba_nobody user.</para>
		<screen>
[root@RHEL4b samba]# testparm -s smb.conf 2&#062;/dev/null | tail -7
[pubwrite]
comment = files to read and write
path = /srv/samba/writable
force user = Samba_nobody
force group = Samba_nobody
read only = No
guest ok = Yes
[root@RHEL4b samba]# 
		</screen>
	</section>
	<section><title>More about smbclient</title>
		<para>Instead of going to the Microsoft machines, we can do the same tests from within linux with <command>smbclient</command>. This first screenshot shows how to verify that Samba is running on your localhost, how to list all the Samba shares, who is the Master Browser of the workgroup and some more information.</para>
		<screen>
[paul@RHEL4b ~]$ smbclient -NL localhost
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Sharename       Type      Comment
---------       ----      -------
pubread         Disk      files to read
pubwrite        Disk      files to read and write
authwrite       Disk      authenticated users only
IPC$            IPC       IPC Service (Public Anonymous File Server)
ADMIN$          IPC       IPC Service (Public Anonymous File Server)
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Server               Comment
---------            -------
RHEL4B               Public Anonymous File Server
WINXP                

Workgroup            Master
---------            -------
WORKGROUP            WINXP
[paul@RHEL4b ~]$ 
		</screen>
		<para>It can also be used to test user access to a Samba share. First an example of how to test anonymous access to our pubread share. If the connection is established, then we get an smb prompt. You can use exit or q to return to bash.</para>
		<screen>
[paul@RHEL4b ~]$ smbclient //rhel4b/pubread -U%
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]
smb: \&#062; dir
.                                   D        0  Fri Jun 22 11:13:15 2007
..                                  D        0  Fri Jun 22 13:03:54 2007
winter.txt                                  18  Fri Jun 22 11:13:11 2007
summer.txt                                  17  Fri Jun 22 11:13:15 2007

45734 blocks of size 262144. 10541 blocks available
smb: \&#062; exit
[paul@RHEL4b ~]$ 
		</screen>
	</section>
	<section><title>NetBIOS name resolving</title>
		<para>If your clients are spread across multiple subnets, then it is likely there is a WINS (Microsoft Windows Internet Naming Service) or NBNS (NetBIOS Name Server) available to resolve NetBIOS names. You should then point Samba to the wins server with the <command>wins server</command> parameter.</para>
		<screen>wins server = 10.0.0.42</screen>
		<para>You can set the resolving order that Samba should use with the <command>name resolve order</command> parameter.</para>
		<screen>name resolve order = wins lmhosts host bcast</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Create a directory and share it with Samba.</para>
		<para>2. Make sure everyone can read and write files, test writing with smbclient and from a Microsoft computer.</para>
		<para>3. Verify the ownership of files created by various users.</para>
		<para>4. Use the "force user" and "force group" directives to force ownership of files created in this shared directory.</para>
		<para>5. Test that Samba properly registers in a WINS server.</para>
		<para>6. Test the working of force user with smbclient and/or net use and/or the MS Windows Explorer.</para>
	</section>
</chapter>
<chapter><title>Samba Servers with authentication and restrictions</title>
	<section><title>Authenticated User Access</title>
		<para>The goal of this example is to set up a file share accessible to a number of different users. The users will need to authenticate with their password before access to this share is granted. We will first create three randomly named users, each with their own password. First we add these users to linux.</para>
		<screen>
[root@RHEL4b samba]# useradd -c "Serena Williams" -p SerenaW Serena
[root@RHEL4b samba]# useradd -c "Kim Clijsters" -p KimC Kim
[root@RHEL4b samba]# useradd -c "Martina Hingis" -p MartinaH Martina
		</screen>
		<para>Then we add them to the smbpasswd file, with the same password.</para>
		<screen>
[root@RHEL4b samba]# smbpasswd -a Serena
New SMB password:
Retype new SMB password:
Added user Serena.
[root@RHEL4b samba]# smbpasswd -a Kim
New SMB password:
Retype new SMB password:
Added user Kim.
[root@RHEL4b samba]# smbpasswd -a Martina
New SMB password:
Retype new SMB password:
Added user Martina.
		</screen>
		<para>We add the following section to our smb.conf (and create the directory /srv/samba/authwrite).</para>
		<screen>
[authwrite]
path = /srv/samba/authwrite
comment = authenticated users only
read only = No
guest ok = No
		</screen>
		<para>After restarting Samba, we test with different users from within Microsoft computers. First Kim from Windows XP.</para>
		<screen>
C:\&#062;net use m: \\rhel4b\authwrite /user:Kim KimC
The command completed successfully.

C:\&#062;m:

M:\&#062;echo greetings from Kim &#062; greetings.txt
		</screen>
		<para>The next screenshot is Martina on a Windows 2000 computer, she succeeds in writing her files, but fails to overwrite the file from Kim.</para>
		<screen>
C:\&#062;net use k: \\rhel4b\authwrite /user:Martina MartinaH
The command completed successfully.

C:\&#062;k:

K:\&#062;echo greetings from martina &#062; Martina.txt

K:\&#062;echo test overwrite &#062; greetings.txt
Access is denied.
		</screen>
		<para>You can also test connecting with authentication with smbclient, first we a wrong password, then with the correct one.</para>
		<screen>
[paul@RHEL4b ~]$ smbclient //rhel4b/authwrite -UMartina&#037;wrongpass
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]
tree connect failed: NT_STATUS_WRONG_PASSWORD
[paul@RHEL4b ~]$ smbclient //rhel4b/authwrite -UMartina&#037;MartinaH
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]
smb: \&#062; more Martina.txt
getting file \Martina.txt of size 25 as /tmp/smbmore.Uv6c86 (24.4 kb/s) (average 24.4 kb/s)
greetings from martina 
smb: \&#062; q
[paul@RHEL4b ~]$ 
		</screen>
		<para>Congratulations, you now have a simple standalone Samba file server with authenticated access. And the files in the shares belong to their proper owners.</para>
		<screen>
[root@RHEL4b samba]# ls -l /srv/samba/authwrite/
total 8
-rwxr--r--  1 Kim     Kim     17 Jun 22 13:05 greetings.txt
-rwxr--r--  1 Martina Martina 25 Jun 22 13:08 Martina.txt
		</screen>
	</section>
	<section><title>Frequently used share settings</title>
		<section><title>valid users</title>
			<para>To restrict users per share, you can use the <command>valid users</command> parameter. In the example below, only the users listed as valid will be able to access the tennis share.</para>
			<screen>
[tennis]
	path = /srv/samba/tennis
	comment = authenticated and valid users only
	read only = No
	guest ok = No
	valid users = serena, kim, venus, justine
			</screen>
		</section>
		<section><title>invalid users</title>
			<para>If you are paranoia, you can also use <command>invalid users</command> to explicitely deny the listed users access. When a user is in both lists, the user has no access!</para>
			<screen>
[tennis]
	path = /srv/samba/tennis
	read only = No
	guest ok = No
	valid users = kim, serena, venus, justine
	invalid users = venus
			</screen>
		</section>		
		<section><title>create mask and inherit permissions</title>
			<para>Similar to umask (but not inverted), you can use the <command>create mask</command> and <command>directory mask</command> to set default permissions for newly created files and directories.</para>
			<screen>
[tennis]
	path = /srv/samba/tennis
	read only = No
	guest ok = No
	create mask = 644
			</screen>
			<para>With <command>inherit permissions = Yes</command> you can force newly created files and directories to inherit permissions from their parent directory, overriding the create mask and directory mask settings.</para>
		</section>
		<section><title>hosts allow</title>
			<para>The <command>hosts allow</command> or <command>allow hosts</command> parameter is one of the key advantages of Samba. It allows access control of shares on the ip-address level. To allow only specific hosts to access a share, list the hosts, seperated by comma's.</para>
			<screen>allow hosts = 192.168.1.5, 192.168.1.40</screen>
			<para>Allowing entire subnets is done by ending the range with a dot.</para>
			<screen>allow hosts = 192.168.1.</screen>
			<para>Subnet masks can be added in the classical way.</para>
			<screen>allow hosts = 10.0.0.0/255.0.0.0</screen>
			<para>You can also allow an entire subnet with exceptions.</para>
			<screen>hosts allow = 10. except 10.0.0.12</screen>
		</section>
		<section><title>hosts deny</title>
			<para>The <command>hosts deny</command> or <command>deny hosts</command> parameter is the logical counterpart of the previous. The syntax is the same as for hosts allow.</para>
			<screen>hosts deny = 192.168.1.55, 192.168.1.56</screen>
		</section>
		<section><title>hide unreadable</title>
			<para>Setting <command>hide unreadable</command>to yes will prevent users from seeing files that cannot be read by them.</para>
			<screen>hide unreadable = yes</screen>
		</section>
		<section><title>read list</title>
			<para>One more setting before we go on to the next topic. Even on a writable share, you can set a list of read only users with the <command>read list</command> parameter.</para>
			<screen>
[authwrite2]
	path = /srv/samba/authwrite2
	comment = authenticated users only
	read only = No
	guest ok = No
	read list = Martina, Roberto
			</screen>
		</section>
	</section>
	<section><title>Practice</title>
		<para>0. Make sure you have properly named backups of your smb.conf of the previous practices.</para>
		<para>1. Create three users (on the Unix and on the Samba), remember their passwords!</para>
		<para>2. Set up a shared directory that is only accessible to authenticated users.</para>
		<para>3. Verify that files created by these users belong to them.</para>
		<para>4. Limit access to the sales share to Sandra, Ann and Veronique. Make sure that Roberto cannot access the share.</para>
		<para>5. Even though the share is writable, Ann should only have read access.</para>
		<para>6. Set the create mask for files to read and write for everyone, test that it works.</para>
		<para>7. Limit one shared directory to the 192.168.1.0/24 subnet, and another share to the two computers with ip-addresses 192.168.1.33 and 172.17.18.19.</para>
		<para>8. Make sure users can only see files and directories that they can read. Test that it works!!</para>
		<para>9. If time permits (or if you are waiting for other students to finish this practice), then combine the "read only" and "writable" statements to check which one has priority. Then combine them with "read list", "write list", "hosts allow" and "hosts deny". Then combine them with file permissions on the linux filesystem (chmod,chown) and make a table of minimal mandatory settings for readonly/readwrite shared directories.</para>
	</section>
</chapter>
<chapter><title>Samba Domain Member Server</title>
	<section><title>smb.conf</title>
		<para>The <command>workgroup</command> option in the global section should match the netbios name of the Active Directory domain. Authentication will not be handled by Samba now, but by the Active Directory Domain Controllers, so we set the <command>security</command> option to domain. Since linux requires a user account for every user accessing its file system, we need to provide Samba with a range of uid's and gid's that it can use to create these user accounts. The first Active Directory user to connect will receive linux uid 20000. Below is our new global section in smb.conf.</para>
		<screen>
[global]
	workgroup = PEGASUS
	server string = Pegasus Domain Member Server
	security = Domain
	idmap uid = 20000-22000
	idmap gid = 20000-22000
	winbindd use default domain = Yes
		</screen>
		<para>Nothing special is required for the share section in smb.conf. Remember, we do not manually create users in smbpasswd or on the linux (/etc/passwd). Only Active Directory users are allowed access.</para>
		<screen>
[domaindata]
	path = /srv/samba/domaindata
	comment = Active Directory users only
	read only = No
		</screen>
	</section>
	<section><title>Joining the Active Directory Domain</title>
		<para>While the Samba server is stopped, you can use <command>net rpc join</command> to join the Active Directory Domain.</para>
		<screen>
[root@RHEL4b samba]# net rpc join -UAdministrator%Stargate1
Joined domain PEGASUS.
[root@RHEL4b samba]# 
		</screen>
		<para>Time to start Samba followed by <command>winbindd</command>.</para>
		<screen>
[root@RHEL4b samba]# service smb start
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]
[root@RHEL4b samba]# service winbindd start
Starting winbindd services:                                [  OK  ]
[root@RHEL4b samba]# 
		</screen>
	</section>
	<section><title>nsswitch.conf</title>
		<para>We need to update the <command>/etc/nsswitch.conf</command> file now, so user group and host names can be resolved against the winbindd daemon.</para>
		<screen>
[root@RHEL4b samba]# vi /etc/nsswitch.conf 
[root@RHEL4b samba]# grep winbindd /etc/nsswitch.conf 
passwd:     files winbindd
group:      files winbindd
hosts:      files dns winbindd
[root@RHEL4b samba]#
		</screen>
	</section>
	<section><title>winbindd</title>
		<para>The <command>winbindd</command> daemon is talking with the Active Directory domain. With <command>wbinfo</command> you can provide winbindd with credentials to talk to Active Directory.</para>
		<screen>[root@RHEL4b samba]# wbinfo --set-auth-user=Administrator%Stargate1</screen>
		<para>We can also use <command>wbinfo -a</command> to verify authentication of a user against Active Directory. Assuming a user account Venus with password VenusW is just created on the Active Directory, we get the following screenshot. </para>
		<screen>
[root@RHEL4b samba]# wbinfo -a Venus%VenusW
plaintext password authentication succeeded
challenge/response password authentication succeeded
[root@RHEL4b samba]# 
		</screen>
		<para>We can use <command>getent</command> to verify that winbindd is working and actually adding the Active directory users to /etc/passwd. The screenshot below shows that Kim and Serena are normal linux users in /etc/passwd, and that the Active Directory user Venus received uid 20000 in /etc/passwd.</para>
		<screen>
[root@RHEL4b samba]# getent passwd Kim
Kim:x:504:504:Kim Clijsters:/home/Kim:/bin/bash
[root@RHEL4b samba]# getent passwd Serena
Serena:x:503:503:Serena Williams:/home/Serena:/bin/bash
[root@RHEL4b samba]# getent passwd Venus
venus:*:20000:20000::/home/PEGASUS/venus:/bin/false
		</screen>
		<para>Not all Active Directory user accounts added to /etc/passwd by winbindd, only those that have been used.</para>
		<screen>
[root@RHEL4b samba]# getent passwd Justine
[root@RHEL4b samba]# wbinfo -a Justine%JustineH
plaintext password authentication succeeded
challenge/response password authentication succeeded
[root@RHEL4b samba]# getent passwd Justine
justine:*:20001:20000::/home/PEGASUS/justine:/bin/false
[root@RHEL4b samba]#
		</screen>
		<para>All the Active Directory users can now easily connect to the Samba share. Files created by them, belong to them. </para>
		<screen>
[root@RHEL4b samba]# ll /srv/samba/domaindata/
total 0
-rwxr--r--  1 justine 20000 0 Jun 22 19:54 created_by_justine_on_winxp.txt
-rwxr--r--  1 venus   20000 0 Jun 22 19:55 created_by_venus.txt
-rwxr--r--  1 maria   20000 0 Jun 22 19:57 Maria.txt
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Verify that you have a working Active Directory (AD) domain.</para>
		<para>2. Setup Samba as a member server in the domain.</para>
		<para>3. Verify the creation of a computer account in AD for your Samba server.</para>
		<para>4. Verify the automatic creation of AD users in /etc/passwd with wbinfo and getent.</para>
		<para>5. Connect to Samba shares with AD users, and verify ownership of their files.</para>
	</section>
</chapter>
<chapter><title>Samba Domain Controller</title>
	<section><title>About Domain Controllers</title>
		<section><title>Samba 3</title>
			<para>Samba 3 can act as a domain controller in its own domain. In a Windows NT4 domain, with one Windows NT4 PDC and zero or more BDC's, Samba 3 can only be a member server. The same is valid for Samba 3 in an Active Directory Domain with Windows 2000 and/or Windows 2003 DC's. In short, a Samba 3 domain controller can not share domain control with Windows domain controllers.</para>
		</section>
		<section><title>Samba 4</title>
			<para>Samba 4 can be a domain Controller in an Active Directory domain, but as of this writing, Samba 4 is not released for production!</para>
		</section>
		<section><title>About password backends</title>
			<para>The example below uses the <command>tdbsam</command> password backend. Another option would be to use LDAP. Larger domains will benefit from using LDAP instead of the not so scalable tdbsam. When you need more than one Domain Controller, then the Samba team advises to not use tdbsam.</para>
		</section>
	</section>
	<section><title>smb.conf</title>
		<para>Now is a good time to start adding comments in your smb.conf. First we'll take a look at the naming of our domain and server in the <command>[global]</command> section, and at the domain controlling parameters. The security must be set to user (which is the default). Our Samba server is the most stable system in the network, so it should win all browser elections (<command>os level</command> above 32) to become the <command>browser master</command>, and it should accept domain logons (<command>domain logons = Yes</command>).</para>
		<screen>
[global]
# names
	workgroup = SPORTS
	netbios name = DCSPORTS
	server string = Sports Domain Controller
# domain control parameters
	security = user
	os level = 80
	preferred master = Yes
	domain master = Yes
	domain logons = Yes
		</screen>
		<para>Then we create some sections for file shares, to test our Samba server. Users can all access the general sports file share, but only group members can access their own sport share.</para>
		<screen>
[sports]
comment = Information about all sports
path = /srv/samba/sports
valid users = @ntsports
read only = No

[tennis]
comment = Information about tennis
path = /srv/samba/tennis
valid users = @nttennis
read only = No

[football]
comment = Information about football
path = /srv/samba/football
valid users = @ntfootball
read only = No
		</screen>
		<para>Part of the Microsoft definition of a domain controller is that it should have a <command>netlogon share</command>. This is the relevant part of smb.conf to create this netlogon share on Samba.</para>
		<screen>
[netlogon]
comment = Network Logon Service
path = /srv/samba/netlogon
admin users = root
guest ok = Yes
browseable = No
		</screen>
	</section>
	<section><title>Users and Groups</title>
		<para>To be able to use users and groups in Samba, we have to set up some users and groups on the Linux computer.</para>
		<screen>
[root@RHEL4b samba]# groupadd ntadmins
[root@RHEL4b samba]# groupadd ntsports
[root@RHEL4b samba]# groupadd nttennis
[root@RHEL4b samba]# groupadd ntfootball
[root@RHEL4b samba]# useradd -m -G ntadmins -p Stargate1 Administrator
[root@RHEL4b samba]# useradd -m -G ntsports,nttennis -p stargate Venus
[root@RHEL4b samba]# useradd -m -G ntsports,nttennis -p stargate Serena
[root@RHEL4b samba]# useradd -m -G ntsports,nttennis -p stargate Kim
[root@RHEL4b samba]# useradd -m -G ntsports,ntfootball -p stargate Figo
[root@RHEL4b samba]# useradd -m -G ntsports,ntfootball -p stargate Pfaff
		</screen>
		<para>Next we must make these users known to Samba with the smbpasswd tool. When you add the first user to <command>tdbsam</command>, the file <command>/etc/samba/passdb.tdb</command> will be created.</para>
		<screen>
[root@RHEL4b samba]# smbpasswd -a Administrator
New SMB password:
Retype new SMB password:
Unable to open/create TDB passwd
pdb_getsampwnam: Unable to open TDB passwd (/etc/samba/passdb.tdb)!
TDBSAM version too old (0), trying to convert it.
TDBSAM converted successfully.
Added user Administrator.
[root@RHEL4b samba]#
		</screen>
		<para>Adding the second user generates less output.</para>
		<screen>
[root@RHEL4b samba]# smbpasswd -a root
New SMB password:
Retype new SMB password:
Added user root.
		</screen>
	</section>
	<section><title>About Computer Accounts</title>
		<para>Every NT computer (Windows NT, 2000, XP, Vista) can become a member of a domain. Joining the domain (by right-clicking on My Computer) means that a computer account will be created in the domain. This computer account also has a password (but you cannot know it) to prevent other computers with the same name from accidentally becoming member of the domain. The computer account created by Samba is visible in the <command>/etc/passwd</command> file on linux. Computer accounts appear as a normal user account, but end their name with a dollar sign. Below a screenshot of the winxp$ computer account, created by Samba 3.</para>
		<screen>
[root@RHEL4b samba]# tail -5 /etc/passwd
Serena:x:508:512::/home/Serena:/bin/bash
Kim:x:509:513::/home/Kim:/bin/bash
Figo:x:510:514::/home/Figo:/bin/bash
Pfaff:x:511:515::/home/Pfaff:/bin/bash
winxp$:x:512:516::/home/nobody:/bin/false
		</screen>
		<para>To be able to create the account, you will need to provide credentials of an account with the permission to create accounts (by default only root can do this on Linux). And we will have to tell Samba how to to this, by adding an <command>add machine script</command> to the global section of smb.conf.</para>
		<screen>add machine script = /usr/sbin/useradd -s /bin/false -d /home/nobody %u</screen>
		<para>You can now join a Microsoft computer to the sports domain (with the root user). After reboot of the Microsoft computer, you will be able to logon with Administrator (password Stargate1), but you will get an error about your roaming profile. We will fix this in the next section.</para>
	</section>
	<section><title>Roaming Profiles</title>
		<para>For your information, if you want to force local profiles instead of roaming profiles, then simply add the following two lines to the global section in smb.conf.</para>
		<screen>
logon home =
logon path =
		</screen>
		<para>Microsoft computers store a lot of User Metadata and application data in a user profile. Making this profile available on the network will enable users to keep their Desktop and Application settings across computers. User profiles on the network are called <command>roaming profiles</command> or <command>roving profiles</command>. The Samba domain controller can manage these profiles. First we need to add the relevant section in smb.conf.</para>
		<screen>
[Profiles]
	comment = User Profiles
	path = /srv/samba/profiles
	readonly = No
	profile acls = Yes
		</screen>
		<para>Besides the share section, we also need to set the location of the profiles share (this can be another Samba server) in the global section.</para>
		<screen> logon path = \\%L\Profiles\%U</screen>
		<para>The <command>&#037;L</command> variable is the name of this Samba server, the <command>&#037;U</command> variable translates to the username. After adding a user to smbpasswd and letting the user log on and off, the profile of the user will look like this.</para>
		<screen>
[root@RHEL4b samba]# ll /srv/samba/profiles/Venus/
total 568
drwxr-xr-x  4 Venus Venus   4096 Jul  5 10:03 Application Data
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 Cookies
drwxr-xr-x  3 Venus Venus   4096 Jul  5 10:03 Desktop
drwxr-xr-x  3 Venus Venus   4096 Jul  5 10:03 Favorites
drwxr-xr-x  4 Venus Venus   4096 Jul  5 10:03 My Documents
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 NetHood
-rwxr--r--  1 Venus Venus 524288 Jul  5  2007 NTUSER.DAT
-rwxr--r--  1 Venus Venus   1024 Jul  5  2007 NTUSER.DAT.LOG
-rw-r--r--  1 Venus Venus    268 Jul  5 10:03 ntuser.ini
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 PrintHood
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 Recent
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 SendTo
drwxr-xr-x  3 Venus Venus   4096 Jul  5 10:03 Start Menu
drwxr-xr-x  2 Venus Venus   4096 Jul  5 10:03 Templates
[root@RHEL4b samba]# 
		</screen>
	</section>
	<section><title>Groups in NTFS acls</title>
		<para>We have users on Unix, we have groups on Unix that contain those users.</para>
		<screen>
[root@RHEL4b samba]# grep nt /etc/group
...
ntadmins:x:506:Administrator
ntsports:x:507:Venus,Serena,Kim,Figo,Pfaff
nttennis:x:508:Venus,Serena,Kim
ntfootball:x:509:Figo,Pfaff
[root@RHEL4b samba]# 
		</screen>
		<para>We already added Venus to the <command>tdbsam</command> with <command>smbpasswd</command>.</para>
		<screen>smbpasswd -a Venus</screen>
		<para>Does this mean that Venus can access the tennis and the sports shares ? Yes, all access works fine on the Samba server. But the nttennis group is not available on the windows machines. To make the groups available on windows (like in the ntfs security tab of files and folders), we have to map unix groups to windows groups. To do this, we use the <command>net groupmap</command> command.</para>
		<screen>
[root@RHEL4b samba]# net groupmap add ntgroup="tennis" unixgroup=nttennis type=d
No rid or sid specified, choosing algorithmic mapping
Successully added group tennis to the mapping db
[root@RHEL4b samba]# net groupmap add ntgroup="football" unixgroup=ntfootball type=d
No rid or sid specified, choosing algorithmic mapping
Successully added group football to the mapping db
[root@RHEL4b samba]# net groupmap add ntgroup="sports" unixgroup=ntsports type=d
No rid or sid specified, choosing algorithmic mapping
Successully added group sports to the mapping db
[root@RHEL4b samba]# 
		</screen>
		<para>Now you can use the Samba groups on all NTFS volumes on members of the domain.</para>
	</section>
	<section><title>logon scripts</title>
	<para>Before testing a logon script, make sure it has the proper carriage returns that DOS files have.</para>
	<screen>
[root@RHEL4b netlogon]# cat start.bat 
net use Z: \\DCSPORTS0\SPORTS
[root@RHEL4b netlogon]# unix2dos start.bat 
unix2dos: converting file start.bat to DOS format ...
[root@RHEL4b netlogon]# 
	</screen>
	<para>Then copy the scripts to the netlogon share, and add the following parameter to smb.conf.</para>
	<screen>logon script = start.bat</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Setup Samba as a domain controller.</para>
		<para>2. Create the shares salesdata, salespresentations and meetings. Salesdata must be accessible to all sales people and to all managers. SalesPresentations is only for all sales people. Meetings is only accessible to all managers. Use groups to accomplish this.</para>
		<para>3. Join a Microsoft computer to your domain. Verify the creation of a computer account in /etc/passwd.</para>
		<para>4. Setup and verify the proper working of roaming profiles.</para>
		<para>5. Find information about home directories for users, set them up and verify that users receive their home directory mapped under the H:-drive in MS Windows Explorer.</para>
		<para>6. Use a couple of samba domain groups with members to set acls on ntfs. Verify that it works!</para>
		<para>7. Knowing that the &#037;m variable contains the computername, create a seperate log file for every computer(account).</para>
		<para>8. Knowing that &#037;s contains the client operating system, include a smb.&#037;s.conf file that contains a share. (The share will only be visible to clients with that OS).</para>
		<para>9. If time permits (or if you are waiting for other students to finish this practice), then combine "valid users" and "invalid users" with groups and usernames with "hosts allow" and "hosts deny" and make a table of which get priority over which.</para>
	</section>
</chapter>
<chapter><title>Samba Print Servers</title>
	<section><title>Simple CUPS Print Server</title>
		<para>Let us start by setting up a Samba print server that serves two printers which are set up with the CUPS web interface (http://localhost:631). We make these printers available to everyone for printing. We set up the CUPS printers without a driver (raw printing device). The <command>lpstat</command> tool will see the printers like this.</para>
		<screen>
[root@RHEL4b samba]# lpstat -t
scheduler is running
system default destination: HPColor
device for HPBlack: socket://192.168.1.244:9100
device for HPColor: parallel:/dev/lp0
HPBlack accepting requests since Jan 01 00:00
HPColor accepting requests since Jan 01 00:00
printer HPBlack is idle.  enabled since Jan 01 00:00
printer HPColor is idle.  enabled since Jan 01 00:00
		</screen>
		<para>The windows clients need to install the correct printer driver themselves, so the spooler just sends the jobs to the print device (without any kind of processing or interpreting of the print jobs). Our smb.conf looks like this.</para>
		<screen>
[global]
	server string = Public Anonymous Print Server
	security = share
	disable spoolss = No
	printing = cups

[printers]
	path = /var/spool/samba
	read only = Yes
	printable = Yes
	use client driver = Yes
		</screen>
		<para>Let's do a quick check with smbclient.</para>
		<screen>
[root@RHEL4b samba]# smbclient -NL 127.0.0.1
Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.0.10-1.4E.9]

Sharename       Type      Comment
---------       ----      -------
IPC$            IPC       IPC Service (Public Anonymous Print Server)
ADMIN$          IPC       IPC Service (Public Anonymous Print Server)
HPBlack         Printer   Local Raw Printer
HPColor         Printer   Local Raw Printer
...
		</screen>
		<para>That looks ok. Now you can add the printer to windows computers in the workgroup, just browse to your Samba server in the add printer wizard. Or you can connect with the <command>net use</command> command as shown below.</para>
		<screen>
C:\shov&#062;net use lpt1: \\rhel4b\HPColor
The command completed successfully.

C:\shov&#062;net use
New connections will be remembered.


Status       Local     Remote                    Network

-------------------------------------------------------------------------------
OK           LPT1      \\rhel4b\HPColor          Microsoft Windows Network
The command completed successfully.

C:\shov&#062;print shovel.bat
C:\shov\shovel.bat is currently being printed
		</screen>
		<para>After printing a test page (by rightclicking on the printer icon in windows and then clicking on the print test page button of the properties dialog box) and issuing the print command from within Firefox, the print queue looks like this.</para>
		<screen>
[root@RHEL4b samba]# lpq -a
Rank    Owner   Job     File(s)                         Total Size
active  nobody  4       smbprn.00000001 Test Page       112640 bytes
1st     nobody  5       smbprn.00000002 Mozilla Firefox 120832 bytes
		</screen>
		<para>For troubleshooting, it can be useful to stop (pause) the printer. This way the jobs stay in the queue.</para>
		<screen>
[root@RHEL4b samba]# lpstat -t
scheduler is running
system default destination: HPColor
device for HPBlack: socket://192.168.1.244:9100
device for HPColor: parallel:/dev/lp0
HPBlack accepting requests since Jan 01 00:00
HPColor accepting requests since Jan 01 00:00
printer HPBlack disabled since Jan 01 00:00 -
Paused
printer HPColor is idle.  enabled since Jan 01 00:00
HPBlack-4           nobody       112640   Sat 07 Jul 2007 07:59:33 AM CEST
HPBlack-5           nobody       120832   Sat 07 Jul 2007 08:00:04 AM CEST
		</screen>
	</section>
	<section><title>Simple BSD Print Server</title>
		<para>The default BSD style print commands (also refered to as LPD/LPR) are defined in rfc 1179. The smb.conf file is similar to the one for CUPS printing, except that CUPS is the default. The file now looks like this.</para>
		<screen>
[global]
	server string = Public Anonymous Print Server
	printing = bsd
	load printers = yes

[printers]
	path = /var/spool/samba
	writable = no
	printable = Yes
	public = yes
		</screen>
		<para>Testparm however gives us some more information on values used for the print commands.</para>
		<screen>
[root@RHEL4b samba]# testparm 
Load smb config files from /etc/samba/smb.conf
Processing section "[printers]"
Loaded services file OK.
Server role: ROLE_STANDALONE
Press enter to see a dump of your service definitions
	
# Global parameters
[global]
	server string = Public Anonymous Print Server
	printing = bsd
	print command = lpr -r -P'&#037;p' &#037;s
	lpq command = lpq -P'&#037;p'
	lprm command = lprm -P'&#037;p' &#037;j

[printers]
	path = /var/spool/samba
	guest ok = Yes
	printable = Yes
	browseable = No
[root@RHEL4b samba]# 
		</screen>
	</section>
	<section><title>Simple Unix SysV Print Server</title>
		<para>SystemV style printing uses the lp command in this form.</para>
		<screen>lp -dprinter -s file</screen>
		<para>Since by default this command does not remove the file, we have to add this removal to smb.conf. So here is a simple smb.conf to share Unix System V type printers with Samba.</para>
		<screen>
[global]
	server string = Public Anonymous Print Server
	printing = sysv
	load printers = yes
	
[printers]
	path = /var/spool/samba
	writable = no
	printable = Yes
	public = yes
	print command = lp -d&#037;p -s &#037;s ; rm &#037;s
		</screen>
	</section>	
	<section><title>Samba Prining tips</title>
		<para>The <command>printable = Yes</command> line must always be present in Samba printer shares, even in the <command>[printers]</command> section. It is also important to have a naming convention that prevents printers from having the same name as users. The <command>[homes]</command> section automatically creates a share for each user with that username, so it cannot be also a printer share. </para>
		<para>To troubleshoot the print command, you can da a little trick in smb.conf. Instead of the actual print command, construct the printers section in smb.conf like this.</para>
		<screen>
[printers]
	path = /var/spool/samba
	writable = no
	printable = Yes
	public = yes
	print command = echo "lpr -r -P'%p' %s" >> /tmp/bsdprint.log
		</screen>
		<para>Nothing will be printed, but you can test the print command that is generated by Samba. In this case, the log file looks like this.</para>
		<screen>
[root@RHEL4b samba]# cat /tmp/bsdprint.log
lpr -r -P'HP400' smbprn.00000012.ARQtkM
lpr -r -P'HP400' smbprn.00000013.YbFkuN
lpr -r -P'HP400' smbprn.00000017.NeDuGj
[root@RHEL4b samba]# 
		</screen>
		<para>Here is a list variables that are used by Samba for printing.</para>
		<screen>
&#037;s	filename with path (of the file to be printed)
&#037;f filename without path
&#037;p name of the destination unix printer
&#037;j	print job number	
		</screen>
	</section>
	<section><title>Practice</title>
		<para>1. Create two printers (with lpadmin or with the cups web interface) and pause(stop) them.</para>
		<para>2. Serve these printers with Samba. Connect with a Microsoft computer and test printing.</para>
		<para>3. Make sure only Isabelle and Caroline can access one of the printers.</para>
		<para>4. Make sure they have to be on the 10.5.0.0/16 subnet to access the printer.</para>
		<para>5. If time permits... There are some issues with a BSD printer. Your manager asks you to log the lpr command syntax, its stdout and its stderr to three different files.</para>
	</section>
</chapter>
<chapter><title>Apache</title>
	<section><title>About</title>
		<para>According to NetCraft (http://news.netcraft.com/archives/web_server_survey.html) about seventy percent of all web servers are running on Apache. Some people say that the name is derived from <command>a patchy</command> web server, because of all the patches people wrote for the NCSA httpd server.</para>
		<para>To verify whether Apache is installed, use the proper tools (rpm, dpkg, ...) and grep for apache or httpd.</para>
		<screen>
[paul@rhel4 ~]$ rpm -qa | grep -i httpd
httpd-2.0.52-25.ent
httpd-manual-2.0.52-25.ent
system-config-httpd-1.3.1-1
httpd-devel-2.0.52-25.ent
httpd-suexec-2.0.52-25.ent
		</screen>
		<screen>
paul@laika:~$ dpkg -l | grep apache
ii  apache2                  2.2.3-3.2build1      Next generation, scalable, ...
ii  apache2-mpm-prefork      2.2.3-3.2build1      Traditional model for Apach...
ii  apache2-utils            2.2.3-3.2build1      utility programs for webser...
ii  apache2.2-common         2.2.3-3.2build1      Next generation, scalable, ...
ii  libapache2-mod-php5      5.2.1-0ubuntu1.2     server-side, HTML-embedded ...
		</screen>
		<para>This is how apache looks when it is installed on Red Hat Enterprise Linux 4, running named as <command>httpd</command>.</para>
		<screen>
[root@RHELv4u3 ~]# /etc/init.d/httpd status
httpd is stopped
[root@RHELv4u3 ~]# service httpd start
Starting httpd:                                            [  OK  ]
[root@RHELv4u3 ~]# ps -C httpd
PID TTY          TIME CMD
4573 ?        00:00:00 httpd
4576 ?        00:00:00 httpd
4577 ?        00:00:00 httpd
4578 ?        00:00:00 httpd
4579 ?        00:00:00 httpd
4580 ?        00:00:00 httpd
4581 ?        00:00:00 httpd
4582 ?        00:00:00 httpd
4583 ?        00:00:00 httpd
[root@RHELv4u3 ~]#
		</screen>
		<para>And here is Apache running on Ubuntu Feisty Fawn, named as <command>apache2</command>.</para>
		<screen>
root@laika:~# ps -C apache2
PID TTY          TIME CMD
6170 ?        00:00:00 apache2
6248 ?        00:00:01 apache2
6249 ?        00:00:01 apache2
6250 ?        00:00:00 apache2
6251 ?        00:00:01 apache2
6252 ?        00:00:01 apache2
7520 ?        00:00:01 apache2
8943 ?        00:00:01 apache2
root@laika:~# /etc/init.d/apache2 status
* Usage: /etc/init.d/apache2 {start|stop|restart|reload|force-reload}
root@laika:~# 
		</screen>
		<para>To verify that apache is running, open a web browser on the web server, and browse to http://localhost. An Apache test page should be shown. The http://localhosts/manual url will give you an extensive Apache manual. The second test is to connect to your Apache from another computer.</para>
	</section>
	<section><title>Apache configuration</title>
		<para>Configuring Apache changed a bit the past couple of years. But it still takes place in <command>/etc/httpd</command> or <command>/etc/apache</command>.</para>
		<screen>
[root@RHELv4u3 ~]# cd /etc/httpd/
[root@RHELv4u3 httpd]# ll
total 32
lrwxrwxrwx  1 root root   25 Jan 24 09:28 build -> ../../usr/lib/httpd/build
drwxr-xr-x  7 root root 4096 Jan 24 08:48 conf
drwxr-xr-x  2 root root 4096 Jan 24 09:29 conf.d
lrwxrwxrwx  1 root root   19 Jan 24 08:48 logs -> ../../var/log/httpd
lrwxrwxrwx  1 root root   27 Jan 24 08:48 modules -> ../../usr/lib/httpd/modules
lrwxrwxrwx  1 root root   13 Jan 24 08:48 run -> ../../var/run
[root@RHELv4u3 httpd]#
		</screen>
		<para>The main configuration file for the Apache server on RHEL is <command>/etc/httpd/conf/httpd.conf</command>, on Ubuntu it is <command>/etc/apache2/apache2.conf</command>. The file explains itself, and contains examples for how to set up virtual hosts or configure access.</para>
	</section>
	<section><title>Virtual hosts</title>
		<para>Virtual hosts can be defined by ip-address, by port or by name (host record). (The new way of defining virtual hosts is through seperate config files in the conf.d directory.) Below is a very simple virtual host definition.</para>
		<screen>
[root@rhel4 conf]# tail /etc/httpd/conf/httpd.conf 
#
# This is a small test website
#
&#060;VirtualHost testsite.local:80&#062;
ServerAdmin webmaster@testsite.local
DocumentRoot /var/www/html/testsite/
ServerName testsite.local
ErrorLog logs/testsite.local-error_log
CustomLog logs/testsite.local-access_log common
&#060;/VirtualHost&#062;
[root@rhel4 conf]# 
		</screen>
		<para>Should you put this little index.html file in the directory mentioned in the above screenshot, then you can access this humble website.</para>
		<screen>
[root@rhel4 conf]# cat /var/www/html/testsite/index.html 
&#060;html&#062;
	&#060;head&#062;&#060;title>Test Site&#060;/title&#062;&#060;/head&#062;
	&#060;body&#062;
		&#060;p&#062;This is the test site.&#060;/p&#062;
	&#060;/body&#062;
&#060;/html&#062;
		</screen>
		<para>Below is a sample virtual host configuration. This virtual hosts overrules the default Apache <command>ErrorDocument</command> directive.</para>
		<screen>
&#060;VirtualHost 83.217.76.245:80&#062;
ServerName cobbaut.be
ServerAlias www.cobbaut.be
DocumentRoot /home/paul/public_html
ErrorLog /home/paul/logs/error_log
CustomLog /home/paul/logs/access_log common
ScriptAlias /cgi-bin/ /home/paul/cgi-bin/
&#060;Directory /home/paul/public_html&#062;
	Options Indexes IncludesNOEXEC FollowSymLinks
	allow from all
&#060;/Directory&#062;
ErrorDocument 404 http://www.cobbaut.be/cobbaut.php
&#060;/VirtualHost&#062;
		</screen>
	</section>
	<section><title>Aliases and redirects</title>
		<para>Apache supports aliases for directories, like this example shows.</para>
		<screen>Alias /paul/ "/home/paul/public_html/"</screen>
		<para>Similarly, content can be redirected to another website or web server.</para>
		<screen>Redirect permanent /foo http://www.foo.com/bar</screen>
	</section>
	<section><title>Securing directories with htpasswd and .htaccess</title>
		<para>You can secure files and directories in your website with a userid/password. First, enter your website, and use the <command>htpasswd</command> command to create a <command>.htpasswd file</command> that contains a userid and an (encrypted) password.</para>
		<screen>
		[root@rhel4 testsite]# htpasswd -c .htpasswd pol
		New password: 
		Re-type new password: 
		Adding password for user pol
		[root@rhel4 testsite]# cat .htpasswd 
		pol:x5vZlyw1V6KXE
		[root@rhel4 testsite]# 
		</screen>
		<para>You can add users to this file, just don't use the -c switch again.</para>
		<screen>
		[root@rhel4 testsite]# htpasswd .htpasswd kim
		New password: 
		Re-type new password: 
		Adding password for user kim
		[root@rhel4 testsite]# cat .htpasswd 
		pol:x5vZlyw1V6KXE
		kim:6/RbvugwsgOI6
		[root@rhel4 testsite]# 
		</screen>
		<para>You have now defined two users. Next create a subsdirectory that you want to protect with these two accounts. And put the following .htaccess file in that subdirectory.</para>
		<screen>
		[root@rhel4 kimonly]# pwd
		/var/www/html/testsite/kimonly
		[root@rhel4 kimonly]# cat .htaccess 
		AuthUserFile /var/www/html/testsite/.htpasswd
		AuthGroupFile /dev/null
		AuthName "test access title"
		AuthType Basic
		
		&#060;Limit GET POST&#062;
		require valid-user
		&#060;/Limit&#062;
		[root@rhel4 kimonly]# 
		</screen>
		<para>Finally, don't forget to verify that AllowOverride is set to All in the general Apache configuration file.</para>
		<screen>
		# AllowOverride controls what directives may be placed in .htaccess files.
		# It can be "All", "None", or any combination of the keywords:
		#   Options FileInfo AuthConfig Limit
		#
		AllowOverride All
		</screen>
		<para>From now on, when a user accesses a file in that subdirectory, that user will have to provide a userid/password combo that is defined in your .htpasswd.</para>
	</section>
	<section><title>more on .htaccess</title>
		<para>You can do much more with <command>.htaccess</command>. One example si to use .htaccess to prevent people from certain domains to access your website. Like in this case, where a number of referer spammers are blocked from the website.</para>
		<screen>
		paul@lounge:~/cobbaut.be$ cat .htaccess 
		# Options +FollowSymlinks
		RewriteEngine On
		RewriteCond &#037;{HTTP_REFERER} ^http://(www\.)?buy-adipex.fw.nu.*$ [OR]
		RewriteCond &#037;{HTTP_REFERER} ^http://(www\.)?buy-levitra.asso.ws.*$ [NC,OR]
		RewriteCond &#037;{HTTP_REFERER} ^http://(www\.)?buy-tramadol.fw.nu.*$ [NC,OR]
		RewriteCond &#037;{HTTP_REFERER} ^http://(www\.)?buy-viagra.lookin.at.*$ [NC,OR]
		...
		RewriteCond &#037;{HTTP_REFERER} ^http://(www\.)?www.healthinsurancehelp.net.*$ [NC]
		RewriteRule .* - [F,L]
		paul@lounge:~/cobbaut.be$ 
	</screen>
	</section>
	<section><title>Traffic</title>
		<para>Apache keeps a log of all visitors. The <command>webalizer</command> is often used to parse this log into nice html statistics.</para>
	</section>
	<section><title>Practice</title>
		<para>1. Verify that Apache is installed and running.</para>
		<para>2. Browse to the Apache HTML manual from another computer.</para>
		<para>3. Create a virtual hosts that listens to port 8247.</para>
		<para>4. Create a virtual hosts that listens on another ip-address.</para>
		<para>5. Test from another computer that all virtual hosts work.</para>
		<para>6. Protect a subdirectory of a website with .htpasswd and .htaccess.</para>
	</section>
</chapter>	
<chapter><title>MySQL</title>
	<section><title>About MySQL</title>
		<para>MySQL is a database server that understands Structured Query Laguage (SQL). It is developed by the Swedish Company <command>MySQL AB</command> (www.mysql.com). MySQL is very popular for websites in combination with PHP and Apache.</para>
	</section>
	<section><title>MySQL users and Groups</title>
		<para>The installation of MySQL creates a user account and a group account.</para>
		<screen>
# Linux laika 2.6.20-2-generic #3 SMP Sat Dec 16 07:43:26 UTC 2006 x86_64 GNU/Linux
root@laika:~# cat /etc/passwd | grep -i sql
mysql:x:109:115:MySQL Server,,,:/var/lib/mysql:/bin/false
root@laika:~# cat /etc/group | grep -i sql
mysql:x:115:
		</screen>
		<screen>
# Linux barry 2.6.17-2-686 #1 SMP Wed Sep 13 16:34:10 UTC 2006 i686 GNU/Linux
paul@barry:~$ grep mysql /etc/passwd
mysql:x:103:105:MySQL Server,,,:/var/lib/mysql:/bin/false
paul@barry:~$ grep mysql /etc/group
mysql:x:105:
		</screen>
	</section>
	<section><title>Creating a MySQL root user</title>
		<para>With the <command>mysqladmin</command> command you can create a root user to administer your MySQL. It is advised to use a different password than the one for your Unix root account. After doing this, any user can issue MySQL root commands using the <command>-u root</command> argument on the commandline.</para>
		<screen>root@laika:~# mysqladmin -u root password SecretPass</screen>
		<para>You can now use mysql from the commandline by just typing <command>mysql -u root -p</command> and it will ask you for the password (of the mysql root account). You can create a personal mysql configuration file and put the password inthere, so you don't have to type it every time. In the screenshot below, the MySQL Welcome message is cut.</para>
		<screen>
# Linux barry 2.6.17-2-686 #1 SMP Wed Sep 13 16:34:10 UTC 2006 i686 GNU/Linux
paul@barry:~$ mysql -u root -p
Enter password:
&#060;cut MySQL Welcome Message&#062;
mysql&#062; exit
Bye
paul@barry:~$ mysql -u root -pSecretPass
&#060;cut MySQL Welcome Message&#062;
mysql&#062; exit
Bye
paul@barry:~$ 
		</screen>
	</section>
	<section><title>~/.my.cnf</title>
		<para>You can keep some MySQL private configuration in your home directory in the hidden file <command>.my.cnf</command>. In the screenshot below we put the root password in .my.cnf.</para>
		<screen>
paul@barry:~$ echo "[client]" &#062; .my.cnf
paul@barry:~$ echo password=SecretPass &#062;&#062; .my.cnf
paul@barry:~$ cat .my.cnf
[client]
password=SecretPass
paul@barry:~$ mysql -u root
&#060;cut MySQL Welcome Message&#062;
mysql&#062;
		</screen>
		<para>To give everyone access to a mysql database, use the <command>GRANT</command> command.</para>
		<screen>
mysql&#062; GRANT ALL ON wikidb.* to wikiuser@localhost IDENTIFIED BY "wikipass";
Query OK, 0 rows affected (0.03 sec)
		</screen>
	</section>
	<section><title>Mediawiki backup and restore</title>
		<para>Mediawiki wikis can use MySQL as a database. To copy a wiki to another server, first take backup of the wikidb, then take backup of /var/lib/mediawiki-1.7/LocalSettings.php and /var/lib/mediawiki-1.7/upload/*. On the other machine, recreate the wikidb, and restore the access of the wikiuser. Restore the backup of wikidb, and restore the copied /var/lib/... files. Restore ownership and rights of these files.</para>
	</section>
	<section><title>Backup and restore of MySQL database</title>
		<para>You can take a backup of a database, or move it to another computer using the <command>mysql</command> and <command>mysqldump</command> commands. In the screenshot below, i take a backup of the wikidb database on the computer named laika. Then i ssh to another computer named barry and copy (with scp) the backup to barry. Then i restore the backup of wikidb on barry.</para>
		<screen>
paul@laika:~$ mysqldump -u root wikidb &#062; wikidb_backup_20070101.sql
paul@laika:~$ ssh barry
paul@barry:~$ scp laika:~/wikidb_backup_20070101.sql .
wikidb_backup_20070101.sql                      100% 1629KB 542.9KB/s   00:03    
paul@barry:~$ mysql -u root wikidb &#060; wikidb_backup_20070101.sql
paul@barry:~$ 
		</screen>
	</section>
	<section><title>Looking at databases and tables</title>
		<para>You can use the <command>mysql</command> command to take a look at the databases, and to execute SQL queries on them. The screenshots below show you how. First, let's logon to our MySQL server and execute the commands <command>show databases;</command> and <command>use wikidb;</command>. This gives us a list of all databases on the server.</para>
		<screen>
paul@barry:~$ mysql -u root
...
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema | 
| mysql              | 
| wikidb             | 
+--------------------+
3 rows in set (0.01 sec)
		</screen>
		<para> This makes the wikidb database the current db in use.</para>
		<screen>
mysql> use wikidb;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
		</screen>
		<para>You can see a list of tables in the wikidb with the <command>show tables;</command> command.</para>
		<screen>
mysql> show tables;
+------------------+
| Tables_in_wikidb |
+------------------+
| archive          | 
| categorylinks    | 
| externallinks    | 
| filearchive      | 
| hitcounter       | 
| image            | 
| imagelinks       | 
...
31 rows in set (0.00 sec)
		</screen>
		<para>To see a description of the structure of a table, issue the <command>describe $tablename</command> command as shown below.</para>
		<screen>
mysql> describe externallinks;
+----------+-----------------+------+-----+---------+-------+
| Field    | Type            | Null | Key | Default | Extra |
+----------+-----------------+------+-----+---------+-------+
| el_from  | int(8) unsigned | NO   | MUL | 0       |       | 
| el_to    | blob            | NO   | MUL |         |       | 
| el_index | blob            | NO   | MUL |         |       | 
+----------+-----------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
		</screen>
		<para>And finally an example of a simple <command>select</command> query to look at the contents of a table.</para>
		<screen>
mysql> select * from externallinks;
+---------+--------------------------------------------+---------------------------------------------+
| el_from | el_to                                      | el_index                                    |
+---------+--------------------------------------------+---------------------------------------------+
|    1405 | http://www.mediawiki.org/wiki/Help:FAQ     | http://org.mediawiki.www./wiki/Help:FAQ     | 
|       1 | http://www.xkcd.com/c196.html              | http://com.xkcd.www./c196.html              | 
|       1 | http://www.xkcd.com/c178.html              | http://com.xkcd.www./c178.html              | 
|       1 | http://www.xkcd.com/c149.html              | http://com.xkcd.www./c149.html              | 
+---------+--------------------------------------------+---------------------------------------------+
7 rows in set (0.00 sec)
		</screen>
		<para>Type <command>exit;</command> to get back to your Linux command prompt.</para>
		<screen>
	mysql> exit
	Bye
	paul@barry:~$ 
		</screen>
	</section>
	<section><title>Creating a table</title>
		<para>Let us walk through the creation of a simple table. First enter the mysql prompt. On Red Hat, root has default access to mysql.</para>
		<screen>
[root@RHELv4u3 ~]# mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2 to server version: 4.1.12
		
Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
		</screen>
		<para>There are only two databases defined, let us use the test database.</para>
		<screen>
mysql> show databases;
+----------+
| Database |
+----------+
| mysql    |
| test     |
+----------+
2 rows in set (0.01 sec)

mysql> use test
Database changed
		</screen>
		<para>There are no tables yet in the test database.</para>
		<screen>
mysql> show tables;
Empty set (0.00 sec)
		</screen>
		<para>So we create a table with four records, the first one being the primary key.</para>
		<screen>
mysql> create table dieren (
-> id varchar(4) NOT NULL default '',
-> soort enum('reu','teef','kater','kattin') default NULL,
-> naam varchar(12) default NULL,
-> ras varchar(20) default NULL,
-> PRIMARY KEY  (id)
-> );
Query OK, 0 rows affected (0.01 sec)
		</screen>
		<para>Verify the creation of the table</para>
		<screen>
mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| dieren         |
+----------------+
1 row in set (0.00 sec)

mysql> describe dieren;
+-------+-------------------------------------+------+-----+---------+-------+
| Field | Type                                | Null | Key | Default | Extra |
+-------+-------------------------------------+------+-----+---------+-------+
| id    | varchar(4)                          |      | PRI |         |       |
| soort | enum('reu','teef','kater','kattin') | YES  |     | NULL    |       |
| naam  | varchar(12)                         | YES  |     | NULL    |       |
| ras   | varchar(20)                         | YES  |     | NULL    |       |
+-------+-------------------------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql> 
		</screen>
	</section>
	<section><title>Populating a table</title>
		<para>Use <command>INSERT</command> to enter data into the table.</para>
		<screen>
mysql> INSERT INTO dieren VALUES ('h17','reu','Pasha','Rottweiler x Pitbull');
Query OK, 1 row affected (0.01 sec)
		</screen>
		<para>And use <command>SELECT</command> to query the table.</para>
		<screen>
mysql> select * from dieren;
+-----+-------+-------+----------------------+
| id  | soort | naam  | ras                  |
+-----+-------+-------+----------------------+
| h17 | reu   | Pasha | Rottweiler x Pitbull |
+-----+-------+-------+----------------------+
1 row in set (0.00 sec)
		
mysql> select soort,ras from dieren where id='h17';
+-------+----------------------+
| soort | ras                  |
+-------+----------------------+
| reu   | Rottweiler x Pitbull |
+-------+----------------------+
1 row in set (0.01 sec)
		
mysql> 
		</screen>
	</section>
	<section><title>Scripting mysql in bash</title>
		<para>Using the -e option of the mysql command, you can script mysql commands in bash.</para>
		<screen>
paul@laika:~$ mysql -uwikiuser -pwikipass -e"show databases"
+--------------------+
| Database           |
+--------------------+
| information_schema | 
| wikidb             | 
+--------------------+
paul@laika:~$ 
		</screen>
		<screen>
[root@RHELv4u3 ~]# mysql -e"use test;select soort,ras from dieren where id='h17';"
+-------+----------------------+
| soort | ras                  |
+-------+----------------------+
| reu   | Rottweiler x Pitbull |
+-------+----------------------+
[root@RHELv4u3 ~]#
		</screen>
	</section>
</chapter>
<appendix><title>Shell shoveling wth netcat</title>
<para>Netcat can be used for a lot of things. This appendix explains how <command>netcat</command> can deliver a Microsoft Windows XP command prompt in bash. Hackers call this technique <command>shell shoveling</command>.</para>

<para>Start on the Microsoft Windows XP computer by downloading netcat for windows NT from <command>www.vulnwatch.org/netcat/</command> and extract only the <command>nc.exe</command> file to your XP home directory. Then execute the following command to start listening for a netcat client.</para>
<screen>C:\Documents and Settings\paul>nc -l -p 500 -e cmd.exe</screen>

<para>Now issue the following command on your linux computer to shovel a cmd.exe prompt. Replace 192.168.1.48 with the ip-address of the target machine.</para>

<screen>
paul@laika:~$ nc 192.168.1.48 500
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
	
C:\Documents and Settings\paul&#062;dir
dir
Volume in drive C has no label.
Volume Serial Number is A402-2699
	
Directory of C:\Documents and Settings\paul
	
06/19/2007  04:48 PM    &#060;DIR&#062;          .
06/19/2007  04:48 PM    &#060;DIR&#062;          ..
06/19/2007  04:46 PM    &#060;DIR&#062;          Desktop
06/19/2007  03:20 PM    &#060;DIR&#062;          Favorites
06/19/2007  04:46 PM    &#060;DIR&#062;          My Documents
12/29/2004  01:07 PM            61,440 nc.exe
10/10/2005  05:45 PM    &#060;DIR&#062;          Start Menu
1 File(s)         61,440 bytes
6 Dir(s)     764,071,936 bytes free

C:\Documents and Settings\paul&#062;
</screen>
<para>Typing <command>exit</command> at the cmd.exe shell will end the connection.</para>
<screen>
C:\Documents and Settings\paul&#062;exit
paul@laika:~$ 
</screen>
<para>It can be useful to change lowercase l to uppercase L, which will restart the netcat listening when the connection is broken.</para>
<screen>nc -L -p 500 -e cmd.exe</screen>
<para>The next screenshot shows the automatic restart of nc on the target machine, and the contents of the shovel.bat batchfile that accomnplishes this automatic restart.</para>
<screen>
paul@laika:~$ nc 192.168.1.48 500
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
	
C:\Documents and Settings\paul&#062;exit
paul@laika:~$ nc 192.168.1.48 500
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
	
C:\Documents and Settings\paul&#062;type shovel.bat
type shovel.bat
nc -L -p 500 -e cmd.exe 
	
C:\Documents and Settings\paul&#062;exit
paul@laika:~$ 
</screen>
</appendix>
<appendix><title>The net share command</title>
	<para>How to create a shared folder in Windows.</para>
	<screen>
C:\&#062;md c:\share1

C:\&#062;dir
Volume in drive C has no label.
Volume Serial Number is F85C-CC93

Directory of C:\

03/07/2007  09:27p      &#060;DIR&#062;          Documents and Settings
06/19/2007  05:23p      &#060;DIR&#062;          Program Files
06/19/2007  05:37p      &#060;DIR&#062;          share1
06/19/2007  03:05p      &#060;DIR&#062;          WINNT
0 File(s)              0 bytes
4 Dir(s)   4,577,640,448 bytes free

C:\&#062;net share firstshare=c:\share1
firstshare was shared successfully.


C:\&#062;net view W2000
Shared resources at W2000


Share name   Type         Used as  Comment

-------------------------------------------------------------------------------
firstshare   Disk                                                              
The command completed successfully.


C:\&#062;
	</screen>
</appendix>
<appendix><title>Serving a BSD-style printer</title>
	<para>First we set up a BSD-style printer. Read the manpage of printcap for more information.</para>
	<para>The we create a .config file for <command>smbprint</command> in the spool directory for this printer (and set the correct owner and permissions for this directory). The printer is shared on a Windows 98 computer named w98 as \\w98\hp.</para>
	<screen>
[root@RHEL4b samba]# cd /var/spool/lpd/
[root@RHEL4b lpd]# mkdir w98
[root@RHEL4b lpd]# chown lp:lp w98/
[root@RHEL4b lpd]# chmod 700 w98
[root@RHEL4b lpd]# cd w98/
[root@RHEL4b w98]# chown lp:lp .config 
[root@RHEL4b w98]# chmod 600 .config 
[root@RHEL4b w98]# echo server=w98 > .config 
[root@RHEL4b w98]# echo service=hp >> .config 
[root@RHEL4b w98]# echo password="" >> .config 
[root@RHEL4b w98]# cat .config 
server=w98
service=hp
password=
[root@RHEL4b w98]# echo 192.168.1.55 w98 >> /etc/hosts
	</screen>
</appendix>	
</book>
